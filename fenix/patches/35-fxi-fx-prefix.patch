Description: Rename the f{sin,cos,mul,div}() functions to fx*.
 Avoid a conflict with functions defined by the math.h standard
 header file in recent versions of glibc.
Bug-Debian: https://bugs.debian.org/917982
Forwarded: no
Author: Peter Pentchev <roam@ringlet.net>
Last-Update: 2019-01-18

--- a/fxi/inc/fmath.h
+++ b/fxi/inc/fmath.h
@@ -101,7 +101,7 @@
 	return x / FIXED_PREC ;
 }
 
-__INLINE fixed fcos(int x)
+__INLINE fixed fxcos(int x)
 {
 if (x < 0) x = -x ;
 if (x >= 360000) x %= 360000 ;
@@ -111,9 +111,9 @@
 return cos_table[x] ;
 }
 
-__INLINE fixed fsin(int x)
+__INLINE fixed fxsin(int x)
 {
-if (x < 0) return -fsin(-x) ;
+if (x < 0) return -fxsin(-x) ;
 if (x >= 360000) x %= 360000 ;
 if (x >= 270000) return -cos_table[x - 270000] ;
 if (x >= 180000) return -cos_table[270000 - x] ;
@@ -121,12 +121,12 @@
 return cos_table[90000 - x] ;
 }
 
-__INLINE fixed fmul(int x, int y)
+__INLINE fixed fxmul(int x, int y)
 {
 	return ftofix (fixtof(x) * fixtof(y)) ;
 }
 
-__INLINE fixed fdiv(int x, int y)
+__INLINE fixed fxdiv(int x, int y)
 {
 	return ftofix (fixtof(x) / fixtof(y)) ;
 }
--- a/fxi/src/g_mode7.c
+++ b/fxi/src/g_mode7.c
@@ -117,8 +117,8 @@
  *
  * */
 
-#define ROTATEDX(x,y,sina,cosa) (fmul(x,cosa) - fmul(y,sina))
-#define ROTATEDY(x,y,sina,cosa) (fmul(x,sina) + fmul(y,cosa))
+#define ROTATEDX(x,y,sina,cosa) (fxmul(x,cosa) - fxmul(y,sina))
+#define ROTATEDY(x,y,sina,cosa) (fxmul(x,sina) + fxmul(y,cosa))
 
 /* Esta estructura guarda información que se recalcula a cada frame.
  * Quizá no sería necesario recalcularlo todo. El incremento podría
@@ -189,8 +189,8 @@
 
     angle = LOCDWORD(camera, ANGLE) ;
 
-    cosa = fcos (-angle) ;
-    sina = fsin (-angle) ;
+    cosa = fxcos (-angle) ;
+    sina = fxsin (-angle) ;
 
     /* Averigua la posición de inicio */
 
@@ -237,8 +237,8 @@
         }
         //if (point_z >= camera_z) break ;
 
-        lines[y].left_bmp_x = fdiv( fmul((point_x - camera_x), -camera_z), (point_z - camera_z) ) + camera_x ;
-        lines[y].left_bmp_y = fdiv( fmul((point_y - camera_y), -camera_z), (point_z - camera_z) ) + camera_y ;
+        lines[y].left_bmp_x = fxdiv( fxmul((point_x - camera_x), -camera_z), (point_z - camera_z) ) + camera_x ;
+        lines[y].left_bmp_y = fxdiv( fxmul((point_y - camera_y), -camera_z), (point_z - camera_z) ) + camera_y ;
 
         /* Lo mismo para el punto (width,y) */
 
@@ -252,8 +252,8 @@
 
         //if (point_z >= camera_z) break ;
 
-        lines[y].right_bmp_x = fdiv(fmul((point_x - camera_x), -camera_z), (point_z - camera_z)) + camera_x ;
-        lines[y].right_bmp_y = fdiv(fmul((point_y - camera_y), -camera_z), (point_z - camera_z)) + camera_y ;
+        lines[y].right_bmp_x = fxdiv(fxmul((point_x - camera_x), -camera_z), (point_z - camera_z)) + camera_x ;
+        lines[y].right_bmp_y = fxdiv(fxmul((point_y - camera_y), -camera_z), (point_z - camera_z)) + camera_y ;
 
         /* Averigua el incremento necesario para cada paso de la línea */
 
--- a/fxi/src/i_func.c
+++ b/fxi/src/i_func.c
@@ -254,8 +254,8 @@
 
     angle = LOCDWORD(my,ANGLE) ;
     if (!cos_table_initialized) init_cos_tables() ;
-    LOCDWORD(my,COORDX) += fixtoi(fixceil(fmul(fcos(angle), itofix(params[0])))) ;
-    LOCDWORD(my,COORDY) -= fixtoi(fixceil(fmul(fsin(angle), itofix(params[0])))) ;
+    LOCDWORD(my,COORDX) += fixtoi(fixceil(fxmul(fxcos(angle), itofix(params[0])))) ;
+    LOCDWORD(my,COORDY) -= fixtoi(fixceil(fxmul(fxsin(angle), itofix(params[0])))) ;
     return 1 ;
 }
 
@@ -265,8 +265,8 @@
 
     angle = params[0] ;
     if (!cos_table_initialized) init_cos_tables() ;
-    LOCDWORD(my,COORDX) += fixtoi(fixceil(fmul(fcos(angle), itofix(params[1])))) ;
-    LOCDWORD(my,COORDY) -= fixtoi(fixceil(fmul(fsin(angle), itofix(params[1])))) ;
+    LOCDWORD(my,COORDX) += fixtoi(fixceil(fxmul(fxcos(angle), itofix(params[1])))) ;
+    LOCDWORD(my,COORDY) -= fixtoi(fixceil(fxmul(fxsin(angle), itofix(params[1])))) ;
     return 1 ;
 }
 
