diff -Nur orig/extra/py/bmpanel2cfg mod/extra/py/bmpanel2cfg
--- orig/extra/py/bmpanel2cfg	2020-03-24 21:09:20.000000000 +0100
+++ mod/extra/py/bmpanel2cfg	1970-01-01 01:00:00.000000000 +0100
@@ -1,702 +0,0 @@
-#!/usr/bin/env python
-
-import bmpanel2
-import gtk, gobject
-from gtk import gdk
-import sys
-
-configfile = None
-if len(sys.argv) == 2:
-	configfile = sys.argv[1]
-
-g_remote = bmpanel2.Bmpanel2Remote(configfile)
-g_config = bmpanel2.Bmpanel2Config(configfile)
-g_launch = bmpanel2.Bmpanel2Launchbar(g_config)
-
-#----------------------------------------------------------------------
-from threading import Thread
-
-class ThemeDeferredLoader(Thread):
-	def __init__(self, view, model, callback):
-		Thread.__init__(self)
-		self.gui_view = view
-		self.gui_model = model
-		self.gui_callback = callback
-
-	def run(self):
-		view = self.gui_view
-		model = self.gui_model
-
-		themes = bmpanel2.Bmpanel2Themes()
-		gdk.threads_enter()
-		for t in themes.themes:
-			name = t.dirname
-			if t.name:
-				name = t.name
-			model.append((name, t, t.path))
-		current_theme = g_config.get_theme()
-		current_theme_num = 0
-
-		for i in xrange(len(model)):
-			if model[i][1].dirname == current_theme:
-				current_theme_num = i
-				break
-
-		view.set_cursor((current_theme_num,))
-		view.scroll_to_cell((current_theme_num,))
-		view.get_selection().connect('changed', self.gui_callback)
-		view.set_sensitive(True)
-		view.set_tooltip_column(2)
-		gdk.threads_leave()
-#----------------------------------------------------------------------
-
-def reconfigure():
-	g_config.save()
-	g_remote.reconfigure()
-
-def reconfigure_and_reload_theme():
-	g_config.save()
-	g_remote.reconfigure(True)
-
-#----------------------------------------------------------------------
-# ThemesListbox
-#----------------------------------------------------------------------
-class ThemesListbox:
-	def __init__(self):
-		scroll = gtk.ScrolledWindow()
-		scroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
-		scroll.set_shadow_type(gtk.SHADOW_IN)
-
-		model = gtk.ListStore(gobject.TYPE_STRING,
-					gobject.TYPE_PYOBJECT,
-					gobject.TYPE_STRING)
-		renderer = gtk.CellRendererText()
-		column = gtk.TreeViewColumn("Theme", renderer, text=0)
-		view = gtk.TreeView(model)
-		view.append_column(column)
-		view.set_sensitive(False)
-
-		theme_loader = ThemeDeferredLoader(view, model, self.view_cursor_changed)
-		theme_loader.start()
-
-		scroll.add(view)
-		scroll.set_size_request(200, -1)
-		self.widget = scroll
-
-	def view_cursor_changed(self, selection):
-		(model, it) = selection.get_selected()
-		if not it:
-			return
-		theme = model.get_value(it, 1)
-		g_config.set_theme(theme.dirname)
-		reconfigure_and_reload_theme()
-
-#----------------------------------------------------------------------
-# Parameters Table
-#----------------------------------------------------------------------
-def make_alternatives_selector(config, choices, reconf=reconfigure_and_reload_theme):
-	choices.insert(0, "none")
-	model = gtk.ListStore(gobject.TYPE_STRING)
-	for c in choices:
-		model.append((c,))
-
-	current = []
-	try: current += config.get_preferred_alternatives().split()
-	except: pass
-
-	i = None
-	for c in current:
-		try:
-			i = choices.index(c)
-			break
-		except:
-			pass
-
-	w = gtk.ComboBox(model)
-	if i:
-		w.set_active(i)
-	else:
-		w.set_active(0)
-	cell = gtk.CellRendererText()
-	w.pack_start(cell, True)
-	w.add_attribute(cell, 'text', 0)
-
-	def changed(combo, choices):
-		c = choices[combo.get_active()]
-
-		current = set()
-		try: current.add(config.get_preferred_alternatives().split())
-		except: pass
-
-		for choice in choices:
-			current.discard(choice)
-		if c != "none":
-			current.add(c)
-		config.set_preferred_alternatives(" ".join(current))
-		reconf()
-
-	w.connect('changed', changed, choices)
-	return w
-
-def make_boolean(setter, getter, reconf=reconfigure):
-	w = gtk.CheckButton()
-	w.set_active(getter())
-	def changed(checkbox):
-		active = checkbox.get_active()
-		setter(active)
-		reconf()
-	w.connect('toggled', changed)
-	return w
-
-def make_string(setter, getter, reconf=reconfigure):
-	w = gtk.Entry()
-	try:
-		w.set_text(getter())
-	except:
-		pass
-
-	def changed(entry):
-		text = entry.get_text()
-		setter(text)
-		reconf()
-	w.connect('changed', changed)
-	return w
-
-def make_number(setter, getter, mmin, mmax, reconf=reconfigure):
-	w = gtk.SpinButton()
-	w.set_increments(1,5)
-	w.set_range(mmin, mmax)
-	w.set_value(getter())
-	def changed(num):
-		n = num.get_value_as_int()
-		setter(n)
-		reconf()
-	w.connect('value-changed', changed)
-	return w
-
-class ParametersTable:
-	def __init__(self):
-		table = gtk.Table(1,2)
-		table.set_row_spacings(5)
-
-		align = gtk.Alignment(0,0,1,1)
-		align.set_padding(0, 5, 0, 0)
-		align.add(table)
-
-		frame = gtk.Frame("Parameters")
-		frame.set_border_width(5)
-		frame.add(align)
-
-		self.widget = frame
-		self.table = table
-
-		e = make_string(g_config.set_clock_prog,
-				g_config.get_clock_prog)
-		self.add_row("Clock program:", e)
-
-		e = make_boolean(g_config.set_task_urgency_hint,
-				g_config.get_task_urgency_hint)
-		self.add_row("Task urgency hint:", e)
-
-		e = make_number(g_config.set_drag_threshold,
-				g_config.get_drag_threshold, 0, 9999)
-		self.add_row("Drag threshold:", e)
-
-		e = make_number(g_config.set_task_death_threshold,
-				g_config.get_task_death_threshold, 0, 9999)
-		self.add_row("Task death threshold:", e)
-
-		#-----------------------------------------------------
-		self.add_separator()
-
-		e = make_string(g_config.set_task_visible_monitors,
-				g_config.get_task_visible_monitors)
-		self.add_row("Task visible monitors:", e)
-
-		monitors_n = gtk.gdk.screen_get_default().get_n_monitors()
-		e = make_number(g_config.set_monitor,
-				g_config.get_monitor, 0, monitors_n - 1,
-				reconfigure_and_reload_theme)
-		self.add_row("Monitor:", e)
-
-		e = make_boolean(g_config.set_pager_current_monitor_only,
-                                 g_config.get_pager_current_monitor_only)
-		self.add_row("Pager shows current\nmonitor only:", e)
-
-		#-----------------------------------------------------
-		self.add_separator()
-		self.add_label("Alternatives:")
-
-		e = make_alternatives_selector(g_config, ["pager", "desktop_switcher"])
-		self.add_row(None, e)
-
-	def add_separator(self):
-		sep = gtk.HSeparator()
-		row = self.table.props.n_rows
-		self.table.attach(sep, 0, 2, row, row+1, gtk.FILL, 0, 5, 0)
-
-	def add_label(self, label_text):
-		label = gtk.Label(label_text)
-		label.set_alignment(0, 0)
-		row = self.table.props.n_rows
-		self.table.attach(label, 0, 2, row, row+1, gtk.FILL, 0, 5, 0)
-
-	def add_row(self, label_text, widget):
-		row = self.table.props.n_rows
-		if label_text is not None:
-			label = gtk.Label(label_text)
-			label.set_alignment(0, 0)
-			self.table.attach(label, 0, 1, row, row+1, gtk.EXPAND | gtk.FILL, 0, 5, 0)
-		self.table.attach(widget, 1, 2, row, row+1, gtk.FILL, 0, 5, 0)
-
-#----------------------------------------------------------------------
-# IconList
-#----------------------------------------------------------------------
-class Icon:
-	def __init__(self, prog=None, icon=None, pixbuf=None):
-		self.prog = prog
-		self.icon = icon
-		self.pixbuf = pixbuf
-
-	def set(self, prog=None, icon=None, pixbuf=None):
-		self.prog = prog
-		self.icon = icon
-		self.pixbuf = pixbuf
-
-
-class IconList(gtk.Widget):
-	def __init__(self, changed_cb, icon_size = 32):
-		gtk.Widget.__init__(self)
-		self.icon_size = icon_size
-		self.icons = []
-		self.active = -1
-		self.active_changed = []
-		self.changed_cb = changed_cb
-
-	def do_realize(self):
-		self.set_flags(self.flags() | gtk.REALIZED)
-
-		self.window = gtk.gdk.Window(
-			self.get_parent_window(),
-			width = self.allocation.width,
-			height = self.allocation.height,
-			window_type = gdk.WINDOW_CHILD,
-			wclass = gdk.INPUT_OUTPUT,
-			event_mask = self.get_events() | gdk.EXPOSURE_MASK | gtk.gdk.BUTTON_PRESS_MASK
-		)
-
-		self.window.set_user_data(self)
-		self.style.attach(self.window)
-		self.style.set_background(self.window, gtk.STATE_NORMAL)
-		self.window.move_resize(*self.allocation)
-
-		self.connect('expose-event', self._expose_event)
-		self.connect('button-press-event', self._button_press_event)
-
-	def do_unrealize(self):
-		self.window.set_user_data(None)
-
-	def do_size_request(self, requisition):
-		requisition.height = self.icon_size
-		requisition.width = len(self.icons) * self.icon_size
-
-	def do_size_allocate(self, allocation):
-		self.allocation = allocation
-
-		if self.flags() & gtk.REALIZED:
-			self.window.move_resize(*allocation)
-
-	def _expose_event(self, widget, event):
-		gc = self.style.fg_gc[gtk.STATE_NORMAL]
-		for i in xrange(len(self.icons)):
-			icon = self.icons[i]
-			self._draw_icon_centered(icon.pixbuf, self.icon_size * i, i == self.active)
-
-	def _button_press_event(self, widget, event):
-		i = event.x / self.icon_size
-		if len(self.icons) > i and i >= 0:
-			self.active = int(i)
-			self._update_gui()
-
-	# draw utils
-	def _draw_icon_centered(self, icon, xoff, active=False):
-		gc = self.style.bg_gc[gtk.STATE_SELECTED]
-
-		if active:
-			self.window.draw_rectangle(gc, True, xoff, 0, self.icon_size, self.icon_size)
-		if not icon:
-			hs = self.icon_size / 2
-			s = (self.icon_size - hs) / 2
-			self.window.draw_rectangle(gc, True, xoff+s, s, hs, hs)
-		else:
-			w = icon.get_width()
-			h = icon.get_height()
-			x = (self.icon_size - w) / 2
-			y = (self.icon_size - h) / 2
-			self.window.draw_pixbuf(gc, icon, 0, 0, xoff+x, y, -1, -1)
-
-	def _update_gui(self):
-		self.set_size_request(self.icon_size * len(self.icons), self.icon_size)
-		if self.flags() & gtk.REALIZED:
-			rect = gtk.gdk.Rectangle(0,0,self.allocation[2],self.allocation[3])
-			self.window.invalidate_rect(rect, True)
-
-		for cb in self.active_changed:
-			cb(self.active)
-
-	# ----------------------------------------------------------------
-	def _load_pixbuf_for_icon(self, icon):
-		pixbuf = None
-		if icon:
-			pixbuf = gtk.gdk.pixbuf_new_from_file(icon)
-			if pixbuf.get_width() > self.icon_size or pixbuf.get_height() > self.icon_size:
-				pixbuf = pixbuf.scale_simple(self.icon_size, self.icon_size, gtk.gdk.INTERP_HYPER)
-		return pixbuf
-
-	def _validate_active(self):
-		if not len(self.icons):
-			self.active = -1
-			return
-		if self.active < 0:
-			self.active = 0
-		if self.active >= len(self.icons):
-			self.active = len(self.icons)-1
-
-	def insert(self, where_index, prog=None, icon=None):
-		assert(where_index >= 0 and where_index < len(self.icons))
-		try:
-			ic = Icon(prog, icon, self._load_pixbuf_for_icon(icon))
-		except:
-			return
-		self.icons.insert(where_index, ic)
-		self._update_gui()
-
-	def remove(self, where_index):
-		assert(where_index >= 0 and where_index < len(self.icons))
-		commit_change = False
-		if self.icons[where_index].icon != None and self.icons[where_index].prog != None:
-			commit_change = True
-		del self.icons[where_index]
-		self._validate_active()
-		self._update_gui()
-		if commit_change:
-			self.changed_cb()
-
-	def change(self, where_index, prog, icon):
-		assert(where_index >= 0 and where_index < len(self.icons))
-		self.icons[where_index].set(prog, icon, self._load_pixbuf_for_icon(icon))
-		if prog != None and icon != None:
-			self.changed_cb()
-		self._update_gui()
-
-	def move(self, where_index, offset):
-		assert(where_index >= 0 and where_index < len(self.icons))
-		dest = where_index + offset
-		# clamp dest
-		if dest < 0:
-			dest = 0
-		if dest >= len(self.icons):
-			dest = len(self.icons)-1
-
-		if dest == where_index:
-			return
-		if offset > 0:
-			dest += 1
-
-		ic = self.icons[where_index]
-		self.icons.insert(dest, ic)
-		if offset > 0:
-			del self.icons[where_index]
-		elif offset < 0:
-			del self.icons[where_index+1]
-		self.active += offset
-		# clamp active
-		self._validate_active()
-		self.changed_cb()
-		self._update_gui()
-
-	# utility
-	def append(self, prog=None, icon=None):
-		try:
-			ic = Icon(prog, icon, self._load_pixbuf_for_icon(icon))
-		except:
-			return
-		self.icons.append(ic)
-		self._update_gui()
-
-gobject.type_register(IconList)
-
-#----------------------------------------------------------------------
-
-class LaunchbarItem:
-	def __init__(self, prog, icon):
-		self.prog = prog
-		self.icon = icon
-
-class LaunchbarEditor:
-	def __init__(self):
-		self.items = []
-		self.parse_items()
-		self.build_gui()
-
-	def build_toolbar(self, iconlist):
-		hbox = gtk.HBox()
-		vbox = gtk.VBox()
-		hbox.pack_start(vbox, False)
-
-		# <- Move left
-		but = gtk.Button()
-		but.set_focus_on_click(False)
-		but.set_relief(gtk.RELIEF_NONE)
-		but.set_image(gtk.image_new_from_stock(gtk.STOCK_GO_BACK, gtk.ICON_SIZE_SMALL_TOOLBAR))
-		def click(widget):
-			if iconlist.active == -1:
-				return
-			iconlist.move(iconlist.active, -1)
-		but.connect('clicked', click)
-		vbox.pack_start(but, False)
-
-		# + Add
-		but = gtk.Button()
-		but.set_focus_on_click(False)
-		but.set_relief(gtk.RELIEF_NONE)
-		but.set_image(gtk.image_new_from_stock(gtk.STOCK_ADD, gtk.ICON_SIZE_SMALL_TOOLBAR))
-		def click(widget):
-			if iconlist.active != -1:
-				iconlist.insert(iconlist.active)
-			else:
-				iconlist.append()
-		but.connect('clicked', click)
-		vbox.pack_start(but, False)
-
-		vbox = gtk.VBox()
-		hbox.pack_start(vbox, False)
-
-		# -> Move right
-		but = gtk.Button()
-		but.set_focus_on_click(False)
-		but.set_relief(gtk.RELIEF_NONE)
-		but.set_image(gtk.image_new_from_stock(gtk.STOCK_GO_FORWARD, gtk.ICON_SIZE_SMALL_TOOLBAR))
-		def click(widget):
-			if iconlist.active == -1:
-				return
-			iconlist.move(iconlist.active, 1)
-		but.connect('clicked', click)
-		vbox.pack_start(but, False)
-
-		# - Remove
-		but = gtk.Button()
-		but.set_focus_on_click(False)
-		but.set_relief(gtk.RELIEF_NONE)
-		but.set_image(gtk.image_new_from_stock(gtk.STOCK_REMOVE, gtk.ICON_SIZE_SMALL_TOOLBAR))
-		def click(widget):
-			if iconlist.active == -1:
-				return
-			iconlist.remove(iconlist.active)
-		but.connect('clicked', click)
-		vbox.pack_start(but, False)
-
-		align = gtk.Alignment(0.5,0.5)
-		align.add(hbox)
-
-		return align
-
-	def build_edit(self, iconlist):
-		table = gtk.Table(1,2)
-		table.set_row_spacings(5)
-		def add_row(label_text, widget):
-			label = gtk.Label(label_text)
-			label.set_alignment(0, 0)
-			row = table.props.n_rows
-			table.attach(label, 0, 1, row, row+1, gtk.FILL, 0, 5, 0)
-			table.attach(widget, 1, 2, row, row+1, gtk.EXPAND | gtk.FILL, 0, 5, 0)
-
-		e1 = gtk.Entry()
-		filedialog = gtk.FileChooserDialog("Select an icon")
-		filedialog.add_buttons(gtk.STOCK_OK, gtk.RESPONSE_OK,
-				gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
-		filefilter = gtk.FileFilter()
-		filefilter.add_mime_type("image/png")
-		filedialog.set_filter(filefilter)
-		e2 = gtk.FileChooserButton(filedialog)
-
-		# preview
-		preview = gtk.Image()
-		e2.set_preview_widget(preview)
-		def update_preview_cb(file_chooser, preview):
-			filename = file_chooser.get_preview_filename()
-			try:
-				pixbuf = gtk.gdk.pixbuf_new_from_file(filename)
-				preview.set_from_pixbuf(pixbuf)
-				have_preview = True
-			except:
-				have_preview = False
-			file_chooser.set_preview_widget_active(have_preview)
-		e2.connect('update-preview', update_preview_cb, preview)
-		e1.set_sensitive(False)
-		e2.set_sensitive(False)
-
-		# callback for changed event
-		def e1_edited(widget):
-			text = widget.get_text()
-			active = iconlist.active
-			if active != -1:
-				a = iconlist.icons[active]
-				iconlist.change(active, text, a.icon)
-		e1.connect('changed', e1_edited)
-
-		# callback for file dialog response event
-		def file_dialog_response(dialog, response):
-			filename = dialog.get_filename()
-			active = iconlist.active
-			if response != gtk.RESPONSE_OK:
-				if active != -1:
-					icon = iconlist.icons[active].icon
-					if icon:
-						e2.set_filename(iconlist.icons[active].icon)
-					else:
-						e2.unselect_all()
-				return
-			if active != -1:
-				a = iconlist.icons[active]
-				iconlist.change(active, a.prog, filename)
-		filedialog.connect('response', file_dialog_response)
-
-		# callback for iconlist
-		def active_changed_cb(active):
-			e1.handler_block_by_func(e1_edited)
-			if active != -1:
-				e1.set_sensitive(True)
-				e2.set_sensitive(True)
-				prog = iconlist.icons[active].prog
-				if prog:
-					e1.set_text(prog)
-				else:
-					e1.set_text("")
-				icon = iconlist.icons[active].icon
-				if icon:
-					e2.set_filename(icon)
-				else:
-					e2.unselect_all()
-			else:
-				e1.set_text("")
-				e2.unselect_all()
-				e1.set_sensitive(False)
-				e2.set_sensitive(False)
-			e1.handler_unblock_by_func(e1_edited)
-		iconlist.active_changed.append(active_changed_cb)
-
-		# add widgets to table
-		add_row("Program:", e1)
-		add_row("Icon:", e2)
-
-		align = gtk.Alignment(0,0,1,1)
-		align.set_padding(0, 5, 0, 0)
-		align.add(table)
-
-		return align
-
-	def build_gui(self):
-		w = IconList(self.save_items)
-		for i in self.items:
-			w.append(i.prog, i.icon)
-
-		scroll = gtk.ScrolledWindow()
-		scroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_NEVER)
-		scroll.add_with_viewport(w)
-		scroll.get_child().set_shadow_type(gtk.SHADOW_NONE)
-		def scrollchresize(cont, event):
-			adj = cont.get_hadjustment()
-			if adj.page_size == adj.upper:
-				(width,h) = w.size_request()
-				cont.set_size_request(-1, h)
-			else:
-				cont.set_size_request(-1, -1)
-		scroll.connect('size-allocate', scrollchresize)
-
-		hbox = gtk.HBox()
-		hbox.pack_start(self.build_edit(w), True)
-		hbox.pack_start(gtk.VSeparator(), False)
-		hbox.pack_start(self.build_toolbar(w), False)
-
-		vbox = gtk.VBox()
-		vbox.pack_start(scroll, False)
-		vbox.pack_start(gtk.HSeparator(), False)
-		vbox.pack_start(hbox, False)
-
-		frame = gtk.Frame("Launch bar")
-		frame.set_border_width(5)
-		frame.add(vbox)
-
-		self.iconlist = w
-		self.widget = frame
-
-	def parse_items(self):
-		for i in g_launch:
-			self.items.append(LaunchbarItem(i.prog, i.icon))
-
-	def save_items(self):
-		lb = g_config.tree['launchbar']
-		children = lb.children[:]
-		for i in children:
-			g_config.tree.remove_node(i)
-		for i in self.iconlist.icons:
-			if not i.prog or not i.icon:
-				continue
-			node = bmpanel2.ConfigNode(name="exec", value=i.prog)
-			g_config.tree.append_node_as_child(node, lb)
-			node2 = bmpanel2.ConfigNode(name="icon", value=i.icon)
-			g_config.tree.append_node_as_child(node2, node)
-		reconfigure()
-
-gdk.threads_init()
-
-def delete_window(widget, event):
-	# check for incomplete icons in launchbar editor, and warn the user about it
-	incomplete_exists = False
-	for i in lbedit.iconlist.icons:
-		if not i.prog or not i.icon:
-			incomplete_exists = True
-			break
-
-	if incomplete_exists:
-		d = gtk.MessageDialog(type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_OK_CANCEL)
-		d.set_markup("There are incomplete items in the launch bar editor, "
-			"they will not be saved. Are you sure you want to quit?")
-		response = d.run()
-		d.destroy()
-		if response == gtk.RESPONSE_CANCEL:
-			return True
-	return False
-
-def die(widget, data=None):
-	gtk.main_quit()
-
-win = gtk.Window(gtk.WINDOW_TOPLEVEL)
-win.set_title("Bmpanel2 Config")
-win.connect('destroy', die)
-win.connect('delete-event', delete_window)
-
-themeslb = ThemesListbox()
-paramtbl = ParametersTable()
-lbedit = LaunchbarEditor()
-
-hbox = gtk.HBox()
-hbox.pack_start(paramtbl.widget, False, True)
-hbox.pack_start(themeslb.widget, True, True)
-
-vbox = gtk.VBox()
-vbox.pack_start(hbox)
-vbox.pack_start(lbedit.widget, False, True)
-
-win.add(vbox)
-win.show_all()
-
-if g_remote.started_with_theme:
-	d = gtk.MessageDialog(type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_OK)
-	d.set_markup("Bmpanel2 was started with <b>--theme</b> parameter. "
-		"It means it will not react on theme changes in the config file (via this tool or not).")
-	d.run()
-	d.destroy()
-
-gtk.main()
diff -Nur orig/extra/py/bmpanel2.py mod/extra/py/bmpanel2.py
--- orig/extra/py/bmpanel2.py	2020-03-24 21:09:20.000000000 +0100
+++ mod/extra/py/bmpanel2.py	2020-04-04 19:19:19.089818266 +0200
@@ -12,579 +12,597 @@
 to your project and use it in any imaginable way.
 """
 
-import sys, os
-
-#----------------------------------------------------------------------
+from builtins import object
+import os
+# ----------------------------------------------------------------------
 # Config parser.
 #
 # This version may be slow, but it should do some extra stuff, like
 # keeping comments and formatting. It should be really friendly in that
 # kind of area.
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
+
 
 def _parse_indent(line):
-	"""
-	This function is used for parsing indents, it returns the
-	contents of an indent area and the count of indent symbols.
-	"""
-	offset = 0
-	contents = ""
-	for c in line:
-		if c.isspace():
-			offset += 1
-			contents = contents + c
-		else:
-			break
+    """
+    This function is used for parsing indents, it returns the
+    contents of an indent area and the count of indent symbols.
+    """
+    offset = 0
+    contents = ""
+    for ccc in line:
+        if ccc.isspace():
+            offset += 1
+            contents = contents + ccc
+        else:
+            break
 
-	return (contents, offset)
+    return (contents, offset)
 
 # ConfigNode types
-CONFIG_NODE_NAME_VALUE	= 1
-CONFIG_NODE_COMMENT	= 2
-CONFIG_NODE_EMPTY	= 3
-
-class ConfigNode:
-	def __init__(self, **kw):
-		"""
-		Init a node with initial values. Possible are:
-		 - 'name': The name of the node. Or it also serves as
-		   contents of the comment line, you should include '#'
-		   symbol in that case too.
-		 - 'value': The value of the node.
-		 - 'type': The type - CONFIG_NODE_*, the default is
-		   CONFIG_NODE_NAME_VALUE.
-		 - 'parent': The parent of this node.
-		"""
-		self.name = None
-		if 'name' in kw:
-			self.name = kw['name']
-		self.value = None
-		if 'value' in kw:
-			self.value = kw['value']
-		self.type = CONFIG_NODE_NAME_VALUE
-		if 'type' in kw:
-			self.type = kw['type']
-		self.parent = None
-		if 'parent' in kw:
-			self.parent = kw['parent']
-		self.children = []
-		self.indent_contents = ""
-		self.indent_offset = 0
-		self.children_offset = -1
-
-	def is_child(self, indent_offset):
-		"""
-		Using 'indent_offset' figures out is the node with that
-		offset is a child of this node. Also updates
-		'children_offset' implicitly.
-		"""
-		if self.children_offset != -1:
-			return self.children_offset == indent_offset
-		elif self.indent_offset < indent_offset:
-			self.children_offset = indent_offset
-			return True
-		return False
-
-	def parse(self, line):
-		"""
-		Parse a line of text to a node.
-		"""
-		# check empty line
-		sline = line.strip()
-		if sline == "":
-			self.type = CONFIG_NODE_EMPTY
-			return
-
-		# non-empties have indent, parse it
-		(indent_contents, indent_offset) = _parse_indent(line)
-		self.indent_contents = indent_contents
-		self.indent_offset = indent_offset
-
-		# check comment (first non-indent symbol: #)
-		if line[indent_offset] == "#":
-			self.type = CONFIG_NODE_COMMENT
-			self.name = line[indent_offset:]
-			return
-
-		# and finally try to parse name/value
-		self.type = CONFIG_NODE_NAME_VALUE
-
-		cur = indent_offset
-
-		# name
-		name_beg = cur
-		while cur < len(line) and not line[cur].isspace():
-			cur += 1
-		name_end = cur
-		self.name = line[name_beg:name_end]
-
-		# value
-		value = line[name_end:].lstrip()
-		if value != "":
-			self.value = value
-
-	def make_child_of(self, parent):
-		"""
-		Make this node a child of the 'parent'. This method
-		doesn't add 'self' to the children list of the 'parent'.
-		You should do it manually. Updates 'children_offset'
-		implicitly.
-		"""
-		if parent.children_offset == -1:
-			parent.children_offset = parent.indent_offset + 1
-		co = parent.children_offset
-		self.indent_contents = co * "\t"
-		self.indent_offset = co
-		self.parent = parent
-
-	def __getitem__(self, item):
-		for c in self.children:
-			if c.name == item:
-				return c
-		raise KeyError, item
 
-#----------------------------------------------------------------------
+
+CONFIG_NODE_NAME_VALUE = 1
+CONFIG_NODE_COMMENT = 2
+CONFIG_NODE_EMPTY = 3
+
+
+class ConfigNode(object):
+    def __init__(self, **kw):
+        """
+        Init a node with initial values. Possible are:
+         - 'name': The name of the node. Or it also serves as
+           contents of the comment line, you should include '#'
+           symbol in that case too.
+         - 'value': The value of the node.
+         - 'type': The type - CONFIG_NODE_*, the default is
+           CONFIG_NODE_NAME_VALUE.
+         - 'parent': The parent of this node.
+        """
+        self.name = None
+        if 'name' in kw:
+            self.name = kw['name']
+        self.value = None
+        if 'value' in kw:
+            self.value = kw['value']
+        self.type = CONFIG_NODE_NAME_VALUE
+        if 'type' in kw:
+            self.type = kw['type']
+        self.parent = None
+        if 'parent' in kw:
+            self.parent = kw['parent']
+        self.children = []
+        self.indent_contents = ""
+        self.indent_offset = 0
+        self.children_offset = -1
+
+    def is_child(self, indent_offset):
+        """
+        Using 'indent_offset' figures out is the node with that
+        offset is a child of this node. Also updates
+        'children_offset' implicitly.
+        """
+        if self.children_offset != -1:
+            return self.children_offset == indent_offset
+        elif self.indent_offset < indent_offset:
+            self.children_offset = indent_offset
+            return True
+        return False
+
+    def parse(self, line):
+        """
+        Parse a line of text to a node.
+        """
+        # check empty line
+        sline = line.strip()
+        if sline == "":
+            self.type = CONFIG_NODE_EMPTY
+            return
+
+        # non-empties have indent, parse it
+        (indent_contents, indent_offset) = _parse_indent(line)
+        self.indent_contents = indent_contents
+        self.indent_offset = indent_offset
+
+        # check comment (first non-indent symbol: #)
+        if line[indent_offset] == "#":
+            self.type = CONFIG_NODE_COMMENT
+            self.name = line[indent_offset:]
+            return
+
+        # and finally try to parse name/value
+        self.type = CONFIG_NODE_NAME_VALUE
+
+        cur = indent_offset
+
+        # name
+        name_beg = cur
+        while cur < len(line) and not line[cur].isspace():
+            cur += 1
+        name_end = cur
+        self.name = line[name_beg:name_end]
+
+        # value
+        value = line[name_end:].lstrip()
+        if value != "":
+            self.value = value
+
+    def make_child_of(self, parent):
+        """
+        Make this node a child of the 'parent'. This method
+        doesn't add 'self' to the children list of the 'parent'.
+        You should do it manually. Updates 'children_offset'
+        implicitly.
+        """
+        if parent.children_offset == -1:
+            parent.children_offset = parent.indent_offset + 1
+        coo = parent.children_offset
+        self.indent_contents = coo * "\t"
+        self.indent_offset = coo
+        self.parent = parent
+
+    def __getitem__(self, item):
+        for ccc in self.children:
+            if ccc.name == item:
+                return ccc
+        raise_(KeyError, item)
+
+# ----------------------------------------------------------------------
 # ConfigFormat
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
+
+
 class ConfigFormat(ConfigNode):
-	def __init__(self, filename):
-		"""
-		Parse a config format file from the 'filename'.
-		"""
-		ConfigNode.__init__(self)
-		self.indent_offset = -1
-		self.filename = filename
-
-		data = ""
-		try:
-			with file(filename, "r") as f:
-				data = f.read()
-		except IOError:
-			pass
-		lines = data.splitlines()
-		nodes = []
-		parent = self
-		for line in lines:
-			node = ConfigNode()
-			node.parse(line)
-			nodes.append(node)
-
-			# add tree info
-			if node.type != CONFIG_NODE_NAME_VALUE:
-				continue
-
-			if parent.indent_offset < node.indent_offset:
-				if parent.is_child(node.indent_offset):
-					node.parent = parent
-					parent.children.append(node)
-					parent = node
-			else:
-				while parent.indent_offset >= node.indent_offset:
-					parent = parent.parent
-
-				if parent.is_child(node.indent_offset):
-					node.parent = parent
-					parent.children.append(node)
-					parent = node
-
-		self.nodes = nodes
-
-	def save(self, filename):
-		"""
-		Save config format file in the 'filename'. Function makes sure
-		that the dir for 'filename' exists, if not - tries to create it.
-		"""
-		d = os.path.dirname(filename)
-		if not os.path.exists(d):
-			os.makedirs(d)
-		with file(filename, "w") as f:
-			for node in self.nodes:
-				f.write(node.indent_contents)
-				if node.name:
-					f.write(node.name)
-				if node.value:
-					f.write(" ")
-					f.write(node.value)
-				f.write("\n")
-
-	def _find_last_node(self, root):
-		"""
-		Find an index in the nodes list of the last node in the
-		tree chain::
-
-		 ------------------------------------------
-		 one <---- ('root')
- 		 	two
-		 	three
-		 	four
-		 		five
-		 	six
-		 		seven <----(this one)
-		 ------------------------------------------
-		"""
-		if not len(root.children):
-			try:
-				return self.nodes.index(root)
-			except ValueError:
-				return 0
-
-		return self._find_last_node(root.children[-1])
-
-	def append_node_after(self, node, after):
-		"""
-		Append 'node' after another node. Handles both tree and
-		nodes list.
-		"""
-		parent = after.parent
-		nodei = parent.children.index(after)
-
-		node.make_child_of(parent)
-
-		i = self._find_last_node(after)
-		parent.children.insert(nodei+1, node)
-		self.nodes.insert(i+1, node)
-
-	def append_node_as_child(self, node, parent):
-		"""
-		Append 'node' as a child of the 'parent'. Handles both
-		tree and nodes list.
-		"""
-		node.make_child_of(parent)
-
-		i = self._find_last_node(parent)
-		parent.children.append(node)
-		self.nodes.insert(i+1, node)
-
-	def remove_node(self, node):
-		"""
-		Remove 'node' and all its children. Handles both tree
-		and nodes list.
-		"""
-		for c in node.children:
-			self.remove_node(c)
-
-		parent = node.parent
-		if not parent:
-			return
-		parent.children.remove(node)
-		self.nodes.remove(node)
+    def __init__(self, filename):
+        """
+        Parse a config format file from the 'filename'.
+        """
+        ConfigNode.__init__(self)
+        self.indent_offset = -1
+        self.filename = filename
+
+        data = ""
+        try:
+            with open(filename, "r") as fff:
+                data = fff.read()
+        except IOError:
+            pass
+        lines = data.splitlines()
+        nodes = []
+        parent = self
+        for line in lines:
+            node = ConfigNode()
+            node.parse(line)
+            nodes.append(node)
+
+            # add tree info
+            if node.type != CONFIG_NODE_NAME_VALUE:
+                continue
+
+            if parent.indent_offset < node.indent_offset:
+                if parent.is_child(node.indent_offset):
+                    node.parent = parent
+                    parent.children.append(node)
+                    parent = node
+            else:
+                while parent.indent_offset >= node.indent_offset:
+                    parent = parent.parent
+
+                if parent.is_child(node.indent_offset):
+                    node.parent = parent
+                    parent.children.append(node)
+                    parent = node
+
+        self.nodes = nodes
+
+    def save(self, filename):
+        """
+        Save config format file in the 'filename'. Function makes sure
+        that the dir for 'filename' exists, if not - tries to create it.
+        """
+        ddd = os.path.dirname(filename)
+        if not os.path.exists(ddd):
+            os.makedirs(ddd)
+        with open(filename, "w") as fff:
+            for node in self.nodes:
+                fff.write(node.indent_contents)
+                if node.name:
+                    fff.write(node.name)
+                if node.value:
+                    fff.write(" ")
+                    fff.write(node.value)
+                fff.write("\n")
+
+    def _find_last_node(self, root):
+        """
+        Find an index in the nodes list of the last node in the
+        tree chain::
+
+         ------------------------------------------
+         one <---- ('root')
+              two
+             three
+             four
+                 five
+             six
+                 seven <----(this one)
+         ------------------------------------------
+        """
+        if not (len(root.children) == 0):
+            try:
+                return self.nodes.index(root)
+            except ValueError:
+                return 0
+
+        return self._find_last_node(root.children[-1])
+
+    def append_node_after(self, node, after):
+        """
+        Append 'node' after another node. Handles both tree and
+        nodes list.
+        """
+        parent = after.parent
+        nodei = parent.children.index(after)
+
+        node.make_child_of(parent)
+
+        i = self._find_last_node(after)
+        parent.children.insert(nodei+1, node)
+        self.nodes.insert(i+1, node)
+
+    def append_node_as_child(self, node, parent):
+        """
+        Append 'node' as a child of the 'parent'. Handles both
+        tree and nodes list.
+        """
+        node.make_child_of(parent)
+
+        i = self._find_last_node(parent)
+        parent.children.append(node)
+        self.nodes.insert(i+1, node)
+
+    def remove_node(self, node):
+        """
+        Remove 'node' and all its children. Handles both tree
+        and nodes list.
+        """
+        for ccc in node.children:
+            self.remove_node(ccc)
+
+        parent = node.parent
+        if not parent:
+            return
+        parent.children.remove(node)
+        self.nodes.remove(node)
 
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
 # XDG functions
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
+
+
 def XDG_get_config_home():
-	"""
-	Return XDG_CONFIG_HOME directory according to XDG spec.
-	"""
-	xdghome = os.getenv("XDG_CONFIG_HOME")
-	if not xdghome:
-		xdghome = os.path.join(os.getenv("HOME"), ".config")
-	return xdghome
+    """
+    Return XDG_CONFIG_HOME directory according to XDG spec.
+    """
+    xdghome = os.getenv("XDG_CONFIG_HOME")
+    if not xdghome:
+        xdghome = os.path.join(os.getenv("HOME"), ".config")
+    return xdghome
+
 
 def XDG_get_data_dirs():
-	"""
-	Return XDG_DATA_HOME + XDG_DATA_DIRS array according to XDG spec.
-	"""
-	ret = []
-	xdgdata = os.getenv("XDG_DATA_HOME")
-	if not xdgdata:
-		xdgdata = os.path.join(os.getenv("HOME"), ".local/share")
-	ret.append(xdgdata)
-
-	xdgdirs = os.getenv("XDG_DATA_DIRS")
-	if xdgdirs:
-		ret += xdgdirs.split(":")
-	else:
-		ret.append("/usr/share")
-		ret.append("/usr/local/share")
-	return ret
+    """
+    Return XDG_DATA_HOME + XDG_DATA_DIRS array according to XDG spec.
+    """
+    ret = []
+    xdgdata = os.getenv("XDG_DATA_HOME")
+    if not xdgdata:
+        xdgdata = os.path.join(os.getenv("HOME"), ".local/share")
+    ret.append(xdgdata)
+
+    xdgdirs = os.getenv("XDG_DATA_DIRS")
+    if xdgdirs:
+        ret += xdgdirs.split(":")
+    else:
+        ret.append("/usr/share")
+        ret.append("/usr/local/share")
+    return ret
 
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
 # Bmpanel2Config
-#----------------------------------------------------------------------
-class Bmpanel2Config:
-	def _get_int_value(self, name, default):
-		try:
-			ret = int(self.tree[name].value)
-		except:
-			ret = default
-		return ret
-
-	def _set_int_value(self, name, value):
-		s = "{0}".format(value)
-		try:
-			node = self.tree[name]
-			node.value = s
-		except:
-			node = ConfigNode(name=name, value=s)
-			self.tree.append_node_as_child(node, self.tree)
-		self.fire_unsaved_notifiers(True)
-
-	def _get_str_value(self, name, default):
-		try:
-			ret = self.tree[name].value
-		except:
-			ret = default
-		return ret
-
-	def _set_str_value(self, name, value):
-		try:
-			node = self.tree[name]
-			node.value = value
-		except:
-			node = ConfigNode(name=name, value=value)
-			self.tree.append_node_as_child(node, self.tree)
-		self.fire_unsaved_notifiers(True)
-
-	def _get_bool_value(self, name):
-		try:
-			node = self.tree[name]
-			return True
-		except:
-			return False
-
-	def _set_bool_value(self, name, value):
-		try:
-			node = self.tree[name]
-			if not value:
-				self.tree.remove_node(node)
-		except:
-			if value:
-				node = ConfigNode(name=name)
-				self.tree.append_node_as_child(node, self.tree)
-		self.fire_unsaved_notifiers(True)
-	#--------------------------------------------------------------
-	def __init__(self, configfile=None):
-		if configfile:
-			self.path = configfile
-		else:
-			self.path = os.path.join(XDG_get_config_home(), "bmpanel2/bmpanel2rc")
-		self.tree = ConfigFormat(self.path)
-
-		# an array of function pointers
-		# function(state)
-		# where 'state' is a boolean
-		# functions are being called when there are:
-		# True - unsaved changes are here
-		# False - config was just saved, no unsaved changes
-		self.unsaved_notifiers = []
-
-	def add_unsaved_notifier(self, notifier):
-		self.unsaved_notifiers.append(notifier)
-
-	def fire_unsaved_notifiers(self, status):
-		for n in self.unsaved_notifiers:
-			n(status)
-
-	def save(self):
-		self.tree.save(self.path)
-		self.fire_unsaved_notifiers(False)
-		#self.tree.save("testrc")
-
-	def get_theme(self):
-		return self._get_str_value('theme', 'native')
-
-	def set_theme(self, value):
-		self._set_str_value('theme', value)
-
-	def get_task_death_threshold(self):
-		return self._get_int_value('task_death_threshold', 50)
-
-	def set_task_death_threshold(self, value):
-		self._set_int_value('task_death_threshold', value)
-
-	def get_drag_threshold(self):
-		return self._get_int_value('drag_threshold', 30)
-
-	def set_drag_threshold(self, value):
-		self._set_int_value('drag_threshold', value)
-
-	def get_task_urgency_hint(self):
-		return self._get_bool_value('task_urgency_hint')
-
-	def set_task_urgency_hint(self, value):
-		self._set_bool_value('task_urgency_hint', value)
-
-	def get_clock_prog(self):
-		return self._get_str_value('clock_prog', None)
-
-	def set_clock_prog(self, value):
-		self._set_str_value('clock_prog', value)
-
-	def get_monitor(self):
-		return self._get_int_value('monitor', 0)
-
-	def set_monitor(self, value):
-		self._set_int_value('monitor', value)
-
-	def get_task_visible_monitors(self):
-		return self._get_str_value('task_visible_monitors', '')
-
-	def set_task_visible_monitors(self, value):
-		self._set_str_value('task_visible_monitors', value)
-
-	def get_pager_current_monitor_only(self):
-		return self._get_bool_value('pager_current_monitor_only')
-
-	def set_pager_current_monitor_only(self, value):
-		self._set_bool_value('pager_current_monitor_only', value)
-
-	def get_preferred_alternatives(self):
-		return self._get_str_value('preferred_alternatives', '')
+# ----------------------------------------------------------------------
+
 
-	def set_preferred_alternatives(self, value):
-		self._set_str_value('preferred_alternatives', value)
+class Bmpanel2Config(object):
+    def _get_int_value(self, name, default):
+        try:
+            ret = int(self.tree[name].value)
+        except Exception:
+            ret = default
+        return ret
+
+    def _set_int_value(self, name, value):
+        sss = "{0}".format(value)
+        try:
+            node = self.tree[name]
+            node.value = sss
+        except Exception:
+            node = ConfigNode(name=name, value=sss)
+            self.tree.append_node_as_child(node, self.tree)
+        self.fire_unsaved_notifiers(True)
+
+    def _get_str_value(self, name, default):
+        try:
+            ret = self.tree[name].value
+        except Exception:
+            ret = default
+        return ret
+
+    def _set_str_value(self, name, value):
+        try:
+            node = self.tree[name]
+            node.value = value
+        except Exception:
+            node = ConfigNode(name=name, value=value)
+            self.tree.append_node_as_child(node, self.tree)
+        self.fire_unsaved_notifiers(True)
+
+    def _get_bool_value(self, name):
+        try:
+            node = self.tree[name]
+            return True
+        except Exception:
+            return False
+
+    def _set_bool_value(self, name, value):
+        try:
+            node = self.tree[name]
+            if not value:
+                self.tree.remove_node(node)
+        except Exception:
+            if value:
+                node = ConfigNode(name=name)
+                self.tree.append_node_as_child(node, self.tree)
+        self.fire_unsaved_notifiers(True)
+# --------------------------------------------------------------
+
+    def __init__(self, configfile=None):
+        if configfile:
+            self.path = configfile
+        else:
+            self.path = os.path.join(XDG_get_config_home(), "bmpanel2/bmpanel2rc")
+        self.tree = ConfigFormat(self.path)
+
+        # an array of function pointers
+        # function(state)
+        # where 'state' is a boolean
+        # functions are being called when there are:
+        # True - unsaved changes are here
+        # False - config was just saved, no unsaved changes
+        self.unsaved_notifiers = []
+
+    def add_unsaved_notifier(self, notifier):
+        self.unsaved_notifiers.append(notifier)
+
+    def fire_unsaved_notifiers(self, status):
+        for nnn in self.unsaved_notifiers:
+            nnn(status)
+
+    def save(self):
+        self.tree.save(self.path)
+        self.fire_unsaved_notifiers(False)
+        # self.tree.save("testrc")
+
+    def get_theme(self):
+        return self._get_str_value('theme', 'native')
+
+    def set_theme(self, value):
+        self._set_str_value('theme', value)
+
+    def get_task_death_threshold(self):
+        return self._get_int_value('task_death_threshold', 50)
+
+    def set_task_death_threshold(self, value):
+        self._set_int_value('task_death_threshold', value)
+
+    def get_drag_threshold(self):
+        return self._get_int_value('drag_threshold', 30)
+
+    def set_drag_threshold(self, value):
+        self._set_int_value('drag_threshold', value)
+
+    def get_task_urgency_hint(self):
+        return self._get_bool_value('task_urgency_hint')
+
+    def set_task_urgency_hint(self, value):
+        self._set_bool_value('task_urgency_hint', value)
+
+    def get_clock_prog(self):
+        return self._get_str_value('clock_prog', None)
+
+    def set_clock_prog(self, value):
+        self._set_str_value('clock_prog', value)
+
+    def get_monitor(self):
+        return self._get_int_value('monitor', 0)
+
+    def set_monitor(self, value):
+        self._set_int_value('monitor', value)
+
+    def get_task_visible_monitors(self):
+        return self._get_str_value('task_visible_monitors', '')
+
+    def set_task_visible_monitors(self, value):
+        self._set_str_value('task_visible_monitors', value)
+
+    def get_pager_current_monitor_only(self):
+        return self._get_bool_value('pager_current_monitor_only')
+
+    def set_pager_current_monitor_only(self, value):
+        self._set_bool_value('pager_current_monitor_only', value)
+
+    def get_preferred_alternatives(self):
+        return self._get_str_value('preferred_alternatives', '')
 
-	# TODO: launchbar
+    def set_preferred_alternatives(self, value):
+        self._set_str_value('preferred_alternatives', value)
 
-#----------------------------------------------------------------------
+    # TODO: launchbar
+
+# ----------------------------------------------------------------------
 # Bmpanel2Remote
-#----------------------------------------------------------------------
-class Bmpanel2Remote:
-	def __init__(self, configfile=None):
-		self.configfile = configfile
-		self.started_with_theme = False
-		self.pid = None
-		self.update_pid()
-
-	def update_pid(self):
-		# find pid using following algo:
-		# 1. get all bmpanel2 pids
-		#    - if there is no bmpanel2 instance, return, we can't find the PID
-		# 2. split themes into two arrays, ones that have "--config" parameter and ones that don't.
-		# 3. if we have configfile parameter: look for a bmpanel2 instance in the needed list
-		#    - if not found, return, we can't find the PID
-		# 4. if we don't have configfile parameter:
-		#    - try to use first pid from "non-config list"
-		#    - if not found, use first pid from "config list"
-
-		# (1)
-		try:
-			pids = [int(item) for item in os.popen("pidof bmpanel2").read().split()]
-		except:
-			return
-
-		if not pids:
-			return
-
-		# (2)
-		configlist = []
-		nonconfiglist = []
-		for pid in pids:
-			args = os.popen("ps --no-heading o %a -p {0}".format(pid)).read().splitlines()[0]
-			if args.find("--config") != -1:
-				configlist.append((pid, args))
-			else:
-				nonconfiglist.append((pid, args))
-
-		# (3)
-		if self.configfile:
-			for pid, args in configlist:
-				if args.find(self.configfile) != -1:
-					self.pid = pid
-			if not self.pid:
-				return
-		# (4)
-		else:
-			try:
-				self.pid = nonconfiglist[0][0]
-			except:
-				self.pid = configlist[0][0]
-
-		# check if bmpanel2 was started with "--theme" parameter
-		try:
-			args = os.popen("ps --no-heading o %a -p {0}".format(self.pid)).read().splitlines()[0]
-			self.started_with_theme = args.find("--theme") != -1
-		except:
-			pass
-
-	def reconfigure(self, reload_theme=False):
-		if self.pid:
-			if reload_theme:
-				os.kill(self.pid, 12)
-			else:
-				os.kill(self.pid, 10)
+# ----------------------------------------------------------------------
+
 
-#----------------------------------------------------------------------
+class Bmpanel2Remote(object):
+    def __init__(self, configfile=None):
+        self.configfile = configfile
+        self.started_with_theme = False
+        self.pid = None
+        self.update_pid()
+
+    def update_pid(self):
+        # find pid using following algo:
+        # 1. get all bmpanel2 pids
+        #    - if there is no bmpanel2 instance, return, we can't find the PID
+        # 2. split themes into two arrays, ones that have "--config" parameter and ones that don't.
+        # 3. if we have configfile parameter: look for a bmpanel2 instance in the needed list
+        #    - if not found, return, we can't find the PID
+        # 4. if we don't have configfile parameter:
+        #    - try to use first pid from "non-config list"
+        #    - if not found, use first pid from "config list"
+
+        # (1)
+        try:
+            pids = [int(item) for item in os.popen("pidof bmpanel2").read().split()]
+        except Exception:
+            return
+
+        if not pids:
+            return
+
+        # (2)
+        configlist = []
+        nonconfiglist = []
+        for pid in pids:
+            args = os.popen("ps --no-heading o %a -p {0}".format(pid)).read().splitlines()[0]
+            if args.find("--config") != -1:
+                configlist.append((pid, args))
+            else:
+                nonconfiglist.append((pid, args))
+
+        # (3)
+        if self.configfile:
+            for pid, args in configlist:
+                if args.find(self.configfile) != -1:
+                    self.pid = pid
+            if not self.pid:
+                return
+        # (4)
+        else:
+            try:
+                self.pid = nonconfiglist[0][0]
+            except Exception:
+                self.pid = configlist[0][0]
+
+        # check if bmpanel2 was started with "--theme" parameter
+        try:
+            args = os.popen("ps --no-heading o %a -p {0}".format(self.pid)).read().splitlines()[0]
+            self.started_with_theme = args.find("--theme") != -1
+        except Exception:
+            pass
+
+    def reconfigure(self, reload_theme=False):
+        if self.pid:
+            if reload_theme:
+                os.kill(self.pid, 12)
+            else:
+                os.kill(self.pid, 10)
+
+# ----------------------------------------------------------------------
 # Bmpanel2Themes
-#----------------------------------------------------------------------
-class Theme:
-	def __init__(self, dirname, name=None, author=None, path=None):
-		self.dirname = dirname
-		self.name = name
-		self.author = author
-		self.path = path
-
-class Bmpanel2Themes:
-	def _try_load_theme(self, dirname, themefile):
-		c = ConfigFormat(themefile)
-		path = os.path.dirname(themefile)
-		name = None
-		author = None
-		try:
-			t = c['theme']
-			name = t['name'].value
-			author = t['author'].value
-		except:
-			pass
-
-		if not dirname in self.themes:
-			self.themes[dirname] = Theme(dirname, name, author, path)
-
-	def _lookup_for_themes(self, d):
-		try:
-			files = os.listdir(d)
-		except OSError:
-			return
-
-		for f in files:
-			path = os.path.join(d, f)
-			path = os.path.join(path, "theme")
-			if os.path.exists(path):
-				self._try_load_theme(f, path)
-
-	def __init__(self):
-		self.themes = {}
-		dirs = XDG_get_data_dirs()
-		for d in dirs:
-			path = os.path.join(d, "bmpanel2/themes")
-			self._lookup_for_themes(path)
-
-		def get_dirname(theme):
-			if theme.name:
-				return theme.name
-			else:
-				return theme.dirname
-		tmp = self.themes.values()
-		tmp.sort(key=get_dirname)
-		self.themes = tmp
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
+
+
+class Theme(object):
+    def __init__(self, dirname, name=None, author=None, path=None):
+        self.dirname = dirname
+        self.name = name
+        self.author = author
+        self.path = path
+
+
+class Bmpanel2Themes(object):
+    def _try_load_theme(self, dirname, themefile):
+        ccc = ConfigFormat(themefile)
+        path = os.path.dirname(themefile)
+        name = None
+        author = None
+        try:
+            ttt = ccc['theme']
+            name = ttt['name'].value
+            author = ttt['author'].value
+        except Exception:
+            pass
+
+        if dirname not in self.themes:
+            self.themes[dirname] = Theme(dirname, name, author, path)
+
+    def _lookup_for_themes(self, ddd):
+        try:
+            files = os.listdir(ddd)
+        except OSError:
+            return
+
+        for fff in files:
+            path = os.path.join(ddd, fff)
+            path = os.path.join(path, "theme")
+            if os.path.exists(path):
+                self._try_load_theme(fff, path)
+
+    def __init__(self):
+        self.themes = {}
+        dirs = XDG_get_data_dirs()
+        for ddd in dirs:
+            path = os.path.join(ddd, "bmpanel2/themes")
+            self._lookup_for_themes(path)
+
+        def get_dirname(theme):
+            if theme.name:
+                return theme.name
+            else:
+                return theme.dirname
+        tmp = list(self.themes.values())
+        tmp.sort(key=get_dirname)
+        self.themes = tmp
+# ----------------------------------------------------------------------
 # Bmpanel2Launchbar
-#----------------------------------------------------------------------
+# ----------------------------------------------------------------------
 
-class LaunchbarItem:
-	def __init__(self, prog=None, icon=None):
-		self.prog = prog
-		self.icon = icon
-
-class Bmpanel2Launchbar:
-	def __init__(self, config):
-		try:
-			launchbar = config.tree['launchbar']
-		except:
-			launchbar = ConfigNode(name="launchbar")
-			config.tree.append_node_as_child(launchbar, config.tree)
-
-		self.launchbar = launchbar
-
-	def __iter__(self):
-		for c in self.launchbar.children:
-			try:
-				yield LaunchbarItem(c.value, c['icon'].value)
-			except:
-				pass
-
-	def __getitem__(self, n):
-		c = self.launchbar.children[n]
-		return LaunchbarItem(c.value, c['icon'].value)
 
+class LaunchbarItem(object):
+    def __init__(self, prog=None, icon=None):
+        self.prog = prog
+        self.icon = icon
+
+
+class Bmpanel2Launchbar(object):
+    def __init__(self, config):
+        try:
+            launchbar = config.tree['launchbar']
+        except Exception:
+            launchbar = ConfigNode(name="launchbar")
+            config.tree.append_node_as_child(launchbar, config.tree)
+
+        self.launchbar = launchbar
+
+    def __iter__(self):
+        for ccc in self.launchbar.children:
+            try:
+                yield LaunchbarItem(ccc.value, ccc['icon'].value)
+            except Exception:
+                pass
+
+    def __getitem__(self, nnn):
+        ccc = self.launchbar.children[nnn]
+        return LaunchbarItem(ccc.value, ccc['icon'].value)
diff -Nur orig/extra/py/setup.py mod/extra/py/setup.py
--- orig/extra/py/setup.py	2020-03-24 21:09:20.000000000 +0100
+++ mod/extra/py/setup.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-from distutils.core import setup
-
-setup(name='bmpanel2cfg',
-      version='1.0',
-      description='Bmpanel2 Config',
-      author='nsf',
-      author_email='no.smile.face@gmail.com',
-      scripts=['bmpanel2cfg'],
-      py_modules=['bmpanel2']
-      )
