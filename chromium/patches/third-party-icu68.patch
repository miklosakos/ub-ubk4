diff -Naur orig/third_party/icu/source/common/cmemory.h patched/third_party/icu/source/common/cmemory.h
--- orig/third_party/icu/source/common/cmemory.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/cmemory.h	2020-11-02 22:31:48.052193409 +0100
@@ -292,7 +292,7 @@
     /**
      * Default constructor initializes with internal T[stackCapacity] buffer.
      */
-    MaybeStackArray() : ptr(stackArray), capacity(stackCapacity), needToRelease(FALSE) {}
+    MaybeStackArray() : ptr(stackArray), capacity(stackCapacity), needToRelease(false) {}
     /**
      * Automatically allocates the heap array if the argument is larger than the stack capacity.
      * Intended for use when an approximate capacity is known at compile time but the true
@@ -355,7 +355,7 @@
             releaseArray();
             ptr=otherArray;
             capacity=otherCapacity;
-            needToRelease=FALSE;
+            needToRelease=false;
         }
     }
     /**
@@ -393,7 +393,7 @@
     void resetToStackArray() {
         ptr=stackArray;
         capacity=stackCapacity;
-        needToRelease=FALSE;
+        needToRelease=false;
     }
     /* No comparison operators with other MaybeStackArray's. */
     bool operator==(const MaybeStackArray & /*other*/) {return FALSE;}
@@ -451,7 +451,7 @@
             releaseArray();
             ptr=p;
             capacity=newCapacity;
-            needToRelease=TRUE;
+            needToRelease=true;
         }
         return p;
     } else {
@@ -507,7 +507,7 @@
     /**
      * Default constructor initializes with internal H+T[stackCapacity] buffer.
      */
-    MaybeStackHeaderAndArray() : ptr(&stackHeader), capacity(stackCapacity), needToRelease(FALSE) {}
+    MaybeStackHeaderAndArray() : ptr(&stackHeader), capacity(stackCapacity), needToRelease(false) {}
     /**
      * Destructor deletes the memory (if owned).
      */
@@ -556,7 +556,7 @@
             releaseMemory();
             ptr=otherMemory;
             capacity=otherCapacity;
-            needToRelease=FALSE;
+            needToRelease=false;
         }
     }
     /**
@@ -595,8 +595,8 @@
         }
     }
     /* No comparison operators with other MaybeStackHeaderAndArray's. */
-    bool operator==(const MaybeStackHeaderAndArray & /*other*/) {return FALSE;}
-    bool operator!=(const MaybeStackHeaderAndArray & /*other*/) {return TRUE;}
+    bool operator==(const MaybeStackHeaderAndArray & /*other*/) {return false;}
+    bool operator!=(const MaybeStackHeaderAndArray & /*other*/) {return true;}
     /* No ownership transfer: No copy constructor, no assignment operator. */
     MaybeStackHeaderAndArray(const MaybeStackHeaderAndArray & /*other*/) {}
     void operator=(const MaybeStackHeaderAndArray & /*other*/) {}
@@ -625,7 +625,7 @@
             releaseMemory();
             ptr=p;
             capacity=newCapacity;
-            needToRelease=TRUE;
+            needToRelease=true;
         }
         return p;
     } else {
@@ -657,7 +657,7 @@
     resultCapacity=length;
     ptr=&stackHeader;
     capacity=stackCapacity;
-    needToRelease=FALSE;
+    needToRelease=false;
     return p;
 }
 
diff -Naur orig/third_party/icu/source/common/normalizer2impl.h patched/third_party/icu/source/common/normalizer2impl.h
--- orig/third_party/icu/source/common/normalizer2impl.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/normalizer2impl.h	2020-11-02 22:31:48.052193409 +0100
@@ -171,7 +171,7 @@
                  UErrorCode &errorCode);
     UBool appendBMP(UChar c, uint8_t cc, UErrorCode &errorCode) {
         if(remainingCapacity==0 && !resize(1, errorCode)) {
-            return FALSE;
+            return false;
         }
         if(lastCC<=cc || cc==0) {
             *limit++=c;
@@ -183,7 +183,7 @@
             insert(c, cc);
         }
         --remainingCapacity;
-        return TRUE;
+        return true;
     }
     UBool appendZeroCC(UChar32 c, UErrorCode &errorCode);
     UBool appendZeroCC(const UChar *s, const UChar *sLimit, UErrorCode &errorCode);
diff -Naur orig/third_party/icu/source/common/resource.h patched/third_party/icu/source/common/resource.h
--- orig/third_party/icu/source/common/resource.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/resource.h	2020-11-02 22:31:48.052193409 +0100
@@ -141,7 +141,7 @@
     inline UnicodeString getUnicodeString(UErrorCode &errorCode) const {
         int32_t len = 0;
         const UChar *r = getString(len, errorCode);
-        return UnicodeString(TRUE, r, len);
+        return UnicodeString(true, r, len);
     }
 
     /**
@@ -152,7 +152,7 @@
     inline UnicodeString getAliasUnicodeString(UErrorCode &errorCode) const {
         int32_t len = 0;
         const UChar *r = getAliasString(len, errorCode);
-        return UnicodeString(TRUE, r, len);
+        return UnicodeString(true, r, len);
     }
 
     /**
diff -Naur orig/third_party/icu/source/common/unicode/brkiter.h patched/third_party/icu/source/common/unicode/brkiter.h
--- orig/third_party/icu/source/common/unicode/brkiter.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/brkiter.h	2020-11-02 22:31:48.052193409 +0100
@@ -655,7 +655,7 @@
 
 inline UBool BreakIterator::isBufferClone()
 {
-    return FALSE;
+    return false;
 }
 
 #endif /* U_HIDE_DEPRECATED_API */
diff -Naur orig/third_party/icu/source/common/unicode/bytestriebuilder.h patched/third_party/icu/source/common/unicode/bytestriebuilder.h
--- orig/third_party/icu/source/common/unicode/bytestriebuilder.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/bytestriebuilder.h	2020-11-02 22:31:48.052193409 +0100
@@ -139,7 +139,7 @@
     virtual int32_t skipElementsBySomeUnits(int32_t i, int32_t byteIndex, int32_t count) const;
     virtual int32_t indexOfElementWithNextUnit(int32_t i, int32_t byteIndex, char16_t byte) const;
 
-    virtual UBool matchNodesCanHaveValues() const { return FALSE; }
+    virtual UBool matchNodesCanHaveValues() const { return false; }
 
     virtual int32_t getMaxBranchLinearSubNodeLength() const { return BytesTrie::kMaxBranchLinearSubNodeLength; }
     virtual int32_t getMinLinearMatch() const { return BytesTrie::kMinLinearMatch; }
diff -Naur orig/third_party/icu/source/common/unicode/bytestrie.h patched/third_party/icu/source/common/unicode/bytestrie.h
--- orig/third_party/icu/source/common/unicode/bytestrie.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/bytestrie.h	2020-11-02 22:31:48.052193409 +0100
@@ -253,16 +253,16 @@
     /**
      * Determines whether all byte sequences reachable from the current state
      * map to the same value.
-     * @param uniqueValue Receives the unique value, if this function returns TRUE.
+     * @param uniqueValue Receives the unique value, if this function returns true.
      *                    (output-only)
-     * @return TRUE if all byte sequences reachable from the current state
+     * @return true if all byte sequences reachable from the current state
      *         map to the same value.
      * @stable ICU 4.8
      */
     inline UBool hasUniqueValue(int32_t &uniqueValue) const {
         const uint8_t *pos=pos_;
         // Skip the rest of a pending linear-match node.
-        return pos!=NULL && findUniqueValue(pos+remainingMatchLength_+1, FALSE, uniqueValue);
+        return pos!=NULL && findUniqueValue(pos+remainingMatchLength_+1, false, uniqueValue);
     }
 
     /**
diff -Naur orig/third_party/icu/source/common/unicode/caniter.h patched/third_party/icu/source/common/unicode/caniter.h
--- orig/third_party/icu/source/common/unicode/caniter.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/caniter.h	2020-11-02 22:31:48.056193435 +0100
@@ -25,11 +25,11 @@
  */
  
 /** Should permutation skip characters with combining class zero
- *  Should be either TRUE or FALSE. This is a compile time option
+ *  Should be either true or false. This is a compile time option
  *  @stable ICU 2.4
  */
 #ifndef CANITER_SKIP_ZEROES
-#define CANITER_SKIP_ZEROES TRUE
+#define CANITER_SKIP_ZEROES true
 #endif
 
 U_NAMESPACE_BEGIN
diff -Naur orig/third_party/icu/source/common/unicode/edits.h patched/third_party/icu/source/common/unicode/edits.h
--- orig/third_party/icu/source/common/unicode/edits.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/edits.h	2020-11-02 22:31:48.056193435 +0100
@@ -207,8 +207,8 @@
          */
         Iterator() :
                 array(nullptr), index(0), length(0),
-                remaining(0), onlyChanges_(FALSE), coarse(FALSE),
-                dir(0), changed(FALSE), oldLength_(0), newLength_(0),
+                remaining(0), onlyChanges_(false), coarse(false),
+                dir(0), changed(false), oldLength_(0), newLength_(0),
                 srcIndex(0), replIndex(0), destIndex(0) {}
         /**
          * Copy constructor.
@@ -247,11 +247,11 @@
          * @param errorCode ICU error code. Its input value must pass the U_SUCCESS() test,
          *                  or else the function returns immediately. Check for U_FAILURE()
          *                  on output or use with function chaining. (See User Guide for details.)
-         * @return TRUE if the edit for the source index was found
+         * @return true if the edit for the source index was found
          * @stable ICU 59
          */
         UBool findSourceIndex(int32_t i, UErrorCode &errorCode) {
-            return findIndex(i, TRUE, errorCode) == 0;
+            return findIndex(i, true, errorCode) == 0;
         }
 
         /**
@@ -270,11 +270,11 @@
          * @param errorCode ICU error code. Its input value must pass the U_SUCCESS() test,
          *                  or else the function returns immediately. Check for U_FAILURE()
          *                  on output or use with function chaining. (See User Guide for details.)
-         * @return TRUE if the edit for the destination index was found
+         * @return true if the edit for the destination index was found
          * @stable ICU 60
          */
         UBool findDestinationIndex(int32_t i, UErrorCode &errorCode) {
-            return findIndex(i, FALSE, errorCode) == 0;
+            return findIndex(i, false, errorCode) == 0;
         }
 
         /**
@@ -436,7 +436,7 @@
      * @stable ICU 59
      */
     Iterator getCoarseChangesIterator() const {
-        return Iterator(array, length, TRUE, TRUE);
+        return Iterator(array, length, true, true);
     }
 
     /**
@@ -448,7 +448,7 @@
      * @stable ICU 59
      */
     Iterator getCoarseIterator() const {
-        return Iterator(array, length, FALSE, TRUE);
+        return Iterator(array, length, false, true);
     }
 
     /**
@@ -460,7 +460,7 @@
      * @stable ICU 59
      */
     Iterator getFineChangesIterator() const {
-        return Iterator(array, length, TRUE, FALSE);
+        return Iterator(array, length, true, false);
     }
 
     /**
@@ -471,7 +471,7 @@
      * @stable ICU 59
      */
     Iterator getFineIterator() const {
-        return Iterator(array, length, FALSE, FALSE);
+        return Iterator(array, length, false, false);
     }
 
     /**
diff -Naur orig/third_party/icu/source/common/unicode/idna.h patched/third_party/icu/source/common/unicode/idna.h
--- orig/third_party/icu/source/common/unicode/idna.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/idna.h	2020-11-02 22:31:48.056193435 +0100
@@ -273,10 +273,10 @@
      * Constructor for stack allocation.
      * @stable ICU 4.6
      */
-    IDNAInfo() : errors(0), labelErrors(0), isTransDiff(FALSE), isBiDi(FALSE), isOkBiDi(TRUE) {}
+    IDNAInfo() : errors(0), labelErrors(0), isTransDiff(false), isBiDi(false), isOkBiDi(true) {}
     /**
      * Were there IDNA processing errors?
-     * @return TRUE if there were processing errors
+     * @return true if there were processing errors
      * @stable ICU 4.6
      */
     UBool hasErrors() const { return errors!=0; }
@@ -310,9 +310,9 @@
 
     void reset() {
         errors=labelErrors=0;
-        isTransDiff=FALSE;
-        isBiDi=FALSE;
-        isOkBiDi=TRUE;
+        isTransDiff=false;
+        isBiDi=false;
+        isOkBiDi=true;
     }
 
     uint32_t errors, labelErrors;
diff -Naur orig/third_party/icu/source/common/unicode/parsepos.h patched/third_party/icu/source/common/unicode/parsepos.h
--- orig/third_party/icu/source/common/unicode/parsepos.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/parsepos.h	2020-11-02 22:31:48.056193435 +0100
@@ -196,9 +196,9 @@
 ParsePosition::operator==(const ParsePosition& copy) const
 {
   if(index != copy.index || errorIndex != copy.errorIndex)
-  return FALSE;
+  return false;
   else
-  return TRUE;
+  return true;
 }
 
 inline UBool
diff -Naur orig/third_party/icu/source/common/unicode/stringtriebuilder.h patched/third_party/icu/source/common/unicode/stringtriebuilder.h
--- orig/third_party/icu/source/common/unicode/stringtriebuilder.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/stringtriebuilder.h	2020-11-02 22:31:48.056193435 +0100
@@ -279,10 +279,10 @@
      */
     class ValueNode : public Node {
     public:
-        ValueNode(int32_t initialHash) : Node(initialHash), hasValue(FALSE), value(0) {}
+        ValueNode(int32_t initialHash) : Node(initialHash), hasValue(false), value(0) {}
         virtual UBool operator==(const Node &other) const;
         void setValue(int32_t v) {
-            hasValue=TRUE;
+            hasValue=true;
             value=v;
             hash=hash*37u+v;
         }
diff -Naur orig/third_party/icu/source/common/unicode/ucharstriebuilder.h patched/third_party/icu/source/common/unicode/ucharstriebuilder.h
--- orig/third_party/icu/source/common/unicode/ucharstriebuilder.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/ucharstriebuilder.h	2020-11-02 22:31:48.056193435 +0100
@@ -147,7 +147,7 @@
     virtual int32_t skipElementsBySomeUnits(int32_t i, int32_t unitIndex, int32_t count) const;
     virtual int32_t indexOfElementWithNextUnit(int32_t i, int32_t unitIndex, char16_t unit) const;
 
-    virtual UBool matchNodesCanHaveValues() const { return TRUE; }
+    virtual UBool matchNodesCanHaveValues() const { return true; }
 
     virtual int32_t getMaxBranchLinearSubNodeLength() const { return UCharsTrie::kMaxBranchLinearSubNodeLength; }
     virtual int32_t getMinLinearMatch() const { return UCharsTrie::kMinLinearMatch; }
diff -Naur orig/third_party/icu/source/common/unicode/ucharstrie.h patched/third_party/icu/source/common/unicode/ucharstrie.h
--- orig/third_party/icu/source/common/unicode/ucharstrie.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/ucharstrie.h	2020-11-02 22:31:48.056193435 +0100
@@ -268,16 +268,16 @@
     /**
      * Determines whether all strings reachable from the current state
      * map to the same value.
-     * @param uniqueValue Receives the unique value, if this function returns TRUE.
+     * @param uniqueValue Receives the unique value, if this function returns true.
      *                    (output-only)
-     * @return TRUE if all strings reachable from the current state
+     * @return true if all strings reachable from the current state
      *         map to the same value.
      * @stable ICU 4.8
      */
     inline UBool hasUniqueValue(int32_t &uniqueValue) const {
         const char16_t *pos=pos_;
         // Skip the rest of a pending linear-match node.
-        return pos!=NULL && findUniqueValue(pos+remainingMatchLength_+1, FALSE, uniqueValue);
+        return pos!=NULL && findUniqueValue(pos+remainingMatchLength_+1, false, uniqueValue);
     }
 
     /**
@@ -371,7 +371,7 @@
         UBool truncateAndStop() {
             pos_=NULL;
             value_=-1;  // no real value for str
-            return TRUE;
+            return true;
         }
 
         const char16_t *branchNext(const char16_t *pos, int32_t length, UErrorCode &errorCode);
diff -Naur orig/third_party/icu/source/common/unicode/uidna.h patched/third_party/icu/source/common/unicode/uidna.h
--- orig/third_party/icu/source/common/unicode/uidna.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/uidna.h	2020-11-02 22:31:48.056193435 +0100
@@ -23,6 +23,7 @@
 
 #if !UCONFIG_NO_IDNA
 
+#include <stdbool.h>
 #include "unicode/localpointer.h"
 #include "unicode/parseerr.h"
 
@@ -204,7 +205,7 @@
  */
 #define UIDNA_INFO_INITIALIZER { \
     (int16_t)sizeof(UIDNAInfo), \
-    FALSE, FALSE, \
+    false, false, \
     0, 0, 0 }
 
 /**
diff -Naur orig/third_party/icu/source/common/unicode/umachine.h patched/third_party/icu/source/common/unicode/umachine.h
--- orig/third_party/icu/source/common/unicode/umachine.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/umachine.h	2020-11-02 22:31:48.056193435 +0100
@@ -49,6 +49,7 @@
  * ANSI C headers:
  * stddef.h defines wchar_t
  */
+#include <stdbool.h>
 #include <stddef.h>
 
 /*==========================================================================*/
@@ -170,11 +171,11 @@
 
 /**
  * \def UPRV_BLOCK_MACRO_END
- * Defined as "while (FALSE)" by default.
+ * Defined as "while (false)" by default.
  * @internal
  */
 #ifndef UPRV_BLOCK_MACRO_END
-#define UPRV_BLOCK_MACRO_END while (FALSE)
+#define UPRV_BLOCK_MACRO_END while (false)
 #endif
 
 /*==========================================================================*/
@@ -257,18 +258,59 @@
 /* Boolean data type                                                        */
 /*==========================================================================*/
 
-/** The ICU boolean type @stable ICU 2.0 */
+/**
+ * The ICU boolean type, a signed-byte integer.
+ * ICU-specific for historical reasons: The C and C++ standards used to not define type bool.
+ * Also provides a fixed type definition, as opposed to
+ * type bool whose details (e.g., sizeof) may vary by compiler and between C and C++.
+ *
+ * @stable ICU 2.0
+ */
 typedef int8_t UBool;
 
+/**
+ * \def U_DEFINE_FALSE_AND_TRUE
+ * Normally turns off defining macros FALSE=0 & TRUE=1 in public ICU headers.
+ * These obsolete macros sometimes break compilation of other code that
+ * defines enum constants or similar with these names.
+ * C++ has long defined bool/false/true.
+ * C99 also added definitions for these, although as macros; see stdbool.h.
+ *
+ * You may transitionally define U_DEFINE_FALSE_AND_TRUE=1 if you need time to migrate code.
+ *
+ * @internal ICU 68
+ */
+#ifdef U_DEFINE_FALSE_AND_TRUE
+    // Use the predefined value.
+#elif defined(U_COMBINED_IMPLEMENTATION) || \
+        defined(U_COMMON_IMPLEMENTATION) || defined(U_I18N_IMPLEMENTATION) || \
+        defined(U_IO_IMPLEMENTATION) || defined(U_LAYOUTEX_IMPLEMENTATION) || \
+        defined(U_TOOLUTIL_IMPLEMENTATION)
+    // Inside ICU: Keep FALSE & TRUE available.
+#   define U_DEFINE_FALSE_AND_TRUE 1
+#else
+    // Outside ICU: Avoid collision with non-macro definitions of FALSE & TRUE.
+#   define U_DEFINE_FALSE_AND_TRUE 0
+#endif
+
+#if U_DEFINE_FALSE_AND_TRUE || defined(U_IN_DOXYGEN)
 #ifndef TRUE
-/** The TRUE value of a UBool @stable ICU 2.0 */
+/**
+ * The TRUE value of a UBool.
+ *
+ * @deprecated ICU 68 Use standard "true" instead.
+ */
 #   define TRUE  1
 #endif
 #ifndef FALSE
-/** The FALSE value of a UBool @stable ICU 2.0 */
+/**
+ * The FALSE value of a UBool.
+ *
+ * @deprecated ICU 68 Use standard "false" instead.
+ */
 #   define FALSE 0
 #endif
-
+#endif  // U_DEFINE_FALSE_AND_TRUE
 
 /*==========================================================================*/
 /* Unicode data types                                                       */
diff -Naur orig/third_party/icu/source/common/unicode/unimatch.h patched/third_party/icu/source/common/unicode/unimatch.h
--- orig/third_party/icu/source/common/unicode/unimatch.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/unimatch.h	2020-11-02 22:31:48.056193435 +0100
@@ -134,17 +134,17 @@
      * will produce another matcher that is equal to this one.
      * @param result the string to receive the pattern.  Previous
      * contents will be deleted.
-     * @param escapeUnprintable if TRUE then convert unprintable
+     * @param escapeUnprintable if true then convert unprintable
      * character to their hex escape representations, \\uxxxx or
      * \\Uxxxxxxxx.  Unprintable characters are those other than
      * U+000A, U+0020..U+007E.
      * @stable ICU 2.4
      */
     virtual UnicodeString& toPattern(UnicodeString& result,
-                                     UBool escapeUnprintable = FALSE) const = 0;
+                                     UBool escapeUnprintable = false) const = 0;
 
     /**
-     * Returns TRUE if this matcher will match a character c, where c
+     * Returns true if this matcher will match a character c, where c
      * & 0xFF == v, at offset, in the forward direction (with limit >
      * offset).  This is used by <tt>RuleBasedTransliterator</tt> for
      * indexing.
diff -Naur orig/third_party/icu/source/common/unicode/uniset.h patched/third_party/icu/source/common/unicode/uniset.h
--- orig/third_party/icu/source/common/unicode/uniset.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/uniset.h	2020-11-02 22:33:39.236894299 +0100
@@ -707,7 +707,7 @@
      * @stable ICU 2.0
      */
     virtual UnicodeString& toPattern(UnicodeString& result,
-                             UBool escapeUnprintable = FALSE) const;
+                             UBool escapeUnprintable = false) const;
 
     /**
      * Modifies this set to contain those code points which have the given value
diff -Naur orig/third_party/icu/source/common/unicode/unistr.h patched/third_party/icu/source/common/unicode/unistr.h
--- orig/third_party/icu/source/common/unicode/unistr.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/unistr.h	2020-11-02 22:31:48.056193435 +0100
@@ -113,9 +113,9 @@
  * @stable ICU 2.0
  */
 #if !U_CHAR16_IS_TYPEDEF
-# define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, u ## cs, _length)
+# define UNICODE_STRING(cs, _length) icu::UnicodeString(true, u ## cs, _length)
 #else
-# define UNICODE_STRING(cs, _length) icu::UnicodeString(TRUE, (const char16_t*)u ## cs, _length)
+# define UNICODE_STRING(cs, _length) icu::UnicodeString(true, (const char16_t*)u ## cs, _length)
 #endif
 
 /**
@@ -3615,7 +3615,7 @@
   void unBogus();
 
   // implements assigment operator, copy constructor, and fastCopyFrom()
-  UnicodeString &copyFrom(const UnicodeString &src, UBool fastCopy=FALSE);
+  UnicodeString &copyFrom(const UnicodeString &src, UBool fastCopy=false);
 
   // Copies just the fields without memory management.
   void copyFieldsFrom(UnicodeString &src, UBool setSrcToBogus) U_NOEXCEPT;
@@ -3668,13 +3668,13 @@
    * the buffer is refCounted (shared), and refCount>1, or
    * the buffer is too small.
    *
-   * Return FALSE if memory could not be allocated.
+   * Return false if memory could not be allocated.
    */
   UBool cloneArrayIfNeeded(int32_t newCapacity = -1,
                             int32_t growCapacity = -1,
-                            UBool doCopyArray = TRUE,
+                            UBool doCopyArray = true,
                             int32_t **pBufferToDelete = 0,
-                            UBool forceClone = FALSE);
+                            UBool forceClone = false);
 
   /**
    * Common function for UnicodeString case mappings.
@@ -4732,12 +4732,12 @@
   if(isBogus() && targetLength == 0) {
     // truncate(0) of a bogus string makes the string empty and non-bogus
     unBogus();
-    return FALSE;
+    return false;
   } else if((uint32_t)targetLength < (uint32_t)length()) {
     setLength(targetLength);
-    return TRUE;
+    return true;
   } else {
-    return FALSE;
+    return false;
   }
 }
 
diff -Naur orig/third_party/icu/source/common/unicode/ures.h patched/third_party/icu/source/common/unicode/ures.h
--- orig/third_party/icu/source/common/unicode/ures.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/ures.h	2020-11-02 22:31:48.056193435 +0100
@@ -811,7 +811,7 @@
     int32_t len = 0;
     const UChar *r = ures_getString(resB, &len, status);
     if(U_SUCCESS(*status)) {
-        result.setTo(TRUE, r, len);
+        result.setTo(true, r, len);
     } else {
         result.setToBogus();
     }
@@ -836,7 +836,7 @@
     int32_t len = 0;
     const UChar* r = ures_getNextString(resB, &len, key, status);
     if(U_SUCCESS(*status)) {
-        result.setTo(TRUE, r, len);
+        result.setTo(true, r, len);
     } else {
         result.setToBogus();
     }
@@ -858,7 +858,7 @@
     int32_t len = 0;
     const UChar* r = ures_getStringByIndex(resB, indexS, &len, status);
     if(U_SUCCESS(*status)) {
-        result.setTo(TRUE, r, len);
+        result.setTo(true, r, len);
     } else {
         result.setToBogus();
     }
@@ -881,7 +881,7 @@
     int32_t len = 0;
     const UChar* r = ures_getStringByKey(resB, key, &len, status);
     if(U_SUCCESS(*status)) {
-        result.setTo(TRUE, r, len);
+        result.setTo(true, r, len);
     } else {
         result.setToBogus();
     }
diff -Naur orig/third_party/icu/source/common/unicode/ustring.h patched/third_party/icu/source/common/unicode/ustring.h
--- orig/third_party/icu/source/common/unicode/ustring.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/ustring.h	2020-11-02 22:31:48.056193435 +0100
@@ -903,13 +903,13 @@
  *
  *     U_STRING_DECL(ustringVar1, "Quick-Fox 2", 11);
  *     U_STRING_DECL(ustringVar2, "jumps 5%", 8);
- *     static UBool didInit=FALSE;
+ *     static UBool didInit=false;
  *
  *     int32_t function() {
  *         if(!didInit) {
  *             U_STRING_INIT(ustringVar1, "Quick-Fox 2", 11);
  *             U_STRING_INIT(ustringVar2, "jumps 5%", 8);
- *             didInit=TRUE;
+ *             didInit=true;
  *         }
  *         return u_strcmp(ustringVar1, ustringVar2);
  *     }
diff -Naur orig/third_party/icu/source/common/unicode/utf16.h patched/third_party/icu/source/common/unicode/utf16.h
--- orig/third_party/icu/source/common/unicode/utf16.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/utf16.h	2020-11-02 22:31:48.056193435 +0100
@@ -34,6 +34,7 @@
 #ifndef __UTF16_H__
 #define __UTF16_H__
 
+#include <stdbool.h>
 #include "unicode/umachine.h"
 #ifndef __UTF_H__
 #   include "unicode/utf.h"
@@ -396,7 +397,7 @@
         (s)[(i)++]=(uint16_t)(((c)>>10)+0xd7c0); \
         (s)[(i)++]=(uint16_t)(((c)&0x3ff)|0xdc00); \
     } else /* c>0x10ffff or not enough space */ { \
-        (isError)=TRUE; \
+        (isError)=true; \
     } \
 } UPRV_BLOCK_MACRO_END
 
diff -Naur orig/third_party/icu/source/common/unicode/utf8.h patched/third_party/icu/source/common/unicode/utf8.h
--- orig/third_party/icu/source/common/unicode/utf8.h	2020-10-21 02:17:34.000000000 +0200
+++ patched/third_party/icu/source/common/unicode/utf8.h	2020-11-02 22:31:48.060193460 +0100
@@ -34,6 +34,7 @@
 #ifndef __UTF8_H__
 #define __UTF8_H__
 
+#include <stdbool.h>
 #include "unicode/umachine.h"
 #ifndef __UTF_H__
 #   include "unicode/utf.h"
@@ -472,7 +473,7 @@
         (s)[(i)++]=(uint8_t)(((__uc>>6)&0x3f)|0x80); \
         (s)[(i)++]=(uint8_t)((__uc&0x3f)|0x80); \
     } else { \
-        (isError)=TRUE; \
+        (isError)=true; \
     } \
 } UPRV_BLOCK_MACRO_END
 
diff -Naur orig/third_party/icu/source/i18n/collationfcd.h patched/third_party/icu/source/i18n/collationfcd.h
--- orig/third_party/icu/source/i18n/collationfcd.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/collationfcd.h	2020-11-02 22:31:48.060193460 +0100
@@ -84,7 +84,7 @@
         // Handles all of Unicode 0..10FFFF.
         // c can be negative, e.g., U_SENTINEL.
         // U+0300 is the first character with lccc!=0.
-        if(c < 0x300) { return FALSE; }
+        if(c < 0x300) { return false; }
         if(c > 0xffff) { c = U16_LEAD(c); }
         int32_t i;
         return
diff -Naur orig/third_party/icu/source/i18n/collationiterator.h patched/third_party/icu/source/i18n/collationiterator.h
--- orig/third_party/icu/source/i18n/collationiterator.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/collationiterator.h	2020-11-02 22:31:48.060193460 +0100
@@ -76,9 +76,9 @@
             // (Rather than buffer.getCapacity().)
             if(length < INITIAL_CAPACITY || ensureAppendCapacity(1, errorCode)) {
                 ++length;
-                return TRUE;
+                return true;
             } else {
-                return FALSE;
+                return false;
             }
         }
 
diff -Naur orig/third_party/icu/source/i18n/fphdlimp.h patched/third_party/icu/source/i18n/fphdlimp.h
--- orig/third_party/icu/source/i18n/fphdlimp.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/fphdlimp.h	2020-11-02 22:31:48.060193460 +0100
@@ -41,8 +41,8 @@
 
 class FieldPositionOnlyHandler : public FieldPositionHandler {
   FieldPosition& pos;
-  UBool acceptFirstOnly = FALSE;
-  UBool seenFirst = FALSE;
+  UBool acceptFirstOnly = false;
+  UBool seenFirst = false;
 
  public:
   FieldPositionOnlyHandler(FieldPosition& pos);
diff -Naur orig/third_party/icu/source/i18n/numparse_types.h patched/third_party/icu/source/i18n/numparse_types.h
--- orig/third_party/icu/source/i18n/numparse_types.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/numparse_types.h	2020-11-02 22:31:48.060193460 +0100
@@ -71,7 +71,7 @@
     }
 
     inline UnicodeString toAliasedUnicodeString() const {
-        return UnicodeString(TRUE, fBuffer.getAlias(), -1);
+        return UnicodeString(true, fBuffer.getAlias(), -1);
     }
 
     bool operator==(const CompactUnicodeString& other) const {
diff -Naur orig/third_party/icu/source/i18n/plurrule_impl.h patched/third_party/icu/source/i18n/plurrule_impl.h
--- orig/third_party/icu/source/i18n/plurrule_impl.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/plurrule_impl.h	2020-11-02 22:31:48.060193460 +0100
@@ -320,8 +320,8 @@
     int32_t opNum = -1;             // for mod expressions, the right operand of the mod.
     int32_t value = -1;             // valid for 'is' rules only.
     UVector32 *rangeList = nullptr; // for 'in', 'within' rules. Null otherwise.
-    UBool negated = FALSE;          // TRUE for negated rules.
-    UBool integerOnly = FALSE;      // TRUE for 'within' rules.
+    UBool negated = false;          // true for negated rules.
+    UBool integerOnly = false;      // true for 'within' rules.
     tokenType digitsType = none;    // n | i | v | f constraint.
     AndConstraint *next = nullptr;
     // Internal error status, used for errors that occur during the copy constructor.
@@ -357,8 +357,8 @@
     OrConstraint   *ruleHeader = nullptr;
     UnicodeString   fDecimalSamples;  // Samples strings from rule source
     UnicodeString   fIntegerSamples;  //   without @decimal or @integer, otherwise unprocessed.
-    UBool           fDecimalSamplesUnbounded = FALSE;
-    UBool           fIntegerSamplesUnbounded = FALSE;
+    UBool           fDecimalSamplesUnbounded = false;
+    UBool           fIntegerSamplesUnbounded = false;
     // Internal error status, used for errors that occur during the copy constructor.
     UErrorCode      fInternalStatus = U_ZERO_ERROR;
 
diff -Naur orig/third_party/icu/source/i18n/unicode/calendar.h patched/third_party/icu/source/i18n/unicode/calendar.h
--- orig/third_party/icu/source/i18n/unicode/calendar.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/unicode/calendar.h	2020-11-02 22:31:48.060193460 +0100
@@ -2531,7 +2531,7 @@
 {
     fFields[field] = value;
     fStamp[field] = kInternallySet;
-    fIsSet[field]     = TRUE; // Remove later
+    fIsSet[field]     = true; // Remove later
 }
 
 
diff -Naur orig/third_party/icu/source/i18n/unicode/dcfmtsym.h patched/third_party/icu/source/i18n/unicode/dcfmtsym.h
--- orig/third_party/icu/source/i18n/unicode/dcfmtsym.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/unicode/dcfmtsym.h	2020-11-02 22:31:48.060193460 +0100
@@ -378,7 +378,7 @@
      *                             back to the locale.
      */
     void initialize(const Locale& locale, UErrorCode& success,
-        UBool useLastResortData = FALSE, const NumberingSystem* ns = nullptr);
+                    UBool useLastResortData = false, const NumberingSystem* ns = nullptr);
 
     /**
      * Initialize the symbols with default values.
@@ -543,12 +543,12 @@
 // -------------------------------------
 
 inline void
-DecimalFormatSymbols::setSymbol(ENumberFormatSymbol symbol, const UnicodeString &value, const UBool propogateDigits = TRUE) {
+DecimalFormatSymbols::setSymbol(ENumberFormatSymbol symbol, const UnicodeString &value, const UBool propagateDigits = true) {
     if (symbol == kCurrencySymbol) {
-        fIsCustomCurrencySymbol = TRUE;
+        fIsCustomCurrencySymbol = true;
     }
     else if (symbol == kIntlCurrencySymbol) {
-        fIsCustomIntlCurrencySymbol = TRUE;
+        fIsCustomIntlCurrencySymbol = true;
     }
     if(symbol<kFormatSymbolCount) {
         fSymbols[symbol]=value;
@@ -559,7 +559,7 @@
     // Also record updates to fCodePointZero. Be conservative if in doubt.
     if (symbol == kZeroDigitSymbol) {
         UChar32 sym = value.char32At(0);
-        if ( propogateDigits && u_charDigitValue(sym) == 0 && value.countChar32() == 1 ) {
+        if ( propagateDigits && u_charDigitValue(sym) == 0 && value.countChar32() == 1 ) {
             fCodePointZero = sym;
             for ( int8_t i = 1 ; i<= 9 ; i++ ) {
                 sym++;
diff -Naur orig/third_party/icu/source/i18n/unicode/dtfmtsym.h patched/third_party/icu/source/i18n/unicode/dtfmtsym.h
--- orig/third_party/icu/source/i18n/unicode/dtfmtsym.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/unicode/dtfmtsym.h	2020-11-02 22:31:48.060193460 +0100
@@ -919,7 +919,8 @@
      *                             failure code upon return.
      * @param useLastResortData    determine if use last resort data
      */
-    void initializeData(const Locale& locale, const char *type, UErrorCode& status, UBool useLastResortData = FALSE);
+    void initializeData(const Locale& locale, const char *type,
+                        UErrorCode& status, UBool useLastResortData = false);
 
     /**
      * Copy or alias an array in another object, as appropriate.
diff -Naur orig/third_party/icu/source/i18n/unicode/numberformatter.h patched/third_party/icu/source/i18n/unicode/numberformatter.h
--- orig/third_party/icu/source/i18n/unicode/numberformatter.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/unicode/numberformatter.h	2020-11-02 22:31:48.060193460 +0100
@@ -371,9 +371,9 @@
     UBool copyErrorTo(UErrorCode &status) const {
         if (fType == NTN_ERROR) {
             status = fUnion.errorCode;
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
 
     // To allow MacroProps to initialize empty instances:
@@ -725,9 +725,9 @@
     UBool copyErrorTo(UErrorCode &status) const {
         if (fType == RND_ERROR) {
             status = fUnion.errorCode;
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
 
     // On the parent type so that this method can be called internally on Precision instances.
@@ -969,9 +969,9 @@
     UBool copyErrorTo(UErrorCode &status) const {
         if (fHasError) {
             status = fUnion.errorCode;
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
 
     void apply(impl::DecimalQuantity &quantity, UErrorCode &status) const;
@@ -1097,9 +1097,9 @@
     UBool copyErrorTo(UErrorCode &status) const {
         if (fError != U_ZERO_ERROR) {
             status = fError;
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
 
     void applyTo(impl::DecimalQuantity& quantity) const;
@@ -1192,12 +1192,12 @@
     UBool copyErrorTo(UErrorCode &status) const {
         if (fType == SYMPTR_DFS && fPtr.dfs == nullptr) {
             status = U_MEMORY_ALLOCATION_ERROR;
-            return TRUE;
+            return true;
         } else if (fType == SYMPTR_NS && fPtr.ns == nullptr) {
             status = U_MEMORY_ALLOCATION_ERROR;
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
 
   private:
@@ -1341,9 +1341,9 @@
     UBool copyErrorTo(UErrorCode &status) const {
         if (fWidth == -3) {
             status = fUnion.errorCode;
-            return TRUE;
+            return true;
         }
-        return FALSE;
+        return false;
     }
 
     bool isValid() const {
@@ -2120,13 +2120,13 @@
     /**
      * Sets the UErrorCode if an error occurred in the fluent chain.
      * Preserves older error codes in the outErrorCode.
-     * @return TRUE if U_FAILURE(outErrorCode)
+     * @return true if U_FAILURE(outErrorCode)
      * @stable ICU 60
      */
     UBool copyErrorTo(UErrorCode &outErrorCode) const {
         if (U_FAILURE(outErrorCode)) {
             // Do not overwrite the older error code
-            return TRUE;
+            return true;
         }
         fMacros.copyErrorTo(outErrorCode);
         return U_FAILURE(outErrorCode);
diff -Naur orig/third_party/icu/source/i18n/unicode/numberrangeformatter.h patched/third_party/icu/source/i18n/unicode/numberrangeformatter.h
--- orig/third_party/icu/source/i18n/unicode/numberrangeformatter.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/unicode/numberrangeformatter.h	2020-11-02 22:31:48.060193460 +0100
@@ -474,13 +474,13 @@
     /**
      * Sets the UErrorCode if an error occurred in the fluent chain.
      * Preserves older error codes in the outErrorCode.
-     * @return TRUE if U_FAILURE(outErrorCode)
+     * @return true if U_FAILURE(outErrorCode)
      * @stable ICU 63
      */
     UBool copyErrorTo(UErrorCode &outErrorCode) const {
         if (U_FAILURE(outErrorCode)) {
             // Do not overwrite the older error code
-            return TRUE;
+            return true;
         }
         fMacros.copyErrorTo(outErrorCode);
         return U_FAILURE(outErrorCode);
diff -Naur orig/third_party/icu/source/i18n/unicode/numfmt.h patched/third_party/icu/source/i18n/unicode/numfmt.h
--- orig/third_party/icu/source/i18n/unicode/numfmt.h	2020-10-21 02:17:35.000000000 +0200
+++ patched/third_party/icu/source/i18n/unicode/numfmt.h	2020-11-02 22:31:48.060193460 +0100
@@ -1151,7 +1151,7 @@
 
   private:
     UBool      fParseIntegerOnly;
-    UBool      fLenient; // TRUE => lenient parse is enabled
+    UBool      fLenient; // true => lenient parse is enabled
 
     // ISO currency code
     char16_t      fCurrency[4];
@@ -1228,7 +1228,7 @@
     /**
      * @stable ICU 2.6
      */
-    SimpleNumberFormatFactory(const Locale& locale, UBool visible = TRUE);
+    SimpleNumberFormatFactory(const Locale& locale, UBool visible = true);
 
     /**
      * @stable ICU 3.0
