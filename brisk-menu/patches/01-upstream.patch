diff -Naur a/AUTHORS b/AUTHORS
--- a/AUTHORS	2017-11-02 20:16:40.000000000 +0100
+++ b/AUTHORS	2019-11-25 14:46:11.074938866 +0100
@@ -2,5 +2,6 @@
 Federico Damián Schonborn <federicodamiansch@gmail.com>
 Ikey Doherty <ikey@solus-project.com>
 Martin Wimpress <code@flexion.org>
+Stefan Ric <stefan@solus-project.com>
 Stefan Ric <stfric369@gmail.com>
 Victor Kareh <vkareh@vkareh.net>
diff -Naur a/data/brisk.gresource.xml b/data/brisk.gresource.xml
--- a/data/brisk.gresource.xml	2017-11-02 20:16:40.000000000 +0100
+++ b/data/brisk.gresource.xml	2019-11-25 14:46:11.082938980 +0100
@@ -1,6 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <gresources>
         <gresource prefix="/com/solus-project/brisk/menu">
-                <file>styling.css</file>
+                <file>classic/styling.css</file>
+                <file>dash/styling.css</file>
+                <file>dash/styling-light.css</file>
         </gresource>
 </gresources>
diff -Naur a/data/classic/styling.css b/data/classic/styling.css
--- a/data/classic/styling.css	1970-01-01 01:00:00.000000000 +0100
+++ b/data/classic/styling.css	2019-11-25 14:46:11.082938980 +0100
@@ -0,0 +1,9 @@
+.brisk-button-vertical {
+    padding: 0px;
+    margin: 0px;
+}
+
+.brisk-button {
+    padding: 0px;
+    margin: 0px;
+}
diff -Naur a/data/com.solus-project.brisk-menu.gschema.xml b/data/com.solus-project.brisk-menu.gschema.xml
--- a/data/com.solus-project.brisk-menu.gschema.xml	2017-11-02 20:16:40.000000000 +0100
+++ b/data/com.solus-project.brisk-menu.gschema.xml	2019-11-25 14:46:11.082938980 +0100
@@ -5,6 +5,11 @@
       <value nick="top" value="2" />
       <value nick="automatic" value="4" />
   </enum>
+  <enum id="com.solus-project.brisk-menu.WindowType">
+      <value nick="classic" value="1" />
+      <value nick="dash" value="2" />
+      <value nick="automatic" value="4" />
+  </enum>
   <schema path="/com/solus-project/brisk-menu/" id="com.solus-project.brisk-menu">
     <key type="as" name="pinned-shortcuts">
       <default>['matecc.desktop']</default>
@@ -31,6 +36,11 @@
       <summary>Search bar position</summary>
       <description>Where the search bar will appear in the menu</description>
     </key>
+    <key enum="com.solus-project.brisk-menu.WindowType" name="window-type">
+      <default>'classic'</default>
+      <summary>Window type</summary>
+      <description>The window we're going to display</description>
+    </key>
     <key type="s" name="hot-key">
       <default>'Super_L'</default>
       <summary>Keyboard shortcut</summary>
diff -Naur a/data/dash/styling.css b/data/dash/styling.css
--- a/data/dash/styling.css	1970-01-01 01:00:00.000000000 +0100
+++ b/data/dash/styling.css	2019-11-25 14:46:11.082938980 +0100
@@ -0,0 +1,43 @@
+.brisk-button-vertical {
+    padding: 0px;
+    margin: 0px;
+}
+
+.brisk-button {
+    padding: 0px;
+    margin: 0px;
+}
+
+.brisk-dash {
+	background-color: alpha(@theme_bg_color, 0.95);
+}
+
+.brisk-dash .dash-category-button {
+	border: 1px solid transparent;
+	background-color: transparent;
+	font-weight: bold;
+}
+
+.brisk-dash .dash-category-button:checked {
+	background-color: mix(@theme_bg_color, #000000, 0.2);
+	border: 1px solid alpha(@theme_fg_color, 0.1);
+}
+
+.brisk-dash .dash-category-button:hover {
+	background-color: mix(@theme_bg_color, #000000, 0.2);
+	border: 1px solid alpha(#000, 0.2);
+}
+
+.brisk-dash .header {
+	background-color: mix(@theme_bg_color, #000000, 0.1);
+    border-bottom: 1px solid mix(@theme_base_color, #000000,  0.35);
+    box-shadow: 0px 1px 1px alpha(@theme_fg_color, 0.04);
+}
+
+.brisk-dash .header .section-box-holder {
+	margin: 5px;
+}
+
+scrolledwindow {
+	border: none;
+}
\ Nincs új sor a fájl végén
diff -Naur a/data/dash/styling-light.css b/data/dash/styling-light.css
--- a/data/dash/styling-light.css	1970-01-01 01:00:00.000000000 +0100
+++ b/data/dash/styling-light.css	2019-11-25 14:46:11.082938980 +0100
@@ -0,0 +1,43 @@
+.brisk-button-vertical {
+    padding: 0px;
+    margin: 0px;
+}
+
+.brisk-button {
+    padding: 0px;
+    margin: 0px;
+}
+
+.brisk-dash {
+	background-color: alpha(@dark_bg_color, 0.95);
+}
+
+.brisk-dash .dash-category-button {
+	border: 1px solid transparent;
+	background-color: transparent;
+	font-weight: bold;
+}
+
+.brisk-dash .dash-category-button:checked {
+	background-color: mix(@dark_bg_color, #000000, 0.2);
+	border: 1px solid alpha(@dark_fg_color, 0.1);
+}
+
+.brisk-dash .dash-category-button:hover {
+	background-color: mix(@dark_bg_color, #000000, 0.2);
+	border: 1px solid alpha(#000, 0.2);
+}
+
+.brisk-dash .header {
+	background-color: mix(@dark_bg_color, #000000, 0.1);
+    border-bottom: 1px solid mix(@dark_bg_color, #000000,  0.35);
+    box-shadow: 0px 1px 1px alpha(@dark_fg_color, 0.04);
+}
+
+.brisk-dash .header .section-box-holder {
+	margin: 5px;
+}
+
+scrolledwindow {
+	border: none;
+}
\ Nincs új sor a fájl végén
diff -Naur a/data/meson.build b/data/meson.build
--- a/data/meson.build	2017-11-02 20:16:40.000000000 +0100
+++ b/data/meson.build	2019-11-25 14:46:11.082938980 +0100
@@ -12,6 +12,22 @@
     ],
 )
 
+# libsaver_glue provides dbus code for the MATE screensaver
+libsaver_glue = gnome.gdbus_codegen(
+    'libsaver-glue',
+    'org.mate.ScreenSaver.xml',
+    interface_prefix : 'org.mate.',
+    namespace : 'Mate',
+)
+
+# libsession_glue provides dbus code for the MATE/GNOME session
+libsession_glue = gnome.gdbus_codegen(
+    'libsession-glue',
+    'org.gnome.SessionManager.xml',
+    interface_prefix : 'org.gnome.',
+    namespace : 'Gnome',
+)
+
 icons = [
     'brisk_system-log-out-symbolic.svg',
 ]
diff -Naur a/data/org.gnome.SessionManager.xml b/data/org.gnome.SessionManager.xml
--- a/data/org.gnome.SessionManager.xml	1970-01-01 01:00:00.000000000 +0100
+++ b/data/org.gnome.SessionManager.xml	2019-11-25 14:46:11.082938980 +0100
@@ -0,0 +1,15 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+                      "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<!-- GDBus 2.48.1 -->
+<node>
+  <interface name="org.gnome.SessionManager">
+    <method name="Shutdown"/>
+    <method name="Reboot"/>
+    <method name="CanShutdown">
+      <arg type="b" name="is_available" direction="out"/>
+    </method>
+    <method name="Logout">
+      <arg type="u" name="mode" direction="in"/>
+    </method>
+  </interface>
+</node>
diff -Naur a/data/org.mate.ScreenSaver.xml b/data/org.mate.ScreenSaver.xml
--- a/data/org.mate.ScreenSaver.xml	1970-01-01 01:00:00.000000000 +0100
+++ b/data/org.mate.ScreenSaver.xml	2019-11-25 14:46:11.082938980 +0100
@@ -0,0 +1,11 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.mate.ScreenSaver">
+    <method name="Lock">
+    </method>
+    <method name="GetActive">
+      <arg name="value" direction="out" type="b"/>
+    </method>
+  </interface>
+</node>
diff -Naur a/data/styling.css b/data/styling.css
--- a/data/styling.css	2017-11-02 20:16:40.000000000 +0100
+++ b/data/styling.css	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-.brisk-button-vertical {
-    padding: 0px;
-    margin: 0px;
-}
-
-.brisk-button {
-    padding: 0px;
-    margin: 0px;
-}
diff -Naur a/meson_post_install.sh b/meson_post_install.sh
--- a/meson_post_install.sh	2017-11-02 20:16:40.000000000 +0100
+++ b/meson_post_install.sh	2019-11-25 14:46:11.082938980 +0100
@@ -4,7 +4,13 @@
 # <3 TingPing ^^
 if [ -z $DESTDIR ]; then
 
-	PREFIX=${MESON_INSTALL_PREFIX:-/usr}
+	SYSTEM=$(uname)
+
+	if [ "${SYSTEM}" = "FreeBSD" ]; then
+		PREFIX=${MESON_INSTALL_PREFIX:-/usr/local}
+	else
+		PREFIX=${MESON_INSTALL_PREFIX:-/usr}
+	fi
 
 	echo 'Compiling GSchema'
 	glib-compile-schemas "$PREFIX/share/glib-2.0/schemas"
diff -Naur a/po/brisk-menu.pot b/po/brisk-menu.pot
--- a/po/brisk-menu.pot	2017-11-02 20:16:40.000000000 +0100
+++ b/po/brisk-menu.pot	2019-11-25 14:46:11.082938980 +0100
@@ -1,14 +1,14 @@
 # SOME DESCRIPTIVE TITLE.
 # Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
-# This file is distributed under the same license as the PACKAGE package.
+# This file is distributed under the same license as the brisk-menu package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 #
 #, fuzzy
 msgid ""
 msgstr ""
-"Project-Id-Version: PACKAGE VERSION\n"
+"Project-Id-Version: brisk-menu\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2017-05-20 04:38+0100\n"
+"POT-Creation-Date: 2018-02-08 11:02+0000\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -17,49 +17,92 @@
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: ../src/mate-applet/applet.c:263
-msgid "Menu"
+#: src/backend/all-items/all-backend.c:52
+msgid "All Items"
 msgstr ""
 
-#: ../src/mate-applet/main.c:49
-msgid "_Edit Menus"
+#: src/backend/all-items/all-section.c:102
+#: src/frontend/classic/category-button.c:115
+#: src/frontend/dash/category-button.c:111
+msgid "All"
 msgstr ""
 
-#: ../src/mate-applet/main.c:84
-msgid "Brisk Menu Launcher"
+#: src/backend/apps/apps-backend.c:116
+msgid "Applications"
 msgstr ""
 
-#: ../src/frontend/category-button.c:115
-#: ../src/backend/all-items/all-section.c:102
-msgid "All"
+#: src/backend/favourites/favourites-backend.c:56
+#: src/backend/favourites/favourites-section.c:148
+msgid "Favourites"
 msgstr ""
 
-#: ../src/frontend/menu-session.c:144
-msgid "End the current session"
+#: src/backend/favourites/favourites-backend.c:74
+msgid "Unpin from favourites menu"
 msgstr ""
 
-#: ../src/frontend/menu-session.c:155
-msgid "Lock the screen"
+#: src/backend/favourites/favourites-backend.c:78
+msgid "Pin to favourites menu"
 msgstr ""
 
-#: ../src/frontend/menu-session.c:166
-msgid "Turn off the device"
+#: src/backend/favourites/favourites-desktop.c:222
+msgid "Unpin from desktop"
+msgstr ""
+
+#: src/backend/favourites/favourites-desktop.c:227
+msgid "Pin to desktop"
+msgstr ""
+
+#: src/frontend/classic/classic-window.c:71
+msgid "Classic"
 msgstr ""
 
 #. Translators: This is the text shown in the "search box" with no content
-#: ../src/frontend/menu-window.c:141
+#: src/frontend/classic/classic-window.c:395
+#: src/frontend/dash/dash-window.c:358
 msgid "Type to search"
 msgstr ""
 
 #. Translators: This message is shown when the search results are empty
-#: ../src/frontend/menu-window.c:203
+#: src/frontend/classic/classic-window.c:453
 msgid "Sorry, no items found"
 msgstr ""
 
-#: ../src/backend/all-items/all-backend.c:52
-msgid "All Items"
+#: src/frontend/classic/classic-window.c:659
+msgid "End the current session"
 msgstr ""
 
-#: ../src/backend/apps/apps-backend.c:111
-msgid "Applications"
+#: src/frontend/classic/classic-window.c:670
+msgid "Lock the screen"
+msgstr ""
+
+#: src/frontend/classic/classic-window.c:681
+msgid "Turn off the device"
+msgstr ""
+
+#: src/frontend/dash/dash-window.c:63
+msgid "Dash"
+msgstr ""
+
+#: src/mate-applet/applet.c:248
+msgid "Menu"
+msgstr ""
+
+#: src/mate-applet/applet.c:337
+msgid "Failed to launch menu editor"
+msgstr ""
+
+#: src/mate-applet/applet.c:338
+msgid "Please install 'menulibre' or 'mozo' to edit menus"
+msgstr ""
+
+#: src/mate-applet/main.c:52
+msgid "_Edit Menus"
+msgstr ""
+
+#: src/mate-applet/main.c:60
+msgid "_About"
+msgstr ""
+
+#: src/mate-applet/main.c:92 src/mate-applet/main.c:104
+msgid "Brisk Menu Launcher"
 msgstr ""
diff -Naur a/po/POTFILES.in b/po/POTFILES.in
--- a/po/POTFILES.in	2017-11-02 20:16:40.000000000 +0100
+++ b/po/POTFILES.in	2019-11-25 14:46:11.082938980 +0100
@@ -1,10 +1,12 @@
-src/mate-applet/applet.c
-src/mate-applet/main.c
-src/frontend/category-button.c
-src/frontend/menu-session.c
-src/frontend/menu-window.c
 src/backend/all-items/all-backend.c
 src/backend/all-items/all-section.c
 src/backend/apps/apps-backend.c
 src/backend/favourites/favourites-backend.c
+src/backend/favourites/favourites-desktop.c
 src/backend/favourites/favourites-section.c
+src/frontend/classic/category-button.c
+src/frontend/classic/classic-window.c
+src/frontend/dash/category-button.c
+src/frontend/dash/dash-window.c
+src/mate-applet/applet.c
+src/mate-applet/main.c
diff -Naur a/README.md b/README.md
--- a/README.md	2017-11-02 20:16:40.000000000 +0100
+++ b/README.md	2019-11-25 14:46:11.082938980 +0100
@@ -3,10 +3,11 @@
 
 [![Coverity Scan](https://img.shields.io/coverity/scan/11139.svg)](https://scan.coverity.com/projects/solus-project-brisk-menu) [![License](https://img.shields.io/badge/License-GPL%202.0-blue.svg)](https://opensource.org/licenses/GPL-2.0)
 
-Modern, efficient menu for the MATE Desktop Environment.
+brisk-menu is a modern and efficient menu designed to improve the MATE Desktop Environment with modern, first-class options.
 
-This project aims to reinvigorate the MATE Desktop with modern, first-class options. As such, Brisk Menu is a **distro-agnostic** desktop. Please ensure to report any issues of non portability!
-The primary motivation is to provide a very usable menu, as seen in other desktops, but without the bloat and/or performance problems that plague current offerings.
+The purpose of this project is to provide a usable menu as seen in other desktops without the bloat and performance issues.
+
+brisk-menu is **distro-agnostic** and the reporting of portability issues is encouraged.
 
 ![screenshot](https://raw.githubusercontent.com/solus-project/brisk-menu/master/.github/main.png)
 
@@ -38,21 +39,24 @@
 
 **Planned**
 
-Some items that are currently known to be definite options in the roadmap:
+These planned features will be implemented in the future:
 
  - Settings UI to control further visual aspects (labels/icons/options)
  - Improved styling for the window edge + search entry.
 
-More will be added in time as we go along.
+More will be added.
 
 ![screenshot_context](https://raw.githubusercontent.com/solus-project/brisk-menu/master/.github/context.png)
 
 Building Brisk Menu
 -------------------
+**Requirements:**
+
+ * GTK 3.18 or greater
+ * GTK 3.18 build of Mate 1.16 or greater
+ * **Modern** `meson` (`0.40.x`+) and `ninja` (Ubuntu users should use xenial-backports)
 
- * Please ensure you have GTK 3.18 *minimum*
- * Please ensure you are using a GTK 3.18 build of MATE 1.16 or newer
- * Ensure you have a **modern** `meson` (`0.40.x`+) and `ninja` (Ubuntu users, use xenial-backports!)
+**Build Process:**
 
 ```bash
     meson --buildtype plain build --prefix=/usr
@@ -71,7 +75,7 @@
 License
 --------
 
-Copyright © 2016-2017 Brisk Menu Developers
+Copyright © 2016-2018 Brisk Menu Developers
 
 `brisk-menu` is available under the terms of the `GPL-2.0` license.
 
diff -Naur a/src/frontend/category-button.c b/src/frontend/category-button.c
--- a/src/frontend/category-button.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/category-button.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,206 +0,0 @@
-/*
- * This file is part of brisk-menu.
- *
- * Copyright © 2016-2017 Brisk Menu Developers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#define _GNU_SOURCE
-
-#include "util.h"
-
-BRISK_BEGIN_PEDANTIC
-#include "category-button.h"
-#include "menu-private.h"
-#include <glib/gi18n.h>
-#include <gtk/gtk.h>
-BRISK_END_PEDANTIC
-
-struct _BriskMenuCategoryButtonClass {
-        GtkRadioButtonClass parent_class;
-};
-
-/**
- * BriskMenuCategoryButton is the toplevel window type used within the applet.
- */
-struct _BriskMenuCategoryButton {
-        GtkRadioButton parent;
-        BriskSection *section;
-        GtkWidget *label;
-        GtkWidget *image;
-};
-
-G_DEFINE_TYPE(BriskMenuCategoryButton, brisk_menu_category_button, GTK_TYPE_RADIO_BUTTON)
-
-enum { PROP_SECTION = 1, N_PROPS };
-
-static GParamSpec *obj_properties[N_PROPS] = {
-        NULL,
-};
-
-static void brisk_menu_category_button_set_property(GObject *object, guint id, const GValue *value,
-                                                    GParamSpec *spec)
-{
-        BriskMenuCategoryButton *self = BRISK_MENU_CATEGORY_BUTTON(object);
-
-        switch (id) {
-        case PROP_SECTION:
-                self->section = g_value_get_pointer(value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
-                break;
-        }
-}
-
-static void brisk_menu_category_button_get_property(GObject *object, guint id, GValue *value,
-                                                    GParamSpec *spec)
-{
-        BriskMenuCategoryButton *self = BRISK_MENU_CATEGORY_BUTTON(object);
-
-        switch (id) {
-        case PROP_SECTION:
-                g_value_set_pointer(value, self->section);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
-                break;
-        }
-}
-
-/**
- * brisk_menu_category_button_new:
- *
- * Construct a new BriskMenuCategoryButton object
- */
-GtkWidget *brisk_menu_category_button_new(BriskSection *section)
-{
-        return g_object_new(BRISK_TYPE_MENU_CATEGORY_BUTTON, "section", section, NULL);
-}
-
-/**
- * brisk_menu_category_button_dispose:
- *
- * Clean up a BriskMenuCategoryButton instance
- */
-static void brisk_menu_category_button_dispose(GObject *obj)
-{
-        BriskMenuCategoryButton *self = BRISK_MENU_CATEGORY_BUTTON(obj);
-
-        g_clear_object(&self->section);
-
-        G_OBJECT_CLASS(brisk_menu_category_button_parent_class)->dispose(obj);
-}
-
-/**
- * Handle constructor specifics for our button
- */
-static void brisk_menu_category_button_constructed(GObject *obj)
-{
-        BriskMenuCategoryButton *self = NULL;
-
-        self = BRISK_MENU_CATEGORY_BUTTON(obj);
-
-        /* If we have a section, use it, otherwise we're a special "All" button */
-        if (self->section) {
-                gtk_label_set_label(GTK_LABEL(self->label), brisk_section_get_name(self->section));
-                gtk_image_set_from_gicon(GTK_IMAGE(self->image),
-                                         (GIcon *)brisk_section_get_icon(self->section),
-                                         GTK_ICON_SIZE_BUTTON);
-        } else {
-                gtk_label_set_label(GTK_LABEL(self->label), _("All"));
-                gtk_image_set_from_icon_name(GTK_IMAGE(self->image),
-                                             "starred",
-                                             GTK_ICON_SIZE_BUTTON);
-        }
-
-        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 16);
-
-        G_OBJECT_CLASS(brisk_menu_category_button_parent_class)->constructed(obj);
-}
-
-/**
- * brisk_menu_category_button_class_init:
- *
- * Handle class initialisation
- */
-static void brisk_menu_category_button_class_init(BriskMenuCategoryButtonClass *klazz)
-{
-        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
-
-        /* gobject vtable hookup */
-        obj_class->dispose = brisk_menu_category_button_dispose;
-        obj_class->set_property = brisk_menu_category_button_set_property;
-        obj_class->get_property = brisk_menu_category_button_get_property;
-        obj_class->constructed = brisk_menu_category_button_constructed;
-
-        obj_properties[PROP_SECTION] = g_param_spec_pointer("section",
-                                                            "The BriskSection",
-                                                            "Section that this category represents",
-                                                            G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
-        g_object_class_install_properties(obj_class, N_PROPS, obj_properties);
-}
-
-/**
- * brisk_menu_category_button_init:
- *
- * Handle construction of the BriskMenuCategoryButton
- */
-static void brisk_menu_category_button_init(BriskMenuCategoryButton *self)
-{
-        GtkStyleContext *style = NULL;
-        GtkWidget *label = NULL;
-        GtkWidget *image = NULL;
-        GtkWidget *layout = NULL;
-
-        /* Main layout */
-        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-        gtk_container_add(GTK_CONTAINER(self), layout);
-
-        /* Image on the left */
-        image = gtk_image_new();
-        self->image = image;
-        gtk_widget_set_margin_end(image, 7);
-        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
-
-        /* Display label */
-        label = gtk_label_new("");
-        self->label = label;
-        g_object_set(self->label,
-                     "halign",
-                     GTK_ALIGN_START,
-                     "valign",
-                     GTK_ALIGN_CENTER,
-                     "margin-end",
-                     15,
-                     NULL);
-        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
-
-        /* Button specific fixes */
-        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
-
-        /* Look like a button */
-        g_object_set(G_OBJECT(self), "draw-indicator", FALSE, NULL);
-        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
-
-        /* Flatten the button */
-        style = gtk_widget_get_style_context(GTK_WIDGET(self));
-        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
-}
-
-/*
- * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
- *
- * Local variables:
- * c-basic-offset: 8
- * tab-width: 8
- * indent-tabs-mode: nil
- * End:
- *
- * vi: set shiftwidth=8 tabstop=8 expandtab:
- * :indentSize=8:tabSize=8:noTabs=true:
- */
diff -Naur a/src/frontend/category-button.h b/src/frontend/category-button.h
--- a/src/frontend/category-button.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/category-button.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/*
- * This file is part of brisk-menu.
- *
- * Copyright © 2016-2017 Brisk Menu Developers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#pragma once
-
-#include "backend/section.h"
-#include <glib-object.h>
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-typedef struct _BriskMenuCategoryButton BriskMenuCategoryButton;
-typedef struct _BriskMenuCategoryButtonClass BriskMenuCategoryButtonClass;
-
-#define BRISK_TYPE_MENU_CATEGORY_BUTTON brisk_menu_category_button_get_type()
-#define BRISK_MENU_CATEGORY_BUTTON(o)                                                              \
-        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_MENU_CATEGORY_BUTTON, BriskMenuCategoryButton))
-#define BRISK_IS_MENU_CATEGORY_BUTTON(o)                                                           \
-        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_MENU_CATEGORY_BUTTON))
-#define BRISK_MENU_CATEGORY_BUTTON_CLASS(o)                                                        \
-        (G_TYPE_CHECK_CLASS_CAST((o),                                                              \
-                                 BRISK_TYPE_MENU_CATEGORY_BUTTON,                                  \
-                                 BriskMenuCategoryButtonClass))
-#define BRISK_IS_MENU_CATEGORY_BUTTON_CLASS(o)                                                     \
-        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_MENU_CATEGORY_BUTTON))
-#define BRISK_MENU_CATEGORY_BUTTON_GET_CLASS(o)                                                    \
-        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
-                                   BRISK_TYPE_MENU_CATEGORY_BUTTON,                                \
-                                   BriskMenuCategoryButtonClass))
-
-/**
- * Construct a new BriskMenuCategoryButton from the given group
- */
-GtkWidget *brisk_menu_category_button_new(BriskSection *section);
-
-GType brisk_menu_category_button_get_type(void);
-
-G_END_DECLS
-
-/*
- * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
- *
- * Local variables:
- * c-basic-offset: 8
- * tab-width: 8
- * indent-tabs-mode: nil
- * End:
- *
- * vi: set shiftwidth=8 tabstop=8 expandtab:
- * :indentSize=8:tabSize=8:noTabs=true:
- */
diff -Naur a/src/frontend/classic/category-button.c b/src/frontend/classic/category-button.c
--- a/src/frontend/classic/category-button.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/category-button.c	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,206 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2016-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "category-button.h"
+#include "menu-private.h"
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+BRISK_END_PEDANTIC
+
+struct _BriskClassicCategoryButtonClass {
+        GtkRadioButtonClass parent_class;
+};
+
+/**
+ * BriskClassicCategoryButton is the toplevel window type used within the applet.
+ */
+struct _BriskClassicCategoryButton {
+        GtkRadioButton parent;
+        BriskSection *section;
+        GtkWidget *label;
+        GtkWidget *image;
+};
+
+G_DEFINE_TYPE(BriskClassicCategoryButton, brisk_classic_category_button, GTK_TYPE_RADIO_BUTTON)
+
+enum { PROP_SECTION = 1, N_PROPS };
+
+static GParamSpec *obj_properties[N_PROPS] = {
+        NULL,
+};
+
+static void brisk_classic_category_button_set_property(GObject *object, guint id,
+                                                       const GValue *value, GParamSpec *spec)
+{
+        BriskClassicCategoryButton *self = BRISK_CLASSIC_CATEGORY_BUTTON(object);
+
+        switch (id) {
+        case PROP_SECTION:
+                self->section = g_value_get_pointer(value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
+        }
+}
+
+static void brisk_classic_category_button_get_property(GObject *object, guint id, GValue *value,
+                                                       GParamSpec *spec)
+{
+        BriskClassicCategoryButton *self = BRISK_CLASSIC_CATEGORY_BUTTON(object);
+
+        switch (id) {
+        case PROP_SECTION:
+                g_value_set_pointer(value, self->section);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
+        }
+}
+
+/**
+ * brisk_classic_category_button_new:
+ *
+ * Construct a new BriskClassicCategoryButton object
+ */
+GtkWidget *brisk_classic_category_button_new(BriskSection *section)
+{
+        return g_object_new(BRISK_TYPE_CLASSIC_CATEGORY_BUTTON, "section", section, NULL);
+}
+
+/**
+ * brisk_classic_category_button_dispose:
+ *
+ * Clean up a BriskClassicCategoryButton instance
+ */
+static void brisk_classic_category_button_dispose(GObject *obj)
+{
+        BriskClassicCategoryButton *self = BRISK_CLASSIC_CATEGORY_BUTTON(obj);
+
+        g_clear_object(&self->section);
+
+        G_OBJECT_CLASS(brisk_classic_category_button_parent_class)->dispose(obj);
+}
+
+/**
+ * Handle constructor specifics for our button
+ */
+static void brisk_classic_category_button_constructed(GObject *obj)
+{
+        BriskClassicCategoryButton *self = NULL;
+
+        self = BRISK_CLASSIC_CATEGORY_BUTTON(obj);
+
+        /* If we have a section, use it, otherwise we're a special "All" button */
+        if (self->section) {
+                gtk_label_set_label(GTK_LABEL(self->label), brisk_section_get_name(self->section));
+                gtk_image_set_from_gicon(GTK_IMAGE(self->image),
+                                         (GIcon *)brisk_section_get_icon(self->section),
+                                         GTK_ICON_SIZE_BUTTON);
+        } else {
+                gtk_label_set_label(GTK_LABEL(self->label), _("All"));
+                gtk_image_set_from_icon_name(GTK_IMAGE(self->image),
+                                             "starred",
+                                             GTK_ICON_SIZE_BUTTON);
+        }
+
+        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 16);
+
+        G_OBJECT_CLASS(brisk_classic_category_button_parent_class)->constructed(obj);
+}
+
+/**
+ * brisk_classic_category_button_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_classic_category_button_class_init(BriskClassicCategoryButtonClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->dispose = brisk_classic_category_button_dispose;
+        obj_class->set_property = brisk_classic_category_button_set_property;
+        obj_class->get_property = brisk_classic_category_button_get_property;
+        obj_class->constructed = brisk_classic_category_button_constructed;
+
+        obj_properties[PROP_SECTION] = g_param_spec_pointer("section",
+                                                            "The BriskSection",
+                                                            "Section that this category represents",
+                                                            G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
+        g_object_class_install_properties(obj_class, N_PROPS, obj_properties);
+}
+
+/**
+ * brisk_classic_category_button_init:
+ *
+ * Handle construction of the BriskClassicCategoryButton
+ */
+static void brisk_classic_category_button_init(BriskClassicCategoryButton *self)
+{
+        GtkStyleContext *style = NULL;
+        GtkWidget *label = NULL;
+        GtkWidget *image = NULL;
+        GtkWidget *layout = NULL;
+
+        /* Main layout */
+        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        /* Image on the left */
+        image = gtk_image_new();
+        self->image = image;
+        gtk_widget_set_margin_end(image, 7);
+        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
+
+        /* Display label */
+        label = gtk_label_new("");
+        self->label = label;
+        g_object_set(self->label,
+                     "halign",
+                     GTK_ALIGN_START,
+                     "valign",
+                     GTK_ALIGN_CENTER,
+                     "margin-end",
+                     15,
+                     NULL);
+        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
+
+        /* Button specific fixes */
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+
+        /* Look like a button */
+        g_object_set(G_OBJECT(self), "draw-indicator", FALSE, NULL);
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+
+        /* Flatten the button */
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/category-button.h b/src/frontend/classic/category-button.h
--- a/src/frontend/classic/category-button.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/category-button.h	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,61 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2016-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "backend/section.h"
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskClassicCategoryButton BriskClassicCategoryButton;
+typedef struct _BriskClassicCategoryButtonClass BriskClassicCategoryButtonClass;
+
+#define BRISK_TYPE_CLASSIC_CATEGORY_BUTTON brisk_classic_category_button_get_type()
+#define BRISK_CLASSIC_CATEGORY_BUTTON(o)                                                           \
+        (G_TYPE_CHECK_INSTANCE_CAST((o),                                                           \
+                                    BRISK_TYPE_CLASSIC_CATEGORY_BUTTON,                            \
+                                    BriskClassicCategoryButton))
+#define BRISK_IS_CLASSIC_CATEGORY_BUTTON(o)                                                        \
+        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_CLASSIC_CATEGORY_BUTTON))
+#define BRISK_CLASSIC_CATEGORY_BUTTON_CLASS(o)                                                     \
+        (G_TYPE_CHECK_CLASS_CAST((o),                                                              \
+                                 BRISK_TYPE_CLASSIC_CATEGORY_BUTTON,                               \
+                                 BriskClassicCategoryButtonClass))
+#define BRISK_IS_CLASSIC_CATEGORY_BUTTON_CLASS(o)                                                  \
+        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_CLASSIC_CATEGORY_BUTTON))
+#define BRISK_CLASSIC_CATEGORY_BUTTON_GET_CLASS(o)                                                 \
+        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
+                                   BRISK_TYPE_CLASSIC_CATEGORY_BUTTON,                             \
+                                   BriskClassicCategoryButtonClass))
+
+/**
+ * Construct a new BriskClassicCategoryButton from the given group
+ */
+GtkWidget *brisk_classic_category_button_new(BriskSection *section);
+
+GType brisk_classic_category_button_get_type(void);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/classic-entry-button.c b/src/frontend/classic/classic-entry-button.c
--- a/src/frontend/classic/classic-entry-button.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/classic-entry-button.c	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,147 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "styles.h"
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "classic-entry-button.h"
+
+#include <glib/gi18n.h>
+BRISK_END_PEDANTIC
+
+G_DEFINE_TYPE(BriskClassicEntryButton, brisk_classic_entry_button, BRISK_TYPE_MENU_ENTRY_BUTTON)
+
+/**
+ * Handle constructor specifics for our button
+ */
+static void brisk_classic_entry_button_constructed(GObject *obj)
+{
+        BriskClassicEntryButton *self = NULL;
+        const GIcon *icon = NULL;
+
+        self = BRISK_CLASSIC_ENTRY_BUTTON(obj);
+
+        icon = brisk_item_get_icon(BRISK_MENU_ENTRY_BUTTON(self)->item);
+        if (icon) {
+                gtk_image_set_from_gicon(GTK_IMAGE(self->image),
+                                         (GIcon *)icon,
+                                         GTK_ICON_SIZE_LARGE_TOOLBAR);
+        } else {
+                gtk_image_set_from_icon_name(GTK_IMAGE(self->image),
+                                             "image-missing",
+                                             GTK_ICON_SIZE_LARGE_TOOLBAR);
+        }
+
+        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 24);
+
+        /* Determine our label based on the app */
+        gtk_label_set_label(GTK_LABEL(self->label),
+                            brisk_item_get_name(BRISK_MENU_ENTRY_BUTTON(self)->item));
+        gtk_widget_set_tooltip_text(GTK_WIDGET(self),
+                                    brisk_item_get_summary(BRISK_MENU_ENTRY_BUTTON(self)->item));
+
+        G_OBJECT_CLASS(brisk_classic_entry_button_parent_class)->constructed(obj);
+}
+
+static void brisk_classic_entry_button_dispose(GObject *obj)
+{
+        G_OBJECT_CLASS(brisk_classic_entry_button_parent_class)->dispose(obj);
+}
+
+/**
+ * brisk_classic_entry_button_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_classic_entry_button_class_init(BriskClassicEntryButtonClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->constructed = brisk_classic_entry_button_constructed;
+        obj_class->dispose = brisk_classic_entry_button_dispose;
+}
+
+/**
+ * brisk_classic_entry_button_init:
+ *
+ * Handle construction of the BriskClassicEntryButton
+ */
+static void brisk_classic_entry_button_init(BriskClassicEntryButton *self)
+{
+        GtkStyleContext *style = NULL;
+        GtkWidget *label = NULL;
+        GtkWidget *image = NULL;
+        GtkWidget *layout = NULL;
+
+        /* Main layout */
+        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        /* Image on the left */
+        image = gtk_image_new();
+        self->image = image;
+        gtk_widget_set_margin_end(image, 7);
+        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
+
+        /* Display label */
+        label = gtk_label_new("");
+        gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);
+        gtk_label_set_max_width_chars(GTK_LABEL(label), 25);
+        gtk_label_set_width_chars(GTK_LABEL(label), 25);
+        self->label = label;
+        g_object_set(self->label, "halign", GTK_ALIGN_START, "valign", GTK_ALIGN_CENTER, NULL);
+        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
+        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+        gtk_misc_set_alignment(GTK_MISC(self->label), 0.0, 0.5);
+        G_GNUC_END_IGNORE_DEPRECATIONS
+
+        /* Button specific fixes */
+        gtk_button_set_relief(GTK_BUTTON(self), GTK_RELIEF_NONE);
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+
+        /* Flatten the button */
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+
+        gtk_widget_show_all(layout);
+}
+
+/**
+ * brisk_classic_entry_button_new:
+ *
+ * Return a newly created BriskClassicEntryButton
+ */
+GtkWidget *brisk_classic_entry_button_new(BriskMenuLauncher *launcher, BriskItem *item)
+{
+        return g_object_new(BRISK_TYPE_CLASSIC_ENTRY_BUTTON,
+                            "launcher",
+                            launcher,
+                            "item",
+                            item,
+                            NULL);
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/classic-entry-button.h b/src/frontend/classic/classic-entry-button.h
--- a/src/frontend/classic/classic-entry-button.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/classic-entry-button.h	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,71 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "../entry-button.h"
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskClassicEntryButton BriskClassicEntryButton;
+typedef struct _BriskClassicEntryButtonClass BriskClassicEntryButtonClass;
+
+struct _BriskClassicEntryButtonClass {
+        BriskMenuEntryButtonClass parent_class;
+};
+
+/**
+ * BriskClassicEntryButton implements support for favourites in Brisk
+ */
+struct _BriskClassicEntryButton {
+        BriskMenuEntryButton parent;
+
+        /* Basic button layout */
+        GtkWidget *label;
+        GtkWidget *image;
+};
+
+#define BRISK_TYPE_CLASSIC_ENTRY_BUTTON brisk_classic_entry_button_get_type()
+#define BRISK_CLASSIC_ENTRY_BUTTON(o)                                                              \
+        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_CLASSIC_ENTRY_BUTTON, BriskClassicEntryButton))
+#define BRISK_IS_CLASSIC_ENTRY_BUTTON(o)                                                           \
+        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_CLASSIC_ENTRY_BUTTON))
+#define BRISK_CLASSIC_ENTRY_BUTTON_CLASS(o)                                                        \
+        (G_TYPE_CHECK_CLASS_CAST((o),                                                              \
+                                 BRISK_TYPE_CLASSIC_ENTRY_BUTTON,                                  \
+                                 BriskClassicEntryButtonClass))
+#define BRISK_IS_CLASSIC_ENTRY_BUTTON_CLASS(o)                                                     \
+        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_CLASSIC_ENTRY_BUTTON))
+#define BRISK_CLASSIC_ENTRY_BUTTON_GET_CLASS(o)                                                    \
+        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
+                                   BRISK_TYPE_CLASSIC_ENTRY_BUTTON,                                \
+                                   BriskClassicEntryButtonClass))
+
+GType brisk_classic_entry_button_get_type(void);
+
+GtkWidget *brisk_classic_entry_button_new(BriskMenuLauncher *launcher, BriskItem *item);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/classic-window.c b/src/frontend/classic/classic-window.c
--- a/src/frontend/classic/classic-window.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/classic-window.c	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,826 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "styles.h"
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "../menu-private.h"
+#include "category-button.h"
+#include "classic-entry-button.h"
+#include "classic-window.h"
+#include "desktop-button.h"
+#include "sidebar-scroller.h"
+
+#include <gio/gdesktopappinfo.h>
+#include <glib/gi18n.h>
+BRISK_END_PEDANTIC
+
+G_DEFINE_TYPE(BriskClassicWindow, brisk_classic_window, BRISK_TYPE_MENU_WINDOW)
+
+static void brisk_classic_window_associate_category(BriskMenuWindow *self, GtkWidget *button);
+static void brisk_classic_window_on_toggled(BriskMenuWindow *self, GtkWidget *button);
+static gboolean brisk_classic_window_on_enter(BriskMenuWindow *self, GdkEventCrossing *event,
+                                              GtkWidget *button);
+static void brisk_classic_window_load_css(BriskClassicWindow *self);
+static void brisk_classic_window_key_activate(BriskClassicWindow *self, gpointer v);
+static void brisk_classic_window_activated(BriskMenuWindow *self, GtkListBoxRow *row, gpointer v);
+static void brisk_classic_window_setup_session_controls(BriskClassicWindow *self);
+static void brisk_classic_window_build_sidebar(BriskMenuWindow *self);
+static void brisk_classic_window_add_shortcut(BriskMenuWindow *self, const gchar *id);
+static void brisk_classic_window_set_filters_enabled(BriskClassicWindow *self, gboolean enabled);
+static gboolean brisk_classic_window_filter_apps(GtkListBoxRow *row, gpointer v);
+static gint brisk_classic_window_sort(GtkListBoxRow *row1, GtkListBoxRow *row2, gpointer v);
+
+/**
+ * brisk_classic_window_dispose:
+ *
+ * Clean up a BriskClassicWindow instance
+ */
+static void brisk_classic_window_dispose(GObject *obj)
+{
+        BriskClassicWindow *self = BRISK_CLASSIC_WINDOW(obj);
+        GdkScreen *screen = NULL;
+
+        if (self->css) {
+                screen = gtk_widget_get_screen(GTK_WIDGET(self));
+                gtk_style_context_remove_provider_for_screen(screen, GTK_STYLE_PROVIDER(self->css));
+                g_clear_object(&self->css);
+        }
+
+        G_OBJECT_CLASS(brisk_classic_window_parent_class)->dispose(obj);
+}
+
+static const gchar *brisk_classic_window_get_id(__brisk_unused__ BriskMenuWindow *window)
+{
+        return "classic";
+}
+
+static const gchar *brisk_classic_window_get_display_name(__brisk_unused__ BriskMenuWindow *window)
+{
+        return _("Classic");
+}
+
+static void brisk_classic_window_update_screen_position(BriskMenuWindow *self)
+{
+        GdkScreen *screen = NULL;
+        GtkAllocation relative_alloc = { 0 };
+        GdkWindow *window = NULL;
+        GdkRectangle geom = { 0 };
+        gint relative_x, relative_y = 0;      /* Real X, Y of the applet, on screen */
+        gint window_width, window_height = 0; /* Window width & height */
+        gint mon = 0;                         /* Monitor to display on */
+        gint window_x, window_y = 0;          /* Target X, Y */
+
+        if (!self->relative_to) {
+                g_warning("Cannot set relative location without relative widget!");
+                return;
+        }
+
+        /* Forcibly realize the applet window */
+        if (!gtk_widget_get_realized(self->relative_to)) {
+                gtk_widget_realize(self->relative_to);
+        }
+
+        /* Forcibly realize ourselves */
+        if (!gtk_widget_get_realized(GTK_WIDGET(self))) {
+                gtk_widget_realize(GTK_WIDGET(self));
+        }
+
+        gtk_widget_get_allocation(self->relative_to, &relative_alloc);
+
+        /* Find out where we are on screen */
+        window = gtk_widget_get_window(self->relative_to);
+        gdk_window_get_origin(window, &relative_x, &relative_y);
+
+        /* Find out the window size */
+        gtk_window_get_size(GTK_WINDOW(self), &window_width, &window_height);
+
+        /* Grab the geometry for the monitor we're currently on */
+        screen = gtk_widget_get_screen(self->relative_to);
+        mon = gdk_screen_get_monitor_at_point(screen, relative_x, relative_y);
+        gdk_screen_get_monitor_geometry(screen, mon, &geom);
+
+        switch (self->position) {
+        case GTK_POS_LEFT:
+                /* Left vertical panel, appear to the RHS of it */
+                window_x = relative_x + relative_alloc.width;
+                window_y = relative_y;
+                break;
+        case GTK_POS_RIGHT:
+                /* Right vertical panel, appear to the LHS of it */
+                window_x = relative_x - window_width;
+                window_y = relative_y;
+                break;
+        case GTK_POS_TOP:
+                /* Top panel, appear below it */
+                window_x = relative_x;
+                window_y = relative_y + relative_alloc.height;
+                break;
+        case GTK_POS_BOTTOM:
+        default:
+                /* Bottom panel, appear above it */
+                window_x = relative_x;
+                window_y = relative_y - window_height;
+                break;
+        }
+
+        /* Bound the right side */
+        if (window_x + window_width > (geom.x + geom.width)) {
+                window_x = (geom.x + geom.width) - window_width;
+                if (self->position == GTK_POS_RIGHT) {
+                        window_x -= relative_alloc.width;
+                }
+        }
+
+        /* Bound the left side */
+        if (window_x < geom.x) {
+                window_x = geom.x;
+                if (self->position == GTK_POS_LEFT) {
+                        window_x -= relative_alloc.width;
+                }
+        }
+
+        gtk_window_move(GTK_WINDOW(self), window_x, window_y);
+}
+
+/**
+ * Update the position of the search bar in accordance with settings
+ */
+static void brisk_classic_window_update_search(BriskMenuWindow *self)
+{
+        SearchPosition search_position = self->search_position;
+        GtkWidget *layout = NULL;
+        gint n_pos = 0;
+
+        layout = gtk_bin_get_child(GTK_BIN(self));
+
+        if (search_position < SEARCH_POS_MIN || search_position >= SEARCH_POS_MAX) {
+                search_position = SEARCH_POS_AUTOMATIC;
+        }
+
+        switch (search_position) {
+        case SEARCH_POS_AUTOMATIC:
+                /* Top panel, bottom search. Bottom panel, top search */
+                n_pos = self->position == GTK_POS_TOP ? 1 : 0;
+                break;
+        case SEARCH_POS_TOP:
+                n_pos = 0;
+                break;
+        case SEARCH_POS_BOTTOM:
+        default:
+                n_pos = 1;
+                break;
+        }
+
+        gtk_container_child_set(GTK_CONTAINER(layout), self->search, "position", n_pos, NULL);
+}
+
+/**
+ * Backend has new items for us, add to the global store
+ */
+static void brisk_classic_window_add_item(BriskMenuWindow *self, BriskItem *item,
+                                          __brisk_unused__ BriskBackend *backend)
+{
+        GtkWidget *button = NULL;
+        const gchar *item_id = brisk_item_get_id(item);
+
+        button = brisk_classic_entry_button_new(self->launcher, item);
+        g_signal_connect_swapped(button,
+                                 "show-context-menu",
+                                 G_CALLBACK(brisk_menu_window_show_context),
+                                 self);
+        gtk_container_add(GTK_CONTAINER(BRISK_CLASSIC_WINDOW(self)->apps), button);
+        gtk_widget_show_all(button);
+
+        g_hash_table_insert(self->item_store, g_strdup(item_id), button);
+}
+
+/**
+ * Backend has a new sidebar section for us
+ */
+static void brisk_classic_window_add_section(BriskMenuWindow *self, BriskSection *section,
+                                             __brisk_unused__ BriskBackend *backend)
+{
+        GtkWidget *button = NULL;
+        const gchar *section_id = brisk_section_get_id(section);
+        GtkWidget *box_target = NULL;
+
+        /* Skip dupes. Sections are uniquely namespaced */
+        if (g_hash_table_lookup(self->item_store, section_id) != NULL) {
+                return;
+        }
+
+        box_target = brisk_menu_window_get_section_box(self, backend);
+
+        button = brisk_classic_category_button_new(section);
+        gtk_radio_button_join_group(GTK_RADIO_BUTTON(button),
+                                    GTK_RADIO_BUTTON(self->section_box_leader));
+        gtk_box_pack_start(GTK_BOX(box_target), button, FALSE, FALSE, 0);
+        brisk_classic_window_associate_category(self, button);
+        gtk_widget_show_all(button);
+
+        /* Avoid new dupes */
+        g_hash_table_insert(self->item_store, g_strdup(section_id), button);
+
+        brisk_menu_window_select_sections(self);
+}
+
+/**
+ * A backend needs us to invalidate the filters
+ */
+static void brisk_classic_window_invalidate_filter(BriskMenuWindow *self,
+                                                   __brisk_unused__ BriskBackend *backend)
+{
+        gtk_list_box_invalidate_filter(GTK_LIST_BOX(BRISK_CLASSIC_WINDOW(self)->apps));
+        gtk_list_box_invalidate_sort(GTK_LIST_BOX(BRISK_CLASSIC_WINDOW(self)->apps));
+}
+
+/**
+ * A backend needs us to purge any data we have for it
+ */
+static void brisk_classic_window_reset(BriskMenuWindow *self, BriskBackend *backend)
+{
+        GtkWidget *box_target = NULL;
+        GList *kids = NULL, *elem = NULL;
+        const gchar *backend_id = NULL;
+
+        backend_id = brisk_backend_get_id(backend);
+
+        box_target = brisk_menu_window_get_section_box(self, backend);
+        gtk_container_foreach(GTK_CONTAINER(box_target),
+                              (GtkCallback)brisk_menu_window_remove_category,
+                              self);
+
+        /* Manual work for the items */
+        kids = gtk_container_get_children(GTK_CONTAINER(BRISK_CLASSIC_WINDOW(self)->apps));
+        for (elem = kids; elem; elem = elem->next) {
+                GtkWidget *row = elem->data;
+                GtkWidget *child = NULL;
+                BriskItem *item = NULL;
+                const gchar *local_backend_id = NULL;
+                const gchar *local_id = NULL;
+
+                if (!GTK_IS_BIN(GTK_BIN(row))) {
+                        continue;
+                }
+
+                child = gtk_bin_get_child(GTK_BIN(row));
+                if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {
+                        continue;
+                }
+
+                g_object_get(child, "item", &item, NULL);
+                if (!item) {
+                        g_warning("missing item for entry in backend '%s'", backend_id);
+                        continue;
+                }
+
+                local_backend_id = brisk_item_get_backend_id(item);
+                if (!g_str_equal(backend_id, local_backend_id)) {
+                        continue;
+                }
+                local_id = brisk_item_get_id(item);
+                g_hash_table_remove(self->item_store, local_id);
+                gtk_widget_destroy(row);
+        }
+        g_list_free(kids);
+}
+
+/**
+ * Override hiding so that we can invalidate all filters
+ */
+static void brisk_classic_window_hide(GtkWidget *widget)
+{
+        BriskClassicWindow *self = NULL;
+        GtkAdjustment *adjustment = NULL;
+
+        /* Have parent deal with it first */
+        GTK_WIDGET_CLASS(brisk_classic_window_parent_class)->hide(widget);
+
+        self = BRISK_CLASSIC_WINDOW(widget);
+
+        /* Remove search filter */
+        gtk_entry_set_text(GTK_ENTRY(BRISK_MENU_WINDOW(self)->search), "");
+
+        brisk_menu_window_select_sections(BRISK_MENU_WINDOW(self));
+
+        /* Reset scrollbars */
+        adjustment = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->apps_scroll));
+        gtk_adjustment_set_value(adjustment, 0);
+        adjustment = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->sidebar_scroll));
+        gtk_adjustment_set_value(adjustment, 0);
+
+        /* Unselect any current "apps" */
+        gtk_list_box_select_row(GTK_LIST_BOX(self->apps), NULL);
+}
+
+/**
+ * brisk_classic_window_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_classic_window_class_init(BriskClassicWindowClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+        BriskMenuWindowClass *b_class = BRISK_MENU_WINDOW_CLASS(klazz);
+        GtkWidgetClass *wid_class = GTK_WIDGET_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->dispose = brisk_classic_window_dispose;
+
+        /* Window vtable hookup */
+        b_class->get_id = brisk_classic_window_get_id;
+        b_class->get_display_name = brisk_classic_window_get_display_name;
+        b_class->update_screen_position = brisk_classic_window_update_screen_position;
+        b_class->update_search = brisk_classic_window_update_search;
+        b_class->add_item = brisk_classic_window_add_item;
+        b_class->add_section = brisk_classic_window_add_section;
+        b_class->invalidate_filter = brisk_classic_window_invalidate_filter;
+        b_class->reset = brisk_classic_window_reset;
+
+        /* widget vtable */
+        wid_class->hide = brisk_classic_window_hide;
+}
+
+/**
+ * brisk_classic_window_init:
+ *
+ * Handle construction of the BriskClassicWindow
+ */
+static void brisk_classic_window_init(BriskClassicWindow *self)
+{
+        GtkWidget *layout = NULL;
+        GtkWidget *widget = NULL;
+        GtkWidget *content = NULL;
+        GtkWidget *scroll = NULL;
+        GtkStyleContext *style = NULL;
+        BriskMenuWindow *base;
+        autofree(gchar) *txt_holder = NULL;
+        autofree(gchar) *place_holder = NULL;
+
+        brisk_classic_window_load_css(self);
+
+        base = BRISK_MENU_WINDOW(self);
+
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, BRISK_STYLE_MAIN);
+
+        brisk_menu_window_configure_grabs(base);
+
+        layout = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        /* Create search entry - but not GtkSearchEntry to avoid rounding in themes */
+        widget = gtk_entry_new();
+        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),
+                                          GTK_ENTRY_ICON_PRIMARY,
+                                          "edit-find-symbolic");
+        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),
+                                          GTK_ENTRY_ICON_SECONDARY,
+                                          "edit-clear-symbolic");
+
+        gtk_box_pack_start(GTK_BOX(layout), widget, FALSE, FALSE, 0);
+        /* Translators: This is the text shown in the "search box" with no content */
+        txt_holder = g_strdup_printf("%s\u2026", _("Type to search"));
+        gtk_entry_set_placeholder_text(GTK_ENTRY(widget), txt_holder);
+        base->search = widget;
+        g_signal_connect_swapped(widget, "changed", G_CALLBACK(brisk_menu_window_search), self);
+        g_signal_connect_swapped(widget,
+                                 "activate",
+                                 G_CALLBACK(brisk_classic_window_key_activate),
+                                 self);
+        g_signal_connect(widget, "icon-press", G_CALLBACK(brisk_menu_window_clear_search), self);
+
+        /* Content layout */
+        content = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
+        gtk_box_pack_start(GTK_BOX(layout), content, TRUE, TRUE, 0);
+
+        /* Sidebar for categories */
+        widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+        scroll = brisk_menu_sidebar_scroller_new();
+        base->section_box_holder = widget;
+        style = gtk_widget_get_style_context(base->section_box_holder);
+        gtk_style_context_add_class(style, BRISK_STYLE_SIDEBAR);
+        self->sidebar_scroll = scroll;
+        gtk_container_add(GTK_CONTAINER(scroll), widget);
+
+        /* Create a wrapper for the categories */
+        widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+        gtk_box_pack_start(GTK_BOX(widget), scroll, TRUE, TRUE, 0);
+        gtk_box_pack_start(GTK_BOX(content), widget, TRUE, TRUE, 0);
+        self->sidebar_wrap = widget;
+
+        /* Scrollbar for apps */
+        scroll = gtk_scrolled_window_new(NULL, NULL);
+        gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scroll), GTK_SHADOW_IN);
+        gtk_box_pack_start(GTK_BOX(content), scroll, TRUE, TRUE, 0);
+        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
+                                       GTK_POLICY_NEVER,
+                                       GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(scroll), FALSE);
+        self->apps_scroll = scroll;
+
+        /* Application launcher display */
+        widget = gtk_list_box_new();
+        gtk_container_add(GTK_CONTAINER(scroll), widget);
+        self->apps = widget;
+        gtk_list_box_set_activate_on_single_click(GTK_LIST_BOX(self->apps), TRUE);
+        gtk_list_box_set_selection_mode(GTK_LIST_BOX(self->apps), GTK_SELECTION_SINGLE);
+        g_signal_connect_swapped(self->apps,
+                                 "row-activated",
+                                 G_CALLBACK(brisk_classic_window_activated),
+                                 self);
+
+        /* Style up the app box */
+        style = gtk_widget_get_style_context(widget);
+        gtk_style_context_add_class(style, BRISK_STYLE_APPS_LIST);
+        gtk_style_context_add_class(style, "view");
+        gtk_style_context_add_class(style, "content-view");
+        gtk_style_context_remove_class(style, "background");
+
+        /* Translators: This message is shown when the search results are empty */
+        place_holder = g_strdup_printf("<big>%s</big>", _("Sorry, no items found"));
+        widget = gtk_label_new(place_holder);
+        /* Add a placeholder when there are no apps for current search term */
+        gtk_label_set_use_markup(GTK_LABEL(widget), TRUE);
+        g_object_set(widget,
+                     "halign",
+                     GTK_ALIGN_CENTER,
+                     "valign",
+                     GTK_ALIGN_START,
+                     "margin",
+                     6,
+                     NULL);
+        style = gtk_widget_get_style_context(widget);
+        gtk_style_context_add_class(style, "dim-label");
+        gtk_list_box_set_placeholder(GTK_LIST_BOX(self->apps), widget);
+        gtk_widget_show_all(widget);
+
+        brisk_classic_window_setup_session_controls(self);
+
+        gtk_window_set_default_size(GTK_WINDOW(self), 300, 510);
+
+        /* Hook up keyboard events */
+        g_signal_connect(self,
+                         "key-release-event",
+                         G_CALLBACK(brisk_menu_window_key_release),
+                         NULL);
+        g_signal_connect(self, "key-press-event", G_CALLBACK(brisk_menu_window_key_press), NULL);
+
+        brisk_classic_window_build_sidebar(base);
+
+        brisk_menu_window_init_backends(base);
+
+        /* Hook up dbus later on */
+        g_idle_add((GSourceFunc)brisk_menu_window_setup_session, self);
+
+        gtk_widget_show_all(layout);
+}
+
+/*
+ * brisk_classic_window_new:
+ *
+ * Return a newly created BriskClassicWindow
+ */
+BriskMenuWindow *brisk_classic_window_new(GtkWidget *relative_to)
+{
+        return g_object_new(BRISK_TYPE_CLASSIC_WINDOW,
+                            "type",
+                            GTK_WINDOW_POPUP,
+                            "relative-to",
+                            relative_to,
+                            NULL);
+}
+
+/**
+ * brisk_classic_window_associate_category:
+ *
+ * This will hook up the category button for events to enable us to filter the
+ * list based on the active category.
+ */
+static void brisk_classic_window_associate_category(BriskMenuWindow *self, GtkWidget *button)
+{
+        g_signal_connect_swapped(button,
+                                 "toggled",
+                                 G_CALLBACK(brisk_classic_window_on_toggled),
+                                 self);
+        g_signal_connect_swapped(button,
+                                 "enter-notify-event",
+                                 G_CALLBACK(brisk_classic_window_on_enter),
+                                 self);
+}
+
+/**
+ * Fired by clicking a category button
+ */
+static void brisk_classic_window_on_toggled(BriskMenuWindow *self, GtkWidget *button)
+{
+        BriskClassicCategoryButton *cat = NULL;
+
+        /* Skip a double signal due to using a group */
+        if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button))) {
+                return;
+        }
+
+        cat = BRISK_CLASSIC_CATEGORY_BUTTON(button);
+        g_object_get(cat, "section", &self->active_section, NULL);
+
+        /* Start the filter. */
+        brisk_classic_window_invalidate_filter(self, NULL);
+}
+
+/**
+ * Fired by entering into the category button with a roll over
+ */
+static gboolean brisk_classic_window_on_enter(BriskMenuWindow *self,
+                                              __brisk_unused__ GdkEventCrossing *event,
+                                              GtkWidget *button)
+{
+        GtkToggleButton *but = GTK_TOGGLE_BUTTON(button);
+
+        /* Whether we're in rollover mode */
+        if (!self->rollover) {
+                return GDK_EVENT_PROPAGATE;
+        }
+
+        if (gtk_toggle_button_get_active(but) || !gtk_widget_get_visible(button)) {
+                return GDK_EVENT_PROPAGATE;
+        }
+
+        /* Force activation through rollover */
+        gtk_toggle_button_set_active(but, TRUE);
+
+        return GDK_EVENT_PROPAGATE;
+}
+
+/**
+ * Load up the CSS assets
+ */
+static void brisk_classic_window_load_css(BriskClassicWindow *self)
+{
+        GtkCssProvider *css = NULL;
+        autofree(GFile) *file = NULL;
+        autofree(GError) *err = NULL;
+        GdkScreen *screen = NULL;
+
+        file = g_file_new_for_uri("resource://com/solus-project/brisk/menu/classic/styling.css");
+        if (!file) {
+                return;
+        }
+
+        css = gtk_css_provider_new();
+        self->css = css;
+        screen = gtk_widget_get_screen(GTK_WIDGET(self));
+        gtk_style_context_add_provider_for_screen(screen,
+                                                  GTK_STYLE_PROVIDER(css),
+                                                  GTK_STYLE_PROVIDER_PRIORITY_FALLBACK);
+
+        if (!gtk_css_provider_load_from_file(css, file, &err)) {
+                g_warning("Failed to load CSS: %s\n", err->message);
+                return;
+        }
+}
+
+static void brisk_classic_window_key_activate(BriskClassicWindow *self, __brisk_unused__ gpointer v)
+{
+        autofree(GList) *kids = NULL;
+        GList *elem = NULL;
+        BriskMenuEntryButton *button = NULL;
+
+        kids = gtk_container_get_children(GTK_CONTAINER(self->apps));
+
+        for (elem = kids; elem; elem = elem->next) {
+                GtkWidget *widget = elem->data;
+
+                if (!gtk_widget_get_visible(widget) || !gtk_widget_get_child_visible(widget)) {
+                        continue;
+                }
+
+                button = BRISK_MENU_ENTRY_BUTTON(gtk_bin_get_child(GTK_BIN(widget)));
+                break;
+        }
+        if (!button) {
+                return;
+        }
+        brisk_menu_entry_button_launch(button);
+}
+
+static void brisk_classic_window_activated(__brisk_unused__ BriskMenuWindow *self,
+                                           GtkListBoxRow *row, __brisk_unused__ gpointer v)
+{
+        BriskMenuEntryButton *button = NULL;
+        GtkWidget *child = NULL;
+
+        child = gtk_bin_get_child(GTK_BIN(row));
+        if (!child) {
+                return;
+        }
+        if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {
+                return;
+        }
+        button = BRISK_MENU_ENTRY_BUTTON(child);
+        brisk_menu_entry_button_launch(button);
+}
+
+/**
+ * Create the graphical buttons for session control
+ */
+static void brisk_classic_window_setup_session_controls(BriskClassicWindow *self)
+{
+        GtkWidget *widget = NULL;
+        GtkWidget *box = NULL;
+        GtkStyleContext *style = NULL;
+
+        box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_widget_set_margin_bottom(box, 4);
+
+        gtk_box_pack_end(GTK_BOX(self->sidebar_wrap), box, FALSE, FALSE, 0);
+        gtk_widget_set_halign(box, GTK_ALIGN_CENTER);
+
+        /* Add a separator for visual consistency */
+        widget = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
+        gtk_box_pack_end(GTK_BOX(self->sidebar_wrap), widget, FALSE, FALSE, 3);
+
+        /* Logout */
+        widget = gtk_button_new_from_icon_name("brisk_system-log-out-symbolic", GTK_ICON_SIZE_MENU);
+        self->button_logout = widget;
+        g_signal_connect_swapped(widget, "clicked", G_CALLBACK(brisk_menu_window_logout), self);
+        gtk_widget_set_tooltip_text(widget, _("End the current session"));
+        gtk_widget_set_can_focus(widget, FALSE);
+        gtk_container_add(GTK_CONTAINER(box), widget);
+        style = gtk_widget_get_style_context(widget);
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+        gtk_style_context_add_class(style, "session-button");
+
+        /* Lock */
+        widget = gtk_button_new_from_icon_name("system-lock-screen-symbolic",
+                                               GTK_ICON_SIZE_SMALL_TOOLBAR);
+        self->button_lock = widget;
+        g_signal_connect_swapped(widget, "clicked", G_CALLBACK(brisk_menu_window_lock), self);
+        gtk_widget_set_tooltip_text(widget, _("Lock the screen"));
+        gtk_widget_set_can_focus(widget, FALSE);
+        gtk_container_add(GTK_CONTAINER(box), widget);
+        style = gtk_widget_get_style_context(widget);
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+        gtk_style_context_add_class(style, "session-button");
+
+        /* Shutdown */
+        widget =
+            gtk_button_new_from_icon_name("system-shutdown-symbolic", GTK_ICON_SIZE_SMALL_TOOLBAR);
+        self->button_shutdown = widget;
+        g_signal_connect_swapped(widget, "clicked", G_CALLBACK(brisk_menu_window_shutdown), self);
+        gtk_widget_set_tooltip_text(widget, _("Turn off the device"));
+        gtk_widget_set_can_focus(widget, FALSE);
+        gtk_container_add(GTK_CONTAINER(box), widget);
+        style = gtk_widget_get_style_context(widget);
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+        gtk_style_context_add_class(style, "session-button");
+}
+
+/**
+ * Begin a build of the menu structure
+ */
+static void brisk_classic_window_build_sidebar(BriskMenuWindow *self)
+{
+        GtkWidget *sep = NULL;
+        autofree(gstrv) *shortcuts = NULL;
+
+        brisk_classic_window_set_filters_enabled(BRISK_CLASSIC_WINDOW(self), FALSE);
+
+        /* Special leader to control group association, hidden from view */
+        self->section_box_leader = gtk_radio_button_new(NULL);
+        gtk_box_pack_start(GTK_BOX(self->section_box_holder),
+                           self->section_box_leader,
+                           FALSE,
+                           FALSE,
+                           0);
+        gtk_widget_set_no_show_all(self->section_box_leader, TRUE);
+        gtk_widget_hide(self->section_box_leader);
+
+        /* Separate the things */
+        sep = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
+        gtk_box_pack_start(GTK_BOX(self->section_box_holder), sep, FALSE, FALSE, 5);
+        gtk_widget_show_all(sep);
+
+        /* Load the shortcuts up */
+        shortcuts = g_settings_get_strv(self->settings, "pinned-shortcuts");
+        if (!shortcuts) {
+                return;
+        }
+
+        /* Add from gsettings */
+        for (guint i = 0; i < g_strv_length(shortcuts); i++) {
+                brisk_classic_window_add_shortcut(self, shortcuts[i]);
+        }
+
+        brisk_classic_window_set_filters_enabled(BRISK_CLASSIC_WINDOW(self), TRUE);
+}
+
+/**
+ * brisk_classic_window_add_shortcut
+ *
+ * If we can create a .desktop launcher for the given name, add a new button to
+ * the sidebar as a quick launch facility.
+ */
+static void brisk_classic_window_add_shortcut(BriskMenuWindow *self, const gchar *id)
+{
+        GDesktopAppInfo *info = NULL;
+        GtkWidget *button = NULL;
+
+        info = g_desktop_app_info_new(id);
+        if (!info) {
+                g_message("Not adding missing %s to BriskMenu", id);
+                return;
+        }
+
+        button = brisk_menu_desktop_button_new(self->launcher, G_APP_INFO(info));
+        gtk_widget_show_all(button);
+        gtk_box_pack_start(GTK_BOX(self->section_box_holder), button, FALSE, FALSE, 1);
+}
+
+/**
+ * Enable or disable the filters between building of the menus
+ */
+static void brisk_classic_window_set_filters_enabled(BriskClassicWindow *self, gboolean enabled)
+{
+        BRISK_MENU_WINDOW(self)->filtering = enabled;
+        if (enabled) {
+                gtk_list_box_set_filter_func(GTK_LIST_BOX(self->apps),
+                                             brisk_classic_window_filter_apps,
+                                             self,
+                                             NULL);
+                gtk_list_box_set_sort_func(GTK_LIST_BOX(self->apps),
+                                           brisk_classic_window_sort,
+                                           self,
+                                           NULL);
+                return;
+        }
+        gtk_list_box_set_filter_func(GTK_LIST_BOX(self->apps), NULL, NULL, NULL);
+        gtk_list_box_set_sort_func(GTK_LIST_BOX(self->apps), NULL, NULL, NULL);
+}
+
+/**
+ * brisk_classic_window_filter_apps:
+ *
+ * Responsible for filtering the selection based on active group or search
+ * term.
+ */
+__brisk_pure__ static gboolean brisk_classic_window_filter_apps(GtkListBoxRow *row, gpointer v)
+{
+        BriskMenuWindow *self = NULL;
+        GtkWidget *child = NULL;
+
+        self = BRISK_MENU_WINDOW(v);
+
+        if (!self->filtering) {
+                return FALSE;
+        }
+
+        /* Grab our Entry widget */
+        child = gtk_bin_get_child(GTK_BIN(row));
+
+        return brisk_menu_window_filter_apps(self, child);
+}
+
+static gint brisk_classic_window_sort(GtkListBoxRow *row1, GtkListBoxRow *row2, gpointer v)
+{
+        GtkWidget *child1, *child2 = NULL;
+        BriskItem *itemA, *itemB = NULL;
+        autofree(gchar) *nameA = NULL;
+        autofree(gchar) *nameB = NULL;
+        BriskMenuWindow *self = NULL;
+
+        self = BRISK_MENU_WINDOW(v);
+
+        child1 = gtk_bin_get_child(GTK_BIN(row1));
+        child2 = gtk_bin_get_child(GTK_BIN(row2));
+
+        g_object_get(child1, "item", &itemA, NULL);
+        g_object_get(child2, "item", &itemB, NULL);
+
+        return brisk_menu_window_sort(self, itemA, itemB);
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/classic-window.h b/src/frontend/classic/classic-window.h
--- a/src/frontend/classic/classic-window.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/classic-window.h	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,81 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "../menu-private.h"
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskClassicWindow BriskClassicWindow;
+typedef struct _BriskClassicWindowClass BriskClassicWindowClass;
+
+struct _BriskClassicWindowClass {
+        BriskMenuWindowClass parent_class;
+};
+
+/**
+ * BriskClassicWindow implements support for favourites in Brisk
+ */
+struct _BriskClassicWindow {
+        BriskMenuWindow parent;
+
+        GtkWidget *relative_to;
+
+        /* Categories */
+        GtkWidget *sidebar_scroll;
+
+        /* VBox for the sidebar container */
+        GtkWidget *sidebar_wrap;
+
+        /* Actual applications */
+        GtkWidget *apps;
+        GtkWidget *apps_scroll;
+
+        /* CSS Provider */
+        GtkCssProvider *css;
+
+        /* Session management buttons */
+        GtkWidget *button_lock;
+        GtkWidget *button_logout;
+        GtkWidget *button_shutdown;
+};
+
+#define BRISK_TYPE_CLASSIC_WINDOW brisk_classic_window_get_type()
+#define BRISK_CLASSIC_WINDOW(o)                                                                    \
+        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_CLASSIC_WINDOW, BriskClassicWindow))
+#define BRISK_IS_CLASSIC_WINDOW(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_CLASSIC_WINDOW))
+#define BRISK_CLASSIC_WINDOW_CLASS(o)                                                              \
+        (G_TYPE_CHECK_CLASS_CAST((o), BRISK_TYPE_CLASSIC_WINDOW, BriskClassicWindowClass))
+#define BRISK_IS_CLASSIC_WINDOW_CLASS(o) (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_CLASSIC_WINDOW))
+#define BRISK_CLASSIC_WINDOW_GET_CLASS(o)                                                          \
+        (G_TYPE_INSTANCE_GET_CLASS((o), BRISK_TYPE_CLASSIC_WINDOW, BriskClassicWindowClass))
+
+GType brisk_classic_window_get_type(void);
+
+BriskMenuWindow *brisk_classic_window_new(GtkWidget *relative_to);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/desktop-button.c b/src/frontend/classic/desktop-button.c
--- a/src/frontend/classic/desktop-button.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/desktop-button.c	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,221 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2016-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "desktop-button.h"
+#include "menu-private.h"
+#include <gtk/gtk.h>
+BRISK_END_PEDANTIC
+
+struct _BriskMenuDesktopButtonClass {
+        GtkButtonClass parent_class;
+};
+
+/**
+ * BriskMenuDesktopButton is the toplevel window type used within the applet.
+ */
+struct _BriskMenuDesktopButton {
+        GtkButton parent;
+        GAppInfo *desktop;
+        GtkWidget *label;
+        GtkWidget *image;
+        BriskMenuLauncher *launcher;
+};
+
+G_DEFINE_TYPE(BriskMenuDesktopButton, brisk_menu_desktop_button, GTK_TYPE_BUTTON)
+
+static void brisk_menu_desktop_button_clicked(GtkButton *button);
+
+enum { PROP_DESKTOP = 1, PROP_LAUNCHER, N_PROPS };
+
+static GParamSpec *obj_properties[N_PROPS] = {
+        NULL,
+};
+
+static void brisk_menu_desktop_button_set_property(GObject *object, guint id, const GValue *value,
+                                                   GParamSpec *spec)
+{
+        BriskMenuDesktopButton *self = BRISK_MENU_DESKTOP_BUTTON(object);
+
+        switch (id) {
+        case PROP_DESKTOP:
+                self->desktop = g_value_get_pointer(value);
+                break;
+        case PROP_LAUNCHER:
+                self->launcher = g_value_get_pointer(value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
+        }
+}
+
+static void brisk_menu_desktop_button_get_property(GObject *object, guint id, GValue *value,
+                                                   GParamSpec *spec)
+{
+        BriskMenuDesktopButton *self = BRISK_MENU_DESKTOP_BUTTON(object);
+
+        switch (id) {
+        case PROP_DESKTOP:
+                g_value_set_pointer(value, self->desktop);
+                break;
+        case PROP_LAUNCHER:
+                g_value_set_pointer(value, self->launcher);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
+        }
+}
+
+/**
+ * brisk_menu_desktop_button_new:
+ *
+ * Construct a new BriskMenuDesktopButton object
+ */
+GtkWidget *brisk_menu_desktop_button_new(BriskMenuLauncher *launcher, GAppInfo *desktop)
+{
+        return g_object_new(BRISK_TYPE_MENU_DESKTOP_BUTTON,
+                            "launcher",
+                            launcher,
+                            "desktop",
+                            desktop,
+                            NULL);
+}
+
+/**
+ * brisk_menu_desktop_button_dispose:
+ *
+ * Clean up a BriskMenuDesktopButton instance
+ */
+static void brisk_menu_desktop_button_dispose(GObject *obj)
+{
+        BriskMenuDesktopButton *self = NULL;
+
+        self = BRISK_MENU_DESKTOP_BUTTON(obj);
+        g_clear_object(&self->desktop);
+
+        G_OBJECT_CLASS(brisk_menu_desktop_button_parent_class)->dispose(obj);
+}
+
+/**
+ * Handle constructor specifics for our button
+ */
+static void brisk_menu_desktop_button_constructed(GObject *obj)
+{
+        const gchar *label = NULL;
+        BriskMenuDesktopButton *self = NULL;
+
+        self = BRISK_MENU_DESKTOP_BUTTON(obj);
+
+        gtk_image_set_from_gicon(GTK_IMAGE(self->image),
+                                 g_app_info_get_icon(self->desktop),
+                                 GTK_ICON_SIZE_BUTTON);
+        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 16);
+
+        /* Determine our label based on the app */
+        label = g_app_info_get_display_name(self->desktop);
+        gtk_label_set_label(GTK_LABEL(self->label), label);
+        gtk_widget_set_tooltip_text(GTK_WIDGET(self), g_app_info_get_description(self->desktop));
+
+        G_OBJECT_CLASS(brisk_menu_desktop_button_parent_class)->constructed(obj);
+}
+
+/**
+ * brisk_menu_desktop_button_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_menu_desktop_button_class_init(BriskMenuDesktopButtonClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+        GtkButtonClass *but_class = GTK_BUTTON_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->dispose = brisk_menu_desktop_button_dispose;
+        obj_class->set_property = brisk_menu_desktop_button_set_property;
+        obj_class->get_property = brisk_menu_desktop_button_get_property;
+        obj_class->constructed = brisk_menu_desktop_button_constructed;
+
+        /* button vtable hookup */
+        but_class->clicked = brisk_menu_desktop_button_clicked;
+
+        obj_properties[PROP_DESKTOP] = g_param_spec_pointer("desktop",
+                                                            "The GAppInfo",
+                                                            "Desktop file",
+                                                            G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
+        obj_properties[PROP_LAUNCHER] = g_param_spec_pointer("launcher",
+                                                             "The Brisk Launcher",
+                                                             "Launcher used for starting apps",
+                                                             G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
+        g_object_class_install_properties(obj_class, N_PROPS, obj_properties);
+}
+
+/**
+ * brisk_menu_desktop_button_init:
+ *
+ * Handle construction of the BriskMenuDesktopButton
+ */
+static void brisk_menu_desktop_button_init(BriskMenuDesktopButton *self)
+{
+        GtkStyleContext *style = NULL;
+        GtkWidget *label = NULL;
+        GtkWidget *image = NULL;
+        GtkWidget *layout = NULL;
+
+        /* Main layout */
+        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        /* Image on the left */
+        image = gtk_image_new();
+        self->image = image;
+        gtk_widget_set_margin_end(image, 7);
+        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
+
+        /* Display label */
+        label = gtk_label_new("");
+        self->label = label;
+        g_object_set(self->label, "halign", GTK_ALIGN_START, "valign", GTK_ALIGN_CENTER, NULL);
+        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
+
+        /* Button specific fixes */
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+        gtk_button_set_relief(GTK_BUTTON(self), GTK_RELIEF_NONE);
+
+        /* Flatten the button */
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+}
+
+static void brisk_menu_desktop_button_clicked(GtkButton *button)
+{
+        BriskMenuDesktopButton *self = NULL;
+
+        self = BRISK_MENU_DESKTOP_BUTTON(button);
+        brisk_menu_launcher_start(self->launcher, GTK_WIDGET(self), self->desktop);
+}
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/desktop-button.h b/src/frontend/classic/desktop-button.h
--- a/src/frontend/classic/desktop-button.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/desktop-button.h	2019-11-25 14:46:11.090939095 +0100
@@ -0,0 +1,59 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2016-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+#include <matemenu-tree.h>
+
+#include "launcher.h"
+
+G_BEGIN_DECLS
+
+typedef struct _BriskMenuDesktopButton BriskMenuDesktopButton;
+typedef struct _BriskMenuDesktopButtonClass BriskMenuDesktopButtonClass;
+
+#define BRISK_TYPE_MENU_DESKTOP_BUTTON brisk_menu_desktop_button_get_type()
+#define BRISK_MENU_DESKTOP_BUTTON(o)                                                               \
+        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_MENU_DESKTOP_BUTTON, BriskMenuDesktopButton))
+#define BRISK_IS_MENU_DESKTOP_BUTTON(o)                                                            \
+        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_MENU_DESKTOP_BUTTON))
+#define BRISK_MENU_DESKTOP_BUTTON_CLASS(o)                                                         \
+        (G_TYPE_CHECK_CLASS_CAST((o), BRISK_TYPE_MENU_DESKTOP_BUTTON, BriskMenuDesktopButtonClass))
+#define BRISK_IS_MENU_DESKTOP_BUTTON_CLASS(o)                                                      \
+        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_MENU_DESKTOP_BUTTON))
+#define BRISK_MENU_DESKTOP_BUTTON_GET_CLASS(o)                                                     \
+        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
+                                   BRISK_TYPE_MENU_DESKTOP_BUTTON,                                 \
+                                   BriskMenuDesktopButtonClass))
+
+/**
+ * Construct a new BriskMenuDesktopButton from the given desktop entry
+ */
+GtkWidget *brisk_menu_desktop_button_new(BriskMenuLauncher *launcher, GAppInfo *desktop);
+
+GType brisk_menu_desktop_button_get_type(void);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/sidebar-scroller.c b/src/frontend/classic/sidebar-scroller.c
--- a/src/frontend/classic/sidebar-scroller.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/sidebar-scroller.c	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,120 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "sidebar-scroller.h"
+#include <gtk/gtk.h>
+
+BRISK_END_PEDANTIC
+
+struct _BriskMenuSidebarScrollerClass {
+        GtkScrolledWindowClass parent_class;
+};
+
+struct _BriskMenuSidebarScroller {
+        GtkScrolledWindow parent;
+};
+
+G_DEFINE_TYPE(BriskMenuSidebarScroller, brisk_menu_sidebar_scroller, GTK_TYPE_SCROLLED_WINDOW)
+
+static void brisk_menu_sidebar_scroller_get_preferred_height(GtkWidget *widget, gint *min_height,
+                                                             gint *nat_height);
+
+/**
+ * brisk_menu_sidebar_scroller_new:
+ *
+ * Construct a new BriskMenuSidebarScroller object
+ */
+GtkWidget *brisk_menu_sidebar_scroller_new()
+{
+        return g_object_new(BRISK_TYPE_MENU_SIDEBAR_SCROLLER,
+                            "hadjustment",
+                            NULL,
+                            "vadjustment",
+                            NULL,
+                            NULL);
+}
+
+/**
+ * brisk_menu_sidebar_scroller_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_menu_sidebar_scroller_class_init(BriskMenuSidebarScrollerClass *klazz)
+{
+        GtkWidgetClass *wid_class = GTK_WIDGET_CLASS(klazz);
+        wid_class->get_preferred_height = brisk_menu_sidebar_scroller_get_preferred_height;
+}
+
+/**
+ * brisk_menu_sidebar_scroller_init:
+ *
+ * Handle construction of the BriskMenuEntryButton
+ */
+static void brisk_menu_sidebar_scroller_init(BriskMenuSidebarScroller *self)
+{
+        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(self),
+                                       GTK_POLICY_NEVER,
+                                       GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(self), FALSE);
+}
+
+static void brisk_menu_sidebar_scroller_get_preferred_height(GtkWidget *widget, gint *min_height,
+                                                             gint *nat_height)
+{
+        GdkScreen *screen = NULL;
+        GdkWindow *window = NULL;
+        GdkRectangle geom = { 0 };
+        gint applet_x, applet_y = 0;
+        gint mon = 0;
+
+        /* Find out where we are on screen */
+        window = gtk_widget_get_window(widget);
+        gdk_window_get_origin(window, &applet_x, &applet_y);
+
+        /* Grab the geometry for the monitor we're currently on */
+        screen = gtk_widget_get_screen(widget);
+        mon = gdk_screen_get_monitor_at_point(screen, applet_x, applet_y);
+        gdk_screen_get_monitor_geometry(screen, mon, &geom);
+
+        gint max_height = geom.height - 200;
+
+        GtkBin *bin = NULL;
+        GtkWidget *child = NULL;
+
+        bin = GTK_BIN(widget);
+        child = gtk_bin_get_child(bin);
+
+        if (child) {
+                gtk_widget_get_preferred_height(child, min_height, nat_height);
+                *min_height = MIN(max_height, *min_height);
+                *nat_height = MIN(max_height, *nat_height);
+        } else {
+                *min_height = *nat_height = 0;
+        }
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/classic/sidebar-scroller.h b/src/frontend/classic/sidebar-scroller.h
--- a/src/frontend/classic/sidebar-scroller.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/classic/sidebar-scroller.h	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,60 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskMenuSidebarScroller BriskMenuSidebarScroller;
+typedef struct _BriskMenuSidebarScrollerClass BriskMenuSidebarScrollerClass;
+
+#define BRISK_TYPE_MENU_SIDEBAR_SCROLLER brisk_menu_sidebar_scroller_get_type()
+#define BRISK_MENU_SIDEBAR_SCROLLER(o)                                                             \
+        (G_TYPE_CHECK_INSTANCE_CAST((o),                                                           \
+                                    BRISK_TYPE_MENU_SIDEBAR_SCROLLER,                              \
+                                    BriskMenuSidebarScroller))
+#define BRISK_IS_MENU_SIDEBAR_SCROLLER(o)                                                          \
+        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_MENU_SIDEBAR_SCROLLER))
+#define BRISK_MENU_SIDEBAR_SCROLLER_CLASS(o)                                                       \
+        (G_TYPE_CHECK_CLASS_CAST((o),                                                              \
+                                 BRISK_TYPE_MENU_SIDEBAR_SCROLLER,                                 \
+                                 BriskMenuSidebarScrollerClass))
+#define BRISK_IS_MENU_SIDEBAR_SCROLLER_CLASS(o)                                                    \
+        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_MENU_SIDEBAR_SCROLLER))
+#define BRISK_MENU_SIDEBAR_SCROLLER_GET_CLASS(o)                                                   \
+        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
+                                   BRISK_TYPE_MENU_SIDEBAR_SCROLLER,                               \
+                                   BriskMenuSidebarScrollerClass))
+
+/**
+ * Construct a new BriskMenuSidebarScroller
+ */
+GtkWidget *brisk_menu_sidebar_scroller_new(void);
+
+GType brisk_menu_sidebar_scroller_get_type(void);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/dash/category-button.c b/src/frontend/dash/category-button.c
--- a/src/frontend/dash/category-button.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/dash/category-button.c	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,184 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2016-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "category-button.h"
+#include "menu-private.h"
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+BRISK_END_PEDANTIC
+
+struct _BriskDashCategoryButtonClass {
+        GtkRadioButtonClass parent_class;
+};
+
+/**
+ * BriskDashCategoryButton is the toplevel window type used within the applet.
+ */
+struct _BriskDashCategoryButton {
+        GtkRadioButton parent;
+        BriskSection *section;
+        GtkWidget *label;
+};
+
+G_DEFINE_TYPE(BriskDashCategoryButton, brisk_dash_category_button, GTK_TYPE_RADIO_BUTTON)
+
+enum { PROP_SECTION = 1, N_PROPS };
+
+static GParamSpec *obj_properties[N_PROPS] = {
+        NULL,
+};
+
+static void brisk_dash_category_button_set_property(GObject *object, guint id, const GValue *value,
+                                                    GParamSpec *spec)
+{
+        BriskDashCategoryButton *self = BRISK_DASH_CATEGORY_BUTTON(object);
+
+        switch (id) {
+        case PROP_SECTION:
+                self->section = g_value_get_pointer(value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
+        }
+}
+
+static void brisk_dash_category_button_get_property(GObject *object, guint id, GValue *value,
+                                                    GParamSpec *spec)
+{
+        BriskDashCategoryButton *self = BRISK_DASH_CATEGORY_BUTTON(object);
+
+        switch (id) {
+        case PROP_SECTION:
+                g_value_set_pointer(value, self->section);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
+        }
+}
+
+/**
+ * brisk_dash_category_button_new:
+ *
+ * Construct a new BriskDashCategoryButton object
+ */
+GtkWidget *brisk_dash_category_button_new(BriskSection *section)
+{
+        return g_object_new(BRISK_TYPE_DASH_CATEGORY_BUTTON, "section", section, NULL);
+}
+
+/**
+ * brisk_dash_category_button_dispose:
+ *
+ * Clean up a BriskDashCategoryButton instance
+ */
+static void brisk_dash_category_button_dispose(GObject *obj)
+{
+        BriskDashCategoryButton *self = BRISK_DASH_CATEGORY_BUTTON(obj);
+
+        g_clear_object(&self->section);
+
+        G_OBJECT_CLASS(brisk_dash_category_button_parent_class)->dispose(obj);
+}
+
+/**
+ * Handle constructor specifics for our button
+ */
+static void brisk_dash_category_button_constructed(GObject *obj)
+{
+        BriskDashCategoryButton *self = NULL;
+
+        self = BRISK_DASH_CATEGORY_BUTTON(obj);
+
+        /* If we have a section, use it, otherwise we're a special "All" button */
+        if (self->section) {
+                gtk_label_set_label(GTK_LABEL(self->label), brisk_section_get_name(self->section));
+        } else {
+                gtk_label_set_label(GTK_LABEL(self->label), _("All"));
+        }
+
+        G_OBJECT_CLASS(brisk_dash_category_button_parent_class)->constructed(obj);
+}
+
+/**
+ * brisk_dash_category_button_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_dash_category_button_class_init(BriskDashCategoryButtonClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->dispose = brisk_dash_category_button_dispose;
+        obj_class->set_property = brisk_dash_category_button_set_property;
+        obj_class->get_property = brisk_dash_category_button_get_property;
+        obj_class->constructed = brisk_dash_category_button_constructed;
+
+        obj_properties[PROP_SECTION] = g_param_spec_pointer("section",
+                                                            "The BriskSection",
+                                                            "Section that this category represents",
+                                                            G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
+        g_object_class_install_properties(obj_class, N_PROPS, obj_properties);
+}
+
+/**
+ * brisk_dash_category_button_init:
+ *
+ * Handle construction of the BriskDashCategoryButton
+ */
+static void brisk_dash_category_button_init(BriskDashCategoryButton *self)
+{
+        GtkStyleContext *style = NULL;
+        GtkWidget *label = NULL;
+        GtkWidget *layout = NULL;
+
+        /* Main layout */
+        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        /* Display label */
+        label = gtk_label_new("");
+        self->label = label;
+        g_object_set(self->label, "halign", GTK_ALIGN_START, "valign", GTK_ALIGN_CENTER, NULL);
+        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
+
+        /* Button specific fixes */
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+
+        /* Look like a button */
+        g_object_set(G_OBJECT(self), "draw-indicator", FALSE, NULL);
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+
+        /* Flatten the button */
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+        gtk_style_context_add_class(style, "dash-category-button");
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/dash/category-button.h b/src/frontend/dash/category-button.h
--- a/src/frontend/dash/category-button.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/dash/category-button.h	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,59 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2016-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "backend/section.h"
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskDashCategoryButton BriskDashCategoryButton;
+typedef struct _BriskDashCategoryButtonClass BriskDashCategoryButtonClass;
+
+#define BRISK_TYPE_DASH_CATEGORY_BUTTON brisk_dash_category_button_get_type()
+#define BRISK_DASH_CATEGORY_BUTTON(o)                                                              \
+        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_DASH_CATEGORY_BUTTON, BriskDashCategoryButton))
+#define BRISK_IS_DASH_CATEGORY_BUTTON(o)                                                           \
+        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_DASH_CATEGORY_BUTTON))
+#define BRISK_DASH_CATEGORY_BUTTON_CLASS(o)                                                        \
+        (G_TYPE_CHECK_CLASS_CAST((o),                                                              \
+                                 BRISK_TYPE_DASH_CATEGORY_BUTTON,                                  \
+                                 BriskDashCategoryButtonClass))
+#define BRISK_IS_DASH_CATEGORY_BUTTON_CLASS(o)                                                     \
+        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_DASH_CATEGORY_BUTTON))
+#define BRISK_DASH_CATEGORY_BUTTON_GET_CLASS(o)                                                    \
+        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
+                                   BRISK_TYPE_DASH_CATEGORY_BUTTON,                                \
+                                   BriskDashCategoryButtonClass))
+
+/**
+ * Construct a new BriskDashCategoryButton from the given group
+ */
+GtkWidget *brisk_dash_category_button_new(BriskSection *section);
+
+GType brisk_dash_category_button_get_type(void);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/dash/dash-entry-button.c b/src/frontend/dash/dash-entry-button.c
--- a/src/frontend/dash/dash-entry-button.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/dash/dash-entry-button.c	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,146 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "styles.h"
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "dash-entry-button.h"
+#include <glib/gi18n.h>
+BRISK_END_PEDANTIC
+
+G_DEFINE_TYPE(BriskDashEntryButton, brisk_dash_entry_button, BRISK_TYPE_MENU_ENTRY_BUTTON)
+
+/**
+ * Handle constructor specifics for our button
+ */
+static void brisk_dash_entry_button_constructed(GObject *obj)
+{
+        BriskDashEntryButton *self = NULL;
+        const GIcon *icon = NULL;
+
+        self = BRISK_DASH_ENTRY_BUTTON(obj);
+
+        icon = brisk_item_get_icon(BRISK_MENU_ENTRY_BUTTON(self)->item);
+        if (icon) {
+                gtk_image_set_from_gicon(GTK_IMAGE(self->image),
+                                         (GIcon *)icon,
+                                         GTK_ICON_SIZE_LARGE_TOOLBAR);
+        } else {
+                gtk_image_set_from_icon_name(GTK_IMAGE(self->image),
+                                             "image-missing",
+                                             GTK_ICON_SIZE_LARGE_TOOLBAR);
+        }
+
+        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 64);
+
+        /* Determine our label based on the app */
+        gtk_label_set_label(GTK_LABEL(self->label),
+                            brisk_item_get_name(BRISK_MENU_ENTRY_BUTTON(self)->item));
+        gtk_widget_set_tooltip_text(GTK_WIDGET(self),
+                                    brisk_item_get_summary(BRISK_MENU_ENTRY_BUTTON(self)->item));
+
+        G_OBJECT_CLASS(brisk_dash_entry_button_parent_class)->constructed(obj);
+}
+
+static void brisk_dash_entry_button_dispose(GObject *obj)
+{
+        G_OBJECT_CLASS(brisk_dash_entry_button_parent_class)->dispose(obj);
+}
+
+/**
+ * brisk_dash_entry_button_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_dash_entry_button_class_init(BriskDashEntryButtonClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->constructed = brisk_dash_entry_button_constructed;
+        obj_class->dispose = brisk_dash_entry_button_dispose;
+}
+
+/**
+ * brisk_dash_entry_button_init:
+ *
+ * Handle construction of the BriskDashEntryButton
+ */
+static void brisk_dash_entry_button_init(BriskDashEntryButton *self)
+{
+        GtkStyleContext *style = NULL;
+        GtkWidget *label = NULL;
+        GtkWidget *image = NULL;
+        GtkWidget *layout = NULL;
+
+        /* Main layout */
+        layout = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        /* Image on the left */
+        image = gtk_image_new();
+        self->image = image;
+        gtk_widget_set_margin_bottom(image, 7);
+        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
+
+        /* Display label */
+        label = gtk_label_new("");
+        self->label = label;
+        gtk_label_set_lines(GTK_LABEL(label), 2);
+        gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);
+        gtk_label_set_max_width_chars(GTK_LABEL(label), 15);
+        gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);
+        g_object_set(self->label,
+                     "halign",
+                     GTK_ALIGN_CENTER,
+                     "valign",
+                     GTK_ALIGN_START,
+                     "justify",
+                     GTK_JUSTIFY_CENTER,
+                     NULL);
+        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
+
+        /* Button specific fixes */
+        gtk_button_set_relief(GTK_BUTTON(self), GTK_RELIEF_NONE);
+        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
+
+        /* Flatten the button */
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
+
+        gtk_widget_show_all(layout);
+}
+
+/**
+ * brisk_dash_entry_button_new:
+ *
+ * Return a newly created BriskDashEntryButton
+ */
+BriskMenuEntryButton *brisk_dash_entry_button_new(BriskMenuLauncher *launcher, BriskItem *item)
+{
+        return g_object_new(BRISK_TYPE_DASH_ENTRY_BUTTON, "launcher", launcher, "item", item, NULL);
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/dash/dash-entry-button.h b/src/frontend/dash/dash-entry-button.h
--- a/src/frontend/dash/dash-entry-button.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/dash/dash-entry-button.h	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,68 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "../entry-button.h"
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskDashEntryButton BriskDashEntryButton;
+typedef struct _BriskDashEntryButtonClass BriskDashEntryButtonClass;
+
+struct _BriskDashEntryButtonClass {
+        BriskMenuEntryButtonClass parent_class;
+};
+
+/**
+ * BriskDashEntryButton implements support for favourites in Brisk
+ */
+struct _BriskDashEntryButton {
+        BriskMenuEntryButton parent;
+
+        /* Basic button layout */
+        GtkWidget *label;
+        GtkWidget *image;
+};
+
+#define BRISK_TYPE_DASH_ENTRY_BUTTON brisk_dash_entry_button_get_type()
+#define BRISK_DASH_ENTRY_BUTTON(o)                                                                 \
+        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_DASH_ENTRY_BUTTON, BriskDashEntryButton))
+#define BRISK_IS_DASH_ENTRY_BUTTON(o)                                                              \
+        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_DASH_ENTRY_BUTTON))
+#define BRISK_DASH_ENTRY_BUTTON_CLASS(o)                                                           \
+        (G_TYPE_CHECK_CLASS_CAST((o), BRISK_TYPE_DASH_ENTRY_BUTTON, BriskDashEntryButtonClass))
+#define BRISK_IS_DASH_ENTRY_BUTTON_CLASS(o)                                                        \
+        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_DASH_ENTRY_BUTTON))
+#define BRISK_DASH_ENTRY_BUTTON_GET_CLASS(o)                                                       \
+        (G_TYPE_INSTANCE_GET_CLASS((o), BRISK_TYPE_DASH_ENTRY_BUTTON, BriskDashEntryButtonClass))
+
+GType brisk_dash_entry_button_get_type(void);
+
+BriskMenuEntryButton *brisk_dash_entry_button_new(BriskMenuLauncher *launcher, BriskItem *item);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/dash/dash-window.c b/src/frontend/dash/dash-window.c
--- a/src/frontend/dash/dash-window.c	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/dash/dash-window.c	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,692 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE
+
+#include "styles.h"
+#include "util.h"
+
+BRISK_BEGIN_PEDANTIC
+#include "category-button.h"
+#include "dash-entry-button.h"
+#include "dash-window.h"
+#include <glib/gi18n.h>
+BRISK_END_PEDANTIC
+
+G_DEFINE_TYPE(BriskDashWindow, brisk_dash_window, BRISK_TYPE_MENU_WINDOW)
+
+static void brisk_dash_window_associate_category(BriskMenuWindow *self, GtkWidget *button);
+static void brisk_dash_window_on_toggled(BriskMenuWindow *self, GtkWidget *button);
+static gboolean brisk_dash_window_on_enter(BriskMenuWindow *self, GdkEventCrossing *event,
+                                           GtkWidget *button);
+static void brisk_dash_window_load_css(GtkSettings *settings, const gchar *key,
+                                       BriskDashWindow *self);
+static void brisk_dash_window_key_activate(BriskDashWindow *self, gpointer v);
+static void brisk_dash_window_activated(BriskMenuWindow *self, GtkFlowBoxChild *row, gpointer v);
+static void brisk_dash_window_set_filters_enabled(BriskDashWindow *self, gboolean enabled);
+static gboolean brisk_dash_window_filter_apps(GtkFlowBoxChild *row, gpointer v);
+static gint brisk_dash_window_sort(GtkFlowBoxChild *row1, GtkFlowBoxChild *row2, gpointer v);
+
+/**
+ * brisk_dash_window_dispose:
+ *
+ * Clean up a BriskDashWindow instance
+ */
+static void brisk_dash_window_dispose(GObject *obj)
+{
+        BriskDashWindow *self = BRISK_DASH_WINDOW(obj);
+        GdkScreen *screen = NULL;
+
+        if (self->css) {
+                screen = gtk_widget_get_screen(GTK_WIDGET(self));
+                gtk_style_context_remove_provider_for_screen(screen, GTK_STYLE_PROVIDER(self->css));
+                g_clear_object(&self->css);
+        }
+
+        G_OBJECT_CLASS(brisk_dash_window_parent_class)->dispose(obj);
+}
+
+static const gchar *brisk_dash_window_get_id(__brisk_unused__ BriskMenuWindow *window)
+{
+        return "dash";
+}
+
+static const gchar *brisk_dash_window_get_display_name(__brisk_unused__ BriskMenuWindow *window)
+{
+        return _("Dash");
+}
+
+static void brisk_dash_window_update_screen_position(BriskMenuWindow *self)
+{
+        GdkScreen *screen = NULL;
+        GtkAllocation relative_alloc = { 0 };
+        GdkWindow *window = NULL;
+        GdkRectangle geom = { 0 };
+        gint relative_x, relative_y = 0;      /* Real X, Y of the applet, on screen */
+        gint window_width, window_height = 0; /* Window width & height */
+        gint mon = 0;                         /* Monitor to display on */
+        gint window_x, window_y = 0;          /* Target X, Y */
+
+        if (!self->relative_to) {
+                g_warning("Cannot set relative location without relative widget!");
+                return;
+        }
+
+        /* Forcibly realize the applet window */
+        if (!gtk_widget_get_realized(self->relative_to)) {
+                gtk_widget_realize(self->relative_to);
+        }
+
+        /* Forcibly realize ourselves */
+        if (!gtk_widget_get_realized(GTK_WIDGET(self))) {
+                gtk_widget_realize(GTK_WIDGET(self));
+        }
+
+        gtk_widget_get_allocation(self->relative_to, &relative_alloc);
+
+        /* Find out where we are on screen */
+        window = gtk_widget_get_window(self->relative_to);
+        gdk_window_get_origin(window, &relative_x, &relative_y);
+
+        /* Grab the geometry for the monitor we're currently on */
+        screen = gtk_widget_get_screen(self->relative_to);
+        mon = gdk_screen_get_monitor_at_point(screen, relative_x, relative_y);
+        gdk_screen_get_monitor_geometry(screen, mon, &geom);
+
+        switch (self->position) {
+        case GTK_POS_LEFT:
+                window_width = geom.width - relative_alloc.width;
+                window_height = geom.height;
+                window_x = geom.x + relative_alloc.width;
+                window_y = geom.y;
+                break;
+        case GTK_POS_RIGHT:
+                window_width = geom.width - relative_alloc.width;
+                window_height = geom.height;
+                window_x = geom.x;
+                window_y = geom.y;
+                break;
+        case GTK_POS_TOP:
+                /* Top panel, appear below it */
+                window_width = geom.width;
+                window_height = geom.height - relative_alloc.height;
+                window_x = geom.x;
+                window_y = relative_y + relative_alloc.height;
+                break;
+        case GTK_POS_BOTTOM:
+        default:
+                /* Bottom panel, appear above it */
+                window_width = geom.width;
+                window_height = geom.height - relative_alloc.height;
+                window_x = geom.x;
+                window_y = geom.y;
+                break;
+        }
+
+        gtk_window_set_default_size(GTK_WINDOW(self), window_width, window_height);
+        gtk_window_move(GTK_WINDOW(self), window_x, window_y);
+}
+
+/**
+ * Backend has new items for us, add to the global store
+ */
+static void brisk_dash_window_add_item(BriskMenuWindow *self, BriskItem *item,
+                                       __brisk_unused__ BriskBackend *backend)
+{
+        BriskMenuEntryButton *button = NULL;
+        const gchar *item_id = brisk_item_get_id(item);
+
+        button = brisk_dash_entry_button_new(self->launcher, item);
+        g_signal_connect_swapped(button,
+                                 "show-context-menu",
+                                 G_CALLBACK(brisk_menu_window_show_context),
+                                 self);
+        gtk_container_add(GTK_CONTAINER(BRISK_DASH_WINDOW(self)->apps), GTK_WIDGET(button));
+        gtk_widget_show_all(GTK_WIDGET(button));
+
+        g_hash_table_insert(self->item_store, g_strdup(item_id), GTK_WIDGET(button));
+}
+
+/**
+ * Backend has a new sidebar section for us
+ */
+static void brisk_dash_window_add_section(BriskMenuWindow *self, BriskSection *section,
+                                          __brisk_unused__ BriskBackend *backend)
+{
+        GtkWidget *button = NULL;
+        const gchar *section_id = brisk_section_get_id(section);
+        GtkWidget *box_target = NULL;
+
+        /* Skip dupes. Sections are uniquely namespaced */
+        if (g_hash_table_lookup(self->item_store, section_id) != NULL) {
+                return;
+        }
+
+        box_target = brisk_menu_window_get_section_box(self, backend);
+        gtk_orientable_set_orientation(GTK_ORIENTABLE(box_target), GTK_ORIENTATION_HORIZONTAL);
+
+        button = brisk_dash_category_button_new(section);
+        gtk_radio_button_join_group(GTK_RADIO_BUTTON(button),
+                                    GTK_RADIO_BUTTON(self->section_box_leader));
+        gtk_box_pack_start(GTK_BOX(box_target), button, FALSE, FALSE, 0);
+        brisk_dash_window_associate_category(self, button);
+        gtk_widget_show_all(button);
+
+        /* Avoid new dupes */
+        g_hash_table_insert(self->item_store, g_strdup(section_id), button);
+
+        brisk_menu_window_select_sections(self);
+}
+
+/**
+ * A backend needs us to invalidate the filters
+ */
+static void brisk_dash_window_invalidate_filter(BriskMenuWindow *self,
+                                                __brisk_unused__ BriskBackend *backend)
+{
+        gtk_flow_box_invalidate_filter(GTK_FLOW_BOX(BRISK_DASH_WINDOW(self)->apps));
+        gtk_flow_box_invalidate_sort(GTK_FLOW_BOX(BRISK_DASH_WINDOW(self)->apps));
+}
+
+/**
+ * A backend needs us to purge any data we have for it
+ */
+static void brisk_dash_window_reset(BriskMenuWindow *self, BriskBackend *backend)
+{
+        GtkWidget *box_target = NULL;
+        GList *kids = NULL, *elem = NULL;
+        const gchar *backend_id = NULL;
+
+        backend_id = brisk_backend_get_id(backend);
+
+        box_target = brisk_menu_window_get_section_box(self, backend);
+        gtk_container_foreach(GTK_CONTAINER(box_target),
+                              (GtkCallback)brisk_menu_window_remove_category,
+                              self);
+
+        /* Manual work for the items */
+        kids = gtk_container_get_children(GTK_CONTAINER(BRISK_DASH_WINDOW(self)->apps));
+        for (elem = kids; elem; elem = elem->next) {
+                GtkWidget *row = elem->data;
+                GtkWidget *child = NULL;
+                BriskItem *item = NULL;
+                const gchar *local_backend_id = NULL;
+                const gchar *local_id = NULL;
+
+                if (!GTK_IS_BIN(GTK_BIN(row))) {
+                        continue;
+                }
+
+                child = gtk_bin_get_child(GTK_BIN(row));
+                if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {
+                        continue;
+                }
+
+                g_object_get(child, "item", &item, NULL);
+                if (!item) {
+                        g_warning("missing item for entry in backend '%s'", backend_id);
+                        continue;
+                }
+
+                local_backend_id = brisk_item_get_backend_id(item);
+                if (!g_str_equal(backend_id, local_backend_id)) {
+                        continue;
+                }
+                local_id = brisk_item_get_id(item);
+                g_hash_table_remove(self->item_store, local_id);
+                gtk_widget_destroy(row);
+        }
+        g_list_free(kids);
+}
+
+/**
+ * Override hiding so that we can invalidate all filters
+ */
+static void brisk_dash_window_hide(GtkWidget *widget)
+{
+        BriskDashWindow *self = NULL;
+        GtkAdjustment *adjustment = NULL;
+        autofree(GList) *selected_children = NULL;
+        GtkWidget *selected = NULL;
+
+        /* Have parent deal with it first */
+        GTK_WIDGET_CLASS(brisk_dash_window_parent_class)->hide(widget);
+
+        self = BRISK_DASH_WINDOW(widget);
+
+        /* Remove search filter */
+        gtk_entry_set_text(GTK_ENTRY(BRISK_MENU_WINDOW(self)->search), "");
+
+        brisk_menu_window_select_sections(BRISK_MENU_WINDOW(self));
+
+        /* Reset scrollbars */
+        adjustment = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->apps_scroll));
+        gtk_adjustment_set_value(adjustment, 0);
+        adjustment =
+            gtk_scrolled_window_get_hadjustment(GTK_SCROLLED_WINDOW(self->categories_scroll));
+        gtk_adjustment_set_value(adjustment, 0);
+
+        /* Unselect any current "apps" */
+        selected_children = gtk_flow_box_get_selected_children(GTK_FLOW_BOX(self->apps));
+        selected = g_list_nth_data(selected_children, 0);
+        if (selected) {
+                gtk_flow_box_unselect_child(GTK_FLOW_BOX(self->apps), GTK_FLOW_BOX_CHILD(selected));
+        }
+}
+
+/**
+ * brisk_dash_window_class_init:
+ *
+ * Handle class initialisation
+ */
+static void brisk_dash_window_class_init(BriskDashWindowClass *klazz)
+{
+        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
+        BriskMenuWindowClass *b_class = BRISK_MENU_WINDOW_CLASS(klazz);
+        GtkWidgetClass *wid_class = GTK_WIDGET_CLASS(klazz);
+
+        /* gobject vtable hookup */
+        obj_class->dispose = brisk_dash_window_dispose;
+
+        /* Backend vtable hookup */
+        b_class->get_id = brisk_dash_window_get_id;
+        b_class->get_display_name = brisk_dash_window_get_display_name;
+        b_class->update_screen_position = brisk_dash_window_update_screen_position;
+        b_class->add_item = brisk_dash_window_add_item;
+        b_class->add_section = brisk_dash_window_add_section;
+        b_class->invalidate_filter = brisk_dash_window_invalidate_filter;
+        b_class->reset = brisk_dash_window_reset;
+
+        wid_class->hide = brisk_dash_window_hide;
+}
+
+/**
+ * brisk_dash_window_init:
+ *
+ * Handle construction of the BriskDashWindow
+ */
+static void brisk_dash_window_init(BriskDashWindow *self)
+{
+        GtkWidget *layout = NULL;
+        GtkWidget *widget = NULL;
+        GtkWidget *scroll = NULL;
+        GtkWidget *header = NULL;
+        GtkWidget *content = NULL;
+        GdkScreen *screen = NULL;
+        GtkStyleContext *style = NULL;
+        BriskMenuWindow *base = NULL;
+        GtkSettings *gtk_settings = NULL;
+        autofree(gchar) *txt_holder = NULL;
+
+        base = BRISK_MENU_WINDOW(self);
+
+        brisk_dash_window_load_css(gtk_settings, "gtk-theme-name", self);
+        gtk_settings = gtk_settings_get_default();
+        g_signal_connect(gtk_settings,
+                         "notify::gtk-theme-name",
+                         G_CALLBACK(brisk_dash_window_load_css),
+                         self);
+
+        style = gtk_widget_get_style_context(GTK_WIDGET(self));
+        gtk_style_context_add_class(style, BRISK_STYLE_MAIN);
+        gtk_style_context_add_class(style, BRISK_STYLE_DASH);
+
+        brisk_menu_window_configure_grabs(base);
+
+        layout = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
+        gtk_container_add(GTK_CONTAINER(self), layout);
+
+        header = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
+        style = gtk_widget_get_style_context(GTK_WIDGET(header));
+        gtk_style_context_add_class(style, "header");
+        gtk_box_pack_start(GTK_BOX(layout), header, FALSE, FALSE, 0);
+
+        /* Create search entry */
+        widget = gtk_entry_new();
+        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),
+                                          GTK_ENTRY_ICON_PRIMARY,
+                                          "edit-find-symbolic");
+        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),
+                                          GTK_ENTRY_ICON_SECONDARY,
+                                          "edit-clear-symbolic");
+        gtk_box_pack_start(GTK_BOX(header), widget, FALSE, FALSE, 20);
+        gtk_entry_set_width_chars(GTK_ENTRY(widget), 55);
+        gtk_widget_set_valign(widget, GTK_ALIGN_CENTER);
+        gtk_widget_set_halign(widget, GTK_ALIGN_CENTER);
+        /* Translators: This is the text shown in the "search box" with no content */
+        txt_holder = g_strdup_printf("%s\u2026", _("Type to search"));
+        gtk_entry_set_placeholder_text(GTK_ENTRY(widget), txt_holder);
+        base->search = widget;
+        g_signal_connect_swapped(widget, "changed", G_CALLBACK(brisk_menu_window_search), self);
+        g_signal_connect_swapped(widget,
+                                 "activate",
+                                 G_CALLBACK(brisk_dash_window_key_activate),
+                                 self);
+        g_signal_connect(widget, "icon-press", G_CALLBACK(brisk_menu_window_clear_search), self);
+
+        /* Scrollbar for categories */
+        scroll = gtk_scrolled_window_new(NULL, NULL);
+        gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scroll), GTK_SHADOW_NONE);
+        gtk_box_pack_start(GTK_BOX(header), scroll, FALSE, FALSE, 0);
+        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
+                                       GTK_POLICY_AUTOMATIC,
+                                       GTK_POLICY_NEVER);
+        gtk_widget_set_can_focus(scroll, FALSE);
+        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(scroll), TRUE);
+        self->categories_scroll = scroll;
+
+        /* Container for categories */
+        widget = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+        gtk_container_add(GTK_CONTAINER(scroll), widget);
+        base->section_box_holder = widget;
+
+        style = gtk_widget_get_style_context(widget);
+        gtk_style_context_add_class(style, "section-box-holder");
+
+        /* Content layout */
+        content = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
+        gtk_box_pack_start(GTK_BOX(layout), content, TRUE, TRUE, 0);
+
+        /* Scrollbar for apps */
+        scroll = gtk_scrolled_window_new(NULL, NULL);
+        gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scroll), GTK_SHADOW_NONE);
+        gtk_box_pack_start(GTK_BOX(content), scroll, TRUE, TRUE, 0);
+        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
+                                       GTK_POLICY_NEVER,
+                                       GTK_POLICY_AUTOMATIC);
+        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(scroll), FALSE);
+        self->apps_scroll = scroll;
+
+        /* Application launcher display */
+        widget = gtk_flow_box_new();
+        gtk_widget_set_margin_top(widget, 50);
+        gtk_widget_set_margin_bottom(widget, 50);
+        gtk_widget_set_margin_start(widget, 150);
+        gtk_widget_set_margin_end(widget, 150);
+        gtk_container_add(GTK_CONTAINER(scroll), widget);
+        self->apps = widget;
+        g_object_set(self->apps, "halign", GTK_ALIGN_FILL, "valign", GTK_ALIGN_START, NULL);
+        gtk_flow_box_set_column_spacing(GTK_FLOW_BOX(widget), 80);
+        gtk_flow_box_set_max_children_per_line(GTK_FLOW_BOX(widget), 60);
+        gtk_flow_box_set_homogeneous(GTK_FLOW_BOX(widget), TRUE);
+        gtk_flow_box_set_activate_on_single_click(GTK_FLOW_BOX(self->apps), TRUE);
+        gtk_flow_box_set_selection_mode(GTK_FLOW_BOX(self->apps), GTK_SELECTION_SINGLE);
+        g_signal_connect_swapped(self->apps,
+                                 "child-activated",
+                                 G_CALLBACK(brisk_dash_window_activated),
+                                 self);
+
+        screen = gtk_widget_get_screen(widget);
+        GdkVisual *vis = gdk_screen_get_rgba_visual(screen);
+        if (vis) {
+                gtk_widget_set_visual(GTK_WIDGET(self), vis);
+        }
+
+        brisk_dash_window_set_filters_enabled(self, FALSE);
+
+        /* Special leader to control group association, hidden from view */
+        base->section_box_leader = gtk_radio_button_new(NULL);
+        gtk_box_pack_start(GTK_BOX(base->section_box_holder),
+                           base->section_box_leader,
+                           FALSE,
+                           FALSE,
+                           0);
+        gtk_widget_set_no_show_all(base->section_box_leader, TRUE);
+        gtk_widget_hide(base->section_box_leader);
+
+        brisk_dash_window_set_filters_enabled(self, TRUE);
+
+        /* Hook up keyboard events */
+        g_signal_connect(self,
+                         "key-release-event",
+                         G_CALLBACK(brisk_menu_window_key_release),
+                         NULL);
+        g_signal_connect(self, "key-press-event", G_CALLBACK(brisk_menu_window_key_press), NULL);
+
+        brisk_menu_window_init_backends(base);
+
+        gtk_widget_show_all(layout);
+}
+
+/**
+ * brisk_dash_window_new:
+ *
+ * Return a newly created BriskDashWindow
+ */
+BriskMenuWindow *brisk_dash_window_new(GtkWidget *relative_to)
+{
+        return g_object_new(BRISK_TYPE_DASH_WINDOW,
+                            "type",
+                            GTK_WINDOW_POPUP,
+                            "relative-to",
+                            relative_to,
+                            NULL);
+}
+
+/**
+ * brisk_dash_window_associate_category:
+ *
+ * This will hook up the category button for events to enable us to filter the
+ * list based on the active category.
+ */
+static void brisk_dash_window_associate_category(BriskMenuWindow *self, GtkWidget *button)
+{
+        g_signal_connect_swapped(button, "toggled", G_CALLBACK(brisk_dash_window_on_toggled), self);
+        g_signal_connect_swapped(button,
+                                 "enter-notify-event",
+                                 G_CALLBACK(brisk_dash_window_on_enter),
+                                 self);
+}
+
+/**
+ * Fired by clicking a category button
+ */
+static void brisk_dash_window_on_toggled(BriskMenuWindow *self, GtkWidget *button)
+{
+        BriskDashCategoryButton *cat = NULL;
+
+        /* Skip a double signal due to using a group */
+        if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button))) {
+                return;
+        }
+
+        cat = BRISK_DASH_CATEGORY_BUTTON(button);
+        g_object_get(cat, "section", &self->active_section, NULL);
+
+        /* Start the filter. */
+        brisk_dash_window_invalidate_filter(self, NULL);
+}
+
+/**
+ * Fired by entering into the category button with a roll over
+ */
+static gboolean brisk_dash_window_on_enter(BriskMenuWindow *self,
+                                           __brisk_unused__ GdkEventCrossing *event,
+                                           GtkWidget *button)
+{
+        GtkToggleButton *but = GTK_TOGGLE_BUTTON(button);
+
+        /* Whether we're in rollover mode */
+        if (!self->rollover) {
+                return GDK_EVENT_PROPAGATE;
+        }
+
+        if (gtk_toggle_button_get_active(but) || !gtk_widget_get_visible(button)) {
+                return GDK_EVENT_PROPAGATE;
+        }
+
+        /* Force activation through rollover */
+        gtk_toggle_button_set_active(but, TRUE);
+
+        return GDK_EVENT_PROPAGATE;
+}
+
+/**
+ * Load up the CSS assets
+ */
+static void brisk_dash_window_load_css(GtkSettings *settings, const gchar *key,
+                                       BriskDashWindow *self)
+{
+        GtkCssProvider *css = NULL;
+        GtkStyleContext *context = NULL;
+        autofree(GFile) *file = NULL;
+        autofree(GError) *err = NULL;
+        GdkScreen *screen = NULL;
+        GdkRGBA color;
+
+        file = g_file_new_for_uri("resource://com/solus-project/brisk/menu/dash/styling.css");
+
+        context = gtk_widget_get_style_context(GTK_WIDGET(self));
+        if (gtk_style_context_lookup_color(context, "dark_bg_color", &color)) {
+                file = g_file_new_for_uri(
+                    "resource://com/solus-project/brisk/menu/dash/styling-light.css");
+        }
+
+        if (!file) {
+                return;
+        }
+
+        screen = gtk_widget_get_screen(GTK_WIDGET(self));
+
+        if (self->css) {
+                gtk_style_context_remove_provider_for_screen(screen, GTK_STYLE_PROVIDER(self->css));
+                g_clear_object(&self->css);
+        }
+
+        css = gtk_css_provider_new();
+        self->css = css;
+
+        gtk_style_context_add_provider_for_screen(screen,
+                                                  GTK_STYLE_PROVIDER(css),
+                                                  GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+
+        if (!gtk_css_provider_load_from_file(css, file, &err)) {
+                g_warning("Failed to load CSS: %s\n", err->message);
+                return;
+        }
+}
+
+static void brisk_dash_window_key_activate(BriskDashWindow *self, __brisk_unused__ gpointer v)
+{
+        autofree(GList) *kids = NULL;
+        GList *elem = NULL;
+        BriskMenuEntryButton *button = NULL;
+
+        kids = gtk_container_get_children(GTK_CONTAINER(self->apps));
+
+        for (elem = kids; elem; elem = elem->next) {
+                GtkWidget *widget = elem->data;
+
+                if (!gtk_widget_get_visible(widget) || !gtk_widget_get_child_visible(widget)) {
+                        continue;
+                }
+
+                button = BRISK_MENU_ENTRY_BUTTON(gtk_bin_get_child(GTK_BIN(widget)));
+                break;
+        }
+        if (!button) {
+                return;
+        }
+        brisk_menu_entry_button_launch(button);
+}
+
+static void brisk_dash_window_activated(__brisk_unused__ BriskMenuWindow *self,
+                                        GtkFlowBoxChild *row, __brisk_unused__ gpointer v)
+{
+        BriskMenuEntryButton *button = NULL;
+        GtkWidget *child = NULL;
+
+        child = gtk_bin_get_child(GTK_BIN(row));
+        if (!child) {
+                return;
+        }
+        if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {
+                return;
+        }
+        button = BRISK_MENU_ENTRY_BUTTON(child);
+        brisk_menu_entry_button_launch(button);
+}
+
+/**
+ * Enable or disable the filters between building of the menus
+ */
+static void brisk_dash_window_set_filters_enabled(BriskDashWindow *self, gboolean enabled)
+{
+        BRISK_MENU_WINDOW(self)->filtering = enabled;
+        if (enabled) {
+                gtk_flow_box_set_filter_func(GTK_FLOW_BOX(self->apps),
+                                             brisk_dash_window_filter_apps,
+                                             self,
+                                             NULL);
+                gtk_flow_box_set_sort_func(GTK_FLOW_BOX(self->apps),
+                                           brisk_dash_window_sort,
+                                           self,
+                                           NULL);
+                return;
+        }
+        gtk_flow_box_set_filter_func(GTK_FLOW_BOX(self->apps), NULL, NULL, NULL);
+        gtk_flow_box_set_sort_func(GTK_FLOW_BOX(self->apps), NULL, NULL, NULL);
+}
+
+/**
+ * brisk_dash_window_filter_apps:
+ *
+ * Responsible for filtering the selection based on active group or search
+ * term.
+ */
+__brisk_pure__ static gboolean brisk_dash_window_filter_apps(GtkFlowBoxChild *row, gpointer v)
+{
+        BriskMenuWindow *self = NULL;
+        GtkWidget *child = NULL;
+
+        self = BRISK_MENU_WINDOW(v);
+
+        if (!self->filtering) {
+                return FALSE;
+        }
+
+        /* Grab our Entry widget */
+        child = gtk_bin_get_child(GTK_BIN(row));
+
+        return brisk_menu_window_filter_apps(self, child);
+}
+
+static gint brisk_dash_window_sort(GtkFlowBoxChild *row1, GtkFlowBoxChild *row2, gpointer v)
+{
+        GtkWidget *child1, *child2 = NULL;
+        BriskItem *itemA, *itemB = NULL;
+        autofree(gchar) *nameA = NULL;
+        autofree(gchar) *nameB = NULL;
+        BriskMenuWindow *self = NULL;
+
+        self = BRISK_MENU_WINDOW(v);
+
+        child1 = gtk_bin_get_child(GTK_BIN(row1));
+        child2 = gtk_bin_get_child(GTK_BIN(row2));
+
+        g_object_get(child1, "item", &itemA, NULL);
+        g_object_get(child2, "item", &itemB, NULL);
+
+        return brisk_menu_window_sort(self, itemA, itemB);
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/dash/dash-window.h b/src/frontend/dash/dash-window.h
--- a/src/frontend/dash/dash-window.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/frontend/dash/dash-window.h	2019-11-25 14:46:11.094939153 +0100
@@ -0,0 +1,69 @@
+/*
+ * This file is part of brisk-menu.
+ *
+ * Copyright © 2017-2018 Brisk Menu Developers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#pragma once
+
+#include "../menu-private.h"
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+typedef struct _BriskDashWindow BriskDashWindow;
+typedef struct _BriskDashWindowClass BriskDashWindowClass;
+
+struct _BriskDashWindowClass {
+        BriskMenuWindowClass parent_class;
+};
+
+/**
+ * BriskDashWindow implements support for favourites in Brisk
+ */
+struct _BriskDashWindow {
+        BriskMenuWindow parent;
+
+        /* Actual applications */
+        GtkWidget *apps;
+        GtkWidget *apps_scroll;
+
+        GtkWidget *categories_scroll;
+
+        GtkCssProvider *css;
+};
+
+#define BRISK_TYPE_DASH_WINDOW brisk_dash_window_get_type()
+#define BRISK_DASH_WINDOW(o)                                                                       \
+        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_DASH_WINDOW, BriskDashWindow))
+#define BRISK_IS_DASH_WINDOW(o) (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_DASH_WINDOW))
+#define BRISK_DASH_WINDOW_CLASS(o)                                                                 \
+        (G_TYPE_CHECK_CLASS_CAST((o), BRISK_TYPE_DASH_WINDOW, BriskDashWindowClass))
+#define BRISK_IS_DASH_WINDOW_CLASS(o) (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_DASH_WINDOW))
+#define BRISK_DASH_WINDOW_GET_CLASS(o)                                                             \
+        (G_TYPE_INSTANCE_GET_CLASS((o), BRISK_TYPE_DASH_WINDOW, BriskDashWindowClass))
+
+GType brisk_dash_window_get_type(void);
+
+BriskMenuWindow *brisk_dash_window_new(GtkWidget *relative_to);
+
+G_END_DECLS
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 expandtab:
+ * :indentSize=8:tabSize=8:noTabs=true:
+ */
diff -Naur a/src/frontend/desktop-button.c b/src/frontend/desktop-button.c
--- a/src/frontend/desktop-button.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/desktop-button.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,221 +0,0 @@
-/*
- * This file is part of brisk-menu.
- *
- * Copyright © 2016-2017 Brisk Menu Developers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#define _GNU_SOURCE
-
-#include "util.h"
-
-BRISK_BEGIN_PEDANTIC
-#include "desktop-button.h"
-#include "menu-private.h"
-#include <gtk/gtk.h>
-BRISK_END_PEDANTIC
-
-struct _BriskMenuDesktopButtonClass {
-        GtkButtonClass parent_class;
-};
-
-/**
- * BriskMenuDesktopButton is the toplevel window type used within the applet.
- */
-struct _BriskMenuDesktopButton {
-        GtkButton parent;
-        GAppInfo *desktop;
-        GtkWidget *label;
-        GtkWidget *image;
-        BriskMenuLauncher *launcher;
-};
-
-G_DEFINE_TYPE(BriskMenuDesktopButton, brisk_menu_desktop_button, GTK_TYPE_BUTTON)
-
-static void brisk_menu_desktop_button_clicked(GtkButton *button);
-
-enum { PROP_DESKTOP = 1, PROP_LAUNCHER, N_PROPS };
-
-static GParamSpec *obj_properties[N_PROPS] = {
-        NULL,
-};
-
-static void brisk_menu_desktop_button_set_property(GObject *object, guint id, const GValue *value,
-                                                   GParamSpec *spec)
-{
-        BriskMenuDesktopButton *self = BRISK_MENU_DESKTOP_BUTTON(object);
-
-        switch (id) {
-        case PROP_DESKTOP:
-                self->desktop = g_value_get_pointer(value);
-                break;
-        case PROP_LAUNCHER:
-                self->launcher = g_value_get_pointer(value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
-                break;
-        }
-}
-
-static void brisk_menu_desktop_button_get_property(GObject *object, guint id, GValue *value,
-                                                   GParamSpec *spec)
-{
-        BriskMenuDesktopButton *self = BRISK_MENU_DESKTOP_BUTTON(object);
-
-        switch (id) {
-        case PROP_DESKTOP:
-                g_value_set_pointer(value, self->desktop);
-                break;
-        case PROP_LAUNCHER:
-                g_value_set_pointer(value, self->launcher);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
-                break;
-        }
-}
-
-/**
- * brisk_menu_desktop_button_new:
- *
- * Construct a new BriskMenuDesktopButton object
- */
-GtkWidget *brisk_menu_desktop_button_new(BriskMenuLauncher *launcher, GAppInfo *desktop)
-{
-        return g_object_new(BRISK_TYPE_MENU_DESKTOP_BUTTON,
-                            "launcher",
-                            launcher,
-                            "desktop",
-                            desktop,
-                            NULL);
-}
-
-/**
- * brisk_menu_desktop_button_dispose:
- *
- * Clean up a BriskMenuDesktopButton instance
- */
-static void brisk_menu_desktop_button_dispose(GObject *obj)
-{
-        BriskMenuDesktopButton *self = NULL;
-
-        self = BRISK_MENU_DESKTOP_BUTTON(obj);
-        g_clear_object(&self->desktop);
-
-        G_OBJECT_CLASS(brisk_menu_desktop_button_parent_class)->dispose(obj);
-}
-
-/**
- * Handle constructor specifics for our button
- */
-static void brisk_menu_desktop_button_constructed(GObject *obj)
-{
-        const gchar *label = NULL;
-        BriskMenuDesktopButton *self = NULL;
-
-        self = BRISK_MENU_DESKTOP_BUTTON(obj);
-
-        gtk_image_set_from_gicon(GTK_IMAGE(self->image),
-                                 g_app_info_get_icon(self->desktop),
-                                 GTK_ICON_SIZE_BUTTON);
-        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 16);
-
-        /* Determine our label based on the app */
-        label = g_app_info_get_display_name(self->desktop);
-        gtk_label_set_label(GTK_LABEL(self->label), label);
-        gtk_widget_set_tooltip_text(GTK_WIDGET(self), g_app_info_get_description(self->desktop));
-
-        G_OBJECT_CLASS(brisk_menu_desktop_button_parent_class)->constructed(obj);
-}
-
-/**
- * brisk_menu_desktop_button_class_init:
- *
- * Handle class initialisation
- */
-static void brisk_menu_desktop_button_class_init(BriskMenuDesktopButtonClass *klazz)
-{
-        GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
-        GtkButtonClass *but_class = GTK_BUTTON_CLASS(klazz);
-
-        /* gobject vtable hookup */
-        obj_class->dispose = brisk_menu_desktop_button_dispose;
-        obj_class->set_property = brisk_menu_desktop_button_set_property;
-        obj_class->get_property = brisk_menu_desktop_button_get_property;
-        obj_class->constructed = brisk_menu_desktop_button_constructed;
-
-        /* button vtable hookup */
-        but_class->clicked = brisk_menu_desktop_button_clicked;
-
-        obj_properties[PROP_DESKTOP] = g_param_spec_pointer("desktop",
-                                                            "The GAppInfo",
-                                                            "Desktop file",
-                                                            G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
-        obj_properties[PROP_LAUNCHER] = g_param_spec_pointer("launcher",
-                                                             "The Brisk Launcher",
-                                                             "Launcher used for starting apps",
-                                                             G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
-        g_object_class_install_properties(obj_class, N_PROPS, obj_properties);
-}
-
-/**
- * brisk_menu_desktop_button_init:
- *
- * Handle construction of the BriskMenuDesktopButton
- */
-static void brisk_menu_desktop_button_init(BriskMenuDesktopButton *self)
-{
-        GtkStyleContext *style = NULL;
-        GtkWidget *label = NULL;
-        GtkWidget *image = NULL;
-        GtkWidget *layout = NULL;
-
-        /* Main layout */
-        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-        gtk_container_add(GTK_CONTAINER(self), layout);
-
-        /* Image on the left */
-        image = gtk_image_new();
-        self->image = image;
-        gtk_widget_set_margin_end(image, 7);
-        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
-
-        /* Display label */
-        label = gtk_label_new("");
-        self->label = label;
-        g_object_set(self->label, "halign", GTK_ALIGN_START, "valign", GTK_ALIGN_CENTER, NULL);
-        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
-
-        /* Button specific fixes */
-        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
-        gtk_button_set_relief(GTK_BUTTON(self), GTK_RELIEF_NONE);
-
-        /* Flatten the button */
-        style = gtk_widget_get_style_context(GTK_WIDGET(self));
-        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
-}
-
-static void brisk_menu_desktop_button_clicked(GtkButton *button)
-{
-        BriskMenuDesktopButton *self = NULL;
-
-        self = BRISK_MENU_DESKTOP_BUTTON(button);
-        brisk_menu_launcher_start(self->launcher, GTK_WIDGET(self), self->desktop);
-}
-/*
- * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
- *
- * Local variables:
- * c-basic-offset: 8
- * tab-width: 8
- * indent-tabs-mode: nil
- * End:
- *
- * vi: set shiftwidth=8 tabstop=8 expandtab:
- * :indentSize=8:tabSize=8:noTabs=true:
- */
diff -Naur a/src/frontend/desktop-button.h b/src/frontend/desktop-button.h
--- a/src/frontend/desktop-button.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/desktop-button.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/*
- * This file is part of brisk-menu.
- *
- * Copyright © 2016-2017 Brisk Menu Developers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#pragma once
-
-#include <glib-object.h>
-#include <gtk/gtk.h>
-#include <matemenu-tree.h>
-
-#include "launcher.h"
-
-G_BEGIN_DECLS
-
-typedef struct _BriskMenuDesktopButton BriskMenuDesktopButton;
-typedef struct _BriskMenuDesktopButtonClass BriskMenuDesktopButtonClass;
-
-#define BRISK_TYPE_MENU_DESKTOP_BUTTON brisk_menu_desktop_button_get_type()
-#define BRISK_MENU_DESKTOP_BUTTON(o)                                                               \
-        (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_MENU_DESKTOP_BUTTON, BriskMenuDesktopButton))
-#define BRISK_IS_MENU_DESKTOP_BUTTON(o)                                                            \
-        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_MENU_DESKTOP_BUTTON))
-#define BRISK_MENU_DESKTOP_BUTTON_CLASS(o)                                                         \
-        (G_TYPE_CHECK_CLASS_CAST((o), BRISK_TYPE_MENU_DESKTOP_BUTTON, BriskMenuDesktopButtonClass))
-#define BRISK_IS_MENU_DESKTOP_BUTTON_CLASS(o)                                                      \
-        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_MENU_DESKTOP_BUTTON))
-#define BRISK_MENU_DESKTOP_BUTTON_GET_CLASS(o)                                                     \
-        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
-                                   BRISK_TYPE_MENU_DESKTOP_BUTTON,                                 \
-                                   BriskMenuDesktopButtonClass))
-
-/**
- * Construct a new BriskMenuDesktopButton from the given desktop entry
- */
-GtkWidget *brisk_menu_desktop_button_new(BriskMenuLauncher *launcher, GAppInfo *desktop);
-
-GType brisk_menu_desktop_button_get_type(void);
-
-G_END_DECLS
-
-/*
- * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
- *
- * Local variables:
- * c-basic-offset: 8
- * tab-width: 8
- * indent-tabs-mode: nil
- * End:
- *
- * vi: set shiftwidth=8 tabstop=8 expandtab:
- * :indentSize=8:tabSize=8:noTabs=true:
- */
diff -Naur a/src/frontend/entry-button.c b/src/frontend/entry-button.c
--- a/src/frontend/entry-button.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/entry-button.c	2019-11-25 14:46:11.094939153 +0100
@@ -28,17 +28,6 @@
 static gboolean brisk_menu_entry_button_release_event(GtkWidget *wid, GdkEventButton *event);
 
 /**
- * BriskMenuEntryButton is the toplevel window type used within the applet.
- */
-struct _BriskMenuEntryButton {
-        GtkButton parent;
-        GtkWidget *label;
-        GtkWidget *image;
-        BriskItem *item;
-        BriskMenuLauncher *launcher;
-};
-
-/**
  * IDs for our signals
  */
 enum { ENTRY_BUTTON_SIGNAL_CONTEXT_MENU = 0, N_SIGNALS };
@@ -53,6 +42,21 @@
         NULL,
 };
 
+/**
+ * brisk_menu_entry_button_dispose:
+ *
+ * Clean up a BriskMenuEntryButton instance
+ */
+static void brisk_menu_entry_button_dispose(GObject *obj)
+{
+        BriskMenuEntryButton *self = NULL;
+
+        self = BRISK_MENU_ENTRY_BUTTON(obj);
+        g_clear_object(&self->item);
+
+        G_OBJECT_CLASS(brisk_menu_entry_button_parent_class)->dispose(obj);
+}
+
 static void brisk_menu_entry_button_set_property(GObject *object, guint id, const GValue *value,
                                                  GParamSpec *spec)
 {
@@ -90,61 +94,6 @@
 }
 
 /**
- * brisk_menu_entry_button_new:
- *
- * Construct a new BriskMenuEntryButton object
- */
-GtkWidget *brisk_menu_entry_button_new(BriskMenuLauncher *launcher, BriskItem *item)
-{
-        return g_object_new(BRISK_TYPE_MENU_ENTRY_BUTTON, "launcher", launcher, "item", item, NULL);
-}
-
-/**
- * brisk_menu_entry_button_dispose:
- *
- * Clean up a BriskMenuEntryButton instance
- */
-static void brisk_menu_entry_button_dispose(GObject *obj)
-{
-        BriskMenuEntryButton *self = NULL;
-
-        self = BRISK_MENU_ENTRY_BUTTON(obj);
-        g_clear_object(&self->item);
-
-        G_OBJECT_CLASS(brisk_menu_entry_button_parent_class)->dispose(obj);
-}
-
-/**
- * Handle constructor specifics for our button
- */
-static void brisk_menu_entry_button_constructed(GObject *obj)
-{
-        BriskMenuEntryButton *self = NULL;
-        const GIcon *icon = NULL;
-
-        self = BRISK_MENU_ENTRY_BUTTON(obj);
-
-        icon = brisk_item_get_icon(self->item);
-        if (icon) {
-                gtk_image_set_from_gicon(GTK_IMAGE(self->image),
-                                         (GIcon *)icon,
-                                         GTK_ICON_SIZE_LARGE_TOOLBAR);
-        } else {
-                gtk_image_set_from_icon_name(GTK_IMAGE(self->image),
-                                             "image-missing",
-                                             GTK_ICON_SIZE_LARGE_TOOLBAR);
-        }
-
-        gtk_image_set_pixel_size(GTK_IMAGE(self->image), 24);
-
-        /* Determine our label based on the app */
-        gtk_label_set_label(GTK_LABEL(self->label), brisk_item_get_name(self->item));
-        gtk_widget_set_tooltip_text(GTK_WIDGET(self), brisk_item_get_summary(self->item));
-
-        G_OBJECT_CLASS(brisk_menu_entry_button_parent_class)->constructed(obj);
-}
-
-/**
  * brisk_menu_entry_button_class_init:
  *
  * Handle class initialisation
@@ -158,7 +107,6 @@
         obj_class->dispose = brisk_menu_entry_button_dispose;
         obj_class->set_property = brisk_menu_entry_button_set_property;
         obj_class->get_property = brisk_menu_entry_button_get_property;
-        obj_class->constructed = brisk_menu_entry_button_constructed;
 
         /* widget vtable hookup */
         wid_class->drag_data_get = brisk_menu_entry_drag_data;
@@ -203,46 +151,11 @@
  */
 static void brisk_menu_entry_button_init(BriskMenuEntryButton *self)
 {
-        GtkStyleContext *style = NULL;
-        GtkWidget *label = NULL;
-        GtkWidget *image = NULL;
-        GtkWidget *layout = NULL;
-
         static const GtkTargetEntry drag_targets[] = {
                 { "text/uri-list", 0, 0 },
                 { "application/x-desktop", 0, 0 },
         };
 
-        /* Main layout */
-        layout = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-        gtk_container_add(GTK_CONTAINER(self), layout);
-
-        /* Image on the left */
-        image = gtk_image_new();
-        self->image = image;
-        gtk_widget_set_margin_end(image, 7);
-        gtk_box_pack_start(GTK_BOX(layout), image, FALSE, FALSE, 0);
-
-        /* Display label */
-        label = gtk_label_new("");
-        gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);
-        gtk_label_set_max_width_chars(GTK_LABEL(label), 25);
-        gtk_label_set_width_chars(GTK_LABEL(label), 25);
-        self->label = label;
-        g_object_set(self->label, "halign", GTK_ALIGN_START, "valign", GTK_ALIGN_CENTER, NULL);
-        gtk_box_pack_start(GTK_BOX(layout), label, TRUE, TRUE, 0);
-        G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-        gtk_misc_set_alignment(GTK_MISC(self->label), 0.0, 0.5);
-        G_GNUC_END_IGNORE_DEPRECATIONS
-
-        /* Button specific fixes */
-        gtk_button_set_relief(GTK_BUTTON(self), GTK_RELIEF_NONE);
-        gtk_widget_set_can_focus(GTK_WIDGET(self), FALSE);
-
-        /* Flatten the button */
-        style = gtk_widget_get_style_context(GTK_WIDGET(self));
-        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
-
         /* Hook up drag so users can drag .desktop from here elsewhere */
         gtk_drag_source_set(GTK_WIDGET(self), GDK_BUTTON1_MASK, drag_targets, 2, GDK_ACTION_COPY);
 }
diff -Naur a/src/frontend/entry-button.h b/src/frontend/entry-button.h
--- a/src/frontend/entry-button.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/entry-button.h	2019-11-25 14:46:11.094939153 +0100
@@ -27,6 +27,15 @@
         void (*show_context_menu)(BriskMenuEntryButton *button, BriskItem *item);
 };
 
+/**
+ * BriskMenuEntryButton is the toplevel window type used within the applet.
+ */
+struct _BriskMenuEntryButton {
+        GtkButton parent;
+        BriskMenuLauncher *launcher;
+        BriskItem *item;
+};
+
 #define BRISK_TYPE_MENU_ENTRY_BUTTON brisk_menu_entry_button_get_type()
 #define BRISK_MENU_ENTRY_BUTTON(o)                                                                 \
         (G_TYPE_CHECK_INSTANCE_CAST((o), BRISK_TYPE_MENU_ENTRY_BUTTON, BriskMenuEntryButton))
@@ -39,11 +48,6 @@
 #define BRISK_MENU_ENTRY_BUTTON_GET_CLASS(o)                                                       \
         (G_TYPE_INSTANCE_GET_CLASS((o), BRISK_TYPE_MENU_ENTRY_BUTTON, BriskMenuEntryButtonClass))
 
-/**
- * Construct a new BriskMenuEntryButton from the given entry
- */
-GtkWidget *brisk_menu_entry_button_new(BriskMenuLauncher *launcher, BriskItem *item);
-
 void brisk_menu_entry_button_launch(BriskMenuEntryButton *button);
 
 GType brisk_menu_entry_button_get_type(void);
diff -Naur a/src/frontend/launcher.c b/src/frontend/launcher.c
--- a/src/frontend/launcher.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/launcher.c	2019-11-25 14:46:11.094939153 +0100
@@ -120,7 +120,7 @@
 
         /* Hide the menu before kicking off the launch */
         toplevel = gtk_widget_get_toplevel(parent);
-        if (!GTK_IS_WINDOW(parent)) {
+        if (BRISK_IS_MENU_WINDOW(toplevel)) {
                 gtk_widget_hide(toplevel);
         }
 }
diff -Naur a/src/frontend/menu-grabs.c b/src/frontend/menu-grabs.c
--- a/src/frontend/menu-grabs.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-grabs.c	2019-11-25 14:46:11.094939153 +0100
@@ -15,7 +15,6 @@
 
 BRISK_BEGIN_PEDANTIC
 #include "menu-private.h"
-#include "menu-window.h"
 #include <gtk/gtk.h>
 BRISK_END_PEDANTIC
 
diff -Naur a/src/frontend/menu-keyboard.c b/src/frontend/menu-keyboard.c
--- a/src/frontend/menu-keyboard.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-keyboard.c	2019-11-25 14:46:11.094939153 +0100
@@ -12,7 +12,6 @@
 #include "util.h"
 
 BRISK_BEGIN_PEDANTIC
-#include "entry-button.h"
 #include "menu-private.h"
 BRISK_END_PEDANTIC
 
@@ -51,30 +50,6 @@
         return GDK_EVENT_PROPAGATE;
 }
 
-void brisk_menu_window_key_activate(BriskMenuWindow *self, __brisk_unused__ gpointer v)
-{
-        autofree(GList) *kids = NULL;
-        GList *elem = NULL;
-        BriskMenuEntryButton *button = NULL;
-
-        kids = gtk_container_get_children(GTK_CONTAINER(self->apps));
-
-        for (elem = kids; elem; elem = elem->next) {
-                GtkWidget *widget = elem->data;
-
-                if (!gtk_widget_get_visible(widget) || !gtk_widget_get_child_visible(widget)) {
-                        continue;
-                }
-
-                button = BRISK_MENU_ENTRY_BUTTON(gtk_bin_get_child(GTK_BIN(widget)));
-                break;
-        }
-        if (!button) {
-                return;
-        }
-        brisk_menu_entry_button_launch(button);
-}
-
 /**
  * Called in idle once back out of the event
  */
diff -Naur a/src/frontend/menu-loader.c b/src/frontend/menu-loader.c
--- a/src/frontend/menu-loader.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-loader.c	2019-11-25 14:46:11.094939153 +0100
@@ -17,7 +17,6 @@
 #include "backend/all-items/all-backend.h"
 #include "backend/apps/apps-backend.h"
 #include "backend/favourites/favourites-backend.h"
-#include "category-button.h"
 #include "entry-button.h"
 #include "menu-private.h"
 #include <gtk/gtk.h>
@@ -26,94 +25,12 @@
 /**
  * Return the section box for the given backend ID
  */
-static GtkWidget *brisk_menu_window_get_section_box(BriskMenuWindow *self, BriskBackend *backend)
+GtkWidget *brisk_menu_window_get_section_box(BriskMenuWindow *self, BriskBackend *backend)
 {
         return g_hash_table_lookup(self->section_boxes, brisk_backend_get_id(backend));
 }
 
 /**
- * Backend has new items for us, add to the global store
- */
-static void brisk_menu_window_add_item(BriskMenuWindow *self, BriskItem *item,
-                                       __brisk_unused__ BriskBackend *backend)
-{
-        GtkWidget *button = NULL;
-        const gchar *item_id = brisk_item_get_id(item);
-
-        button = brisk_menu_entry_button_new(self->launcher, item);
-        g_signal_connect_swapped(button,
-                                 "show-context-menu",
-                                 G_CALLBACK(brisk_menu_window_show_context),
-                                 self);
-        gtk_container_add(GTK_CONTAINER(self->apps), button);
-        gtk_widget_show_all(button);
-
-        g_hash_table_insert(self->item_store, g_strdup(item_id), button);
-}
-
-/**
- * Backend has a new sidebar section for us
- */
-static void brisk_menu_window_add_section(BriskMenuWindow *self, BriskSection *section,
-                                          __brisk_unused__ BriskBackend *backend)
-{
-        GtkWidget *button = NULL;
-        const gchar *section_id = brisk_section_get_id(section);
-        GtkWidget *box_target = NULL;
-
-        /* Skip dupes. Sections are uniquely namespaced */
-        if (g_hash_table_lookup(self->item_store, section_id) != NULL) {
-                return;
-        }
-
-        box_target = brisk_menu_window_get_section_box(self, backend);
-
-        button = brisk_menu_category_button_new(section);
-        gtk_radio_button_join_group(GTK_RADIO_BUTTON(button),
-                                    GTK_RADIO_BUTTON(self->sidebar_leader));
-        gtk_box_pack_start(GTK_BOX(box_target), button, FALSE, FALSE, 0);
-        brisk_menu_window_associate_category(self, button);
-        gtk_widget_show_all(button);
-
-        /* Avoid new dupes */
-        g_hash_table_insert(self->item_store, g_strdup(section_id), button);
-
-        brisk_menu_window_select_sidebar(self);
-}
-
-/**
- * Handle deletion for children in the sidebar
- */
-static void brisk_menu_window_remove_category(GtkWidget *widget, BriskMenuWindow *self)
-{
-        BriskSection *section = NULL;
-        const gchar *section_id = NULL;
-
-        if (!BRISK_IS_MENU_CATEGORY_BUTTON(widget)) {
-                return;
-        }
-
-        g_object_get(widget, "section", &section, NULL);
-        if (!section) {
-                g_warning("missing section for category button");
-        }
-
-        section_id = brisk_section_get_id(section);
-
-        g_hash_table_remove(self->item_store, section_id);
-        gtk_widget_destroy(widget);
-}
-
-/**
- * A backend needs us to invalidate the filters
- */
-static void brisk_menu_window_invalidate_filter(BriskMenuWindow *self,
-                                                __brisk_unused__ BriskBackend *backend)
-{
-        gtk_list_box_invalidate_filter(GTK_LIST_BOX(self->apps));
-}
-
-/**
  * A backend needs us to hide the window
  */
 static void brisk_menu_window_hide(BriskMenuWindow *self, __brisk_unused__ BriskBackend *backend)
@@ -122,57 +39,6 @@
 }
 
 /**
- * A backend needs us to purge any data we have for it
- */
-static void brisk_menu_window_reset(BriskMenuWindow *self, BriskBackend *backend)
-{
-        GtkWidget *box_target = NULL;
-        GList *kids = NULL, *elem = NULL;
-        const gchar *backend_id = NULL;
-
-        backend_id = brisk_backend_get_id(backend);
-
-        box_target = brisk_menu_window_get_section_box(self, backend);
-        gtk_container_foreach(GTK_CONTAINER(box_target),
-                              (GtkCallback)brisk_menu_window_remove_category,
-                              self);
-
-        /* Manual work for the items */
-        kids = gtk_container_get_children(GTK_CONTAINER(self->apps));
-        for (elem = kids; elem; elem = elem->next) {
-                GtkWidget *row = elem->data;
-                GtkWidget *child = NULL;
-                BriskItem *item = NULL;
-                const gchar *local_backend_id = NULL;
-                const gchar *local_id = NULL;
-
-                if (!GTK_IS_BIN(GTK_BIN(row))) {
-                        continue;
-                }
-
-                child = gtk_bin_get_child(GTK_BIN(row));
-                if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {
-                        continue;
-                }
-
-                g_object_get(child, "item", &item, NULL);
-                if (!item) {
-                        g_warning("missing item for entry in backend '%s'", backend_id);
-                        continue;
-                }
-
-                local_backend_id = brisk_item_get_backend_id(item);
-                if (!g_str_equal(backend_id, local_backend_id)) {
-                        continue;
-                }
-                local_id = brisk_item_get_id(item);
-                g_hash_table_remove(self->item_store, local_id);
-                gtk_widget_destroy(row);
-        }
-        g_list_free(kids);
-}
-
-/**
  * Load the menus and place them into the window regions
  */
 gboolean brisk_menu_window_load_menus(BriskMenuWindow *self)
@@ -227,12 +93,14 @@
         g_signal_connect_swapped(backend, "reset", G_CALLBACK(brisk_menu_window_reset), self);
 
         box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
-        gtk_box_pack_start(GTK_BOX(self->sidebar), box, FALSE, FALSE, 0);
+        gtk_box_pack_start(GTK_BOX(self->section_box_holder), box, FALSE, FALSE, 0);
 
         /* Always ensure that the box is placed after "All" but not after any
          * non-section boxes
          */
-        gtk_box_reorder_child(GTK_BOX(self->sidebar), box, (gint)g_hash_table_size(self->backends));
+        gtk_box_reorder_child(GTK_BOX(self->section_box_holder),
+                              box,
+                              (gint)g_hash_table_size(self->backends));
 
         g_hash_table_insert(self->section_boxes, (gchar *)backend_id, box);
 }
@@ -248,6 +116,29 @@
 }
 
 /**
+ * Handle deletion for children in the sidebar
+ */
+void brisk_menu_window_remove_category(GtkWidget *widget, BriskMenuWindow *self)
+{
+        BriskSection *section = NULL;
+        const gchar *section_id = NULL;
+
+        if (!GTK_IS_RADIO_BUTTON(widget)) {
+                return;
+        }
+
+        g_object_get(widget, "section", &section, NULL);
+        if (!section) {
+                g_warning("missing section for category button");
+        }
+
+        section_id = brisk_section_get_id(section);
+
+        g_hash_table_remove(self->item_store, section_id);
+        gtk_widget_destroy(widget);
+}
+
+/**
  * Bring up the initial backends
  */
 void brisk_menu_window_init_backends(BriskMenuWindow *self)
diff -Naur a/src/frontend/menu-private.h b/src/frontend/menu-private.h
--- a/src/frontend/menu-private.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-private.h	2019-11-25 14:46:11.094939153 +0100
@@ -31,119 +31,115 @@
 
 struct _BriskMenuWindowClass {
         GtkWindowClass parent_class;
+
+        const gchar *(*get_id)(BriskMenuWindow *);
+        const gchar *(*get_display_name)(BriskMenuWindow *);
+        void (*update_screen_position)(BriskMenuWindow *);
+        void (*update_search)(BriskMenuWindow *);
+        void (*add_item)(BriskMenuWindow *, BriskItem *, BriskBackend *);
+        void (*add_section)(BriskMenuWindow *, BriskSection *, BriskBackend *);
+        void (*invalidate_filter)(BriskMenuWindow *, BriskBackend *);
+        void (*reset)(BriskMenuWindow *, BriskBackend *);
+
+        gpointer padding[12];
 };
 
 /**
- * BriskMenuWindow is the toplevel window type used within the applet.
+ * BriskMenuWindow is an abstract top-level class which is used as the base
+ * of all other window implementations within Brisk.
  */
 struct _BriskMenuWindow {
         GtkWindow parent;
+        /* Current panel position */
+        GtkPositionType position;
 
-        /* Who "owns" us */
-        GtkWidget *relative_to;
+        /* Current search position */
+        SearchPosition search_position;
 
-        /* Control launches */
-        BriskMenuLauncher *launcher;
+        /* Top search entry */
+        GtkWidget *search;
+
+        /* Whether we have a grab or not */
+        gboolean grabbed;
+
+        /* Whether we're in rollover mode or not */
+        gboolean rollover;
+
+        /* Global settings for all BriskMenu instances */
+        GSettings *settings;
 
         /* Control hotkeys */
         BriskKeyBinder *binder;
         gchar *shortcut;
 
-        /* Categories */
-        GtkWidget *sidebar;
-        GtkWidget *sidebar_scroll;
+        GtkWidget *context_menu;
+        GActionGroup *context_group;
 
         /* Each backend gets its own box in the sidebar */
         GHashTable *section_boxes;
+
         /* Each backend is also plugged into one big map */
         GHashTable *backends;
 
-        /* VBox for the sidebar container */
-        GtkWidget *sidebar_wrap;
-        GtkWidget *sidebar_leader;
-
-        /* Top search entry */
-        GtkWidget *search;
-
-        /* Actual applications */
-        GtkWidget *apps;
-        GtkWidget *apps_scroll;
+        /* Acknowledge a single ID "contains" map */
+        GHashTable *item_store;
 
-        /* The current section used in filtering */
-        BriskSection *active_section;
+        /* Control launches */
+        BriskMenuLauncher *launcher;
 
         /* Search term, may be null at any point. Used for filtering */
         gchar *search_term;
 
-        /* Our CSS assets */
-        GtkCssProvider *css;
+        /* The current section used in filtering */
+        BriskSection *active_section;
 
         gboolean filtering;
 
-        /* Whether we have a grab or not */
-        gboolean grabbed;
+        GtkWidget *relative_to;
 
-        /* Whether we're in rollover mode or not */
-        gboolean rollover;
+        /* The widget that contains our backend section boxes */
+        GtkWidget *section_box_holder;
+
+        GtkWidget *section_box_leader;
 
         /* Session management */
         GnomeSessionManager *session;
         MateScreenSaver *saver;
-        GtkWidget *button_lock;
-        GtkWidget *button_logout;
-        GtkWidget *button_shutdown;
-
-        /* Global settings for all BriskMenu instances */
-        GSettings *settings;
-
-        /* Acknowledge a single ID "contains" map */
-        GHashTable *item_store;
-
-        /* Right-click on entry items */
-        GtkWidget *context_menu;
-        GActionGroup *context_group;
+};
 
-        /* Current panel position */
-        GtkPositionType position;
+GtkWidget *brisk_menu_window_get_section_box(BriskMenuWindow *self, BriskBackend *backend);
 
-        /* Current search position */
-        SearchPosition search_position;
-};
+/**
+ * Update internal notion of where the parent panel is on screen
+ */
+void brisk_menu_window_set_parent_position(BriskMenuWindow *window, GtkPositionType position);
+void brisk_menu_window_select_sections(BriskMenuWindow *self);
+GtkWidget *brisk_menu_window_find_first_visible_radio(BriskMenuWindow *self);
 
-/* Split the implementation across multiple files for ease of maintenance */
+/* Loader */
 gboolean brisk_menu_window_load_menus(BriskMenuWindow *self);
 void brisk_menu_window_init_backends(BriskMenuWindow *self);
-void brisk_menu_window_associate_category(BriskMenuWindow *self, GtkWidget *button);
-void brisk_menu_window_select_sidebar(BriskMenuWindow *self);
-
-/* Search */
-void brisk_menu_window_search(BriskMenuWindow *self, GtkEntry *entry);
-gboolean brisk_menu_window_filter_apps(GtkListBoxRow *row, gpointer v);
-void brisk_menu_window_activated(BriskMenuWindow *self, GtkListBoxRow *row, gpointer v);
-void brisk_menu_window_clear_search(GtkEntry *entry, GtkEntryIconPosition pos, GdkEvent *event,
-                                    gpointer v);
+void brisk_menu_window_remove_category(GtkWidget *widget, BriskMenuWindow *self);
 
 /* Sorting */
-gint brisk_menu_window_sort(GtkListBoxRow *row1, GtkListBoxRow *row2, gpointer v);
+gint brisk_menu_window_sort(BriskMenuWindow *self, BriskItem *itemA, BriskItem *itemB);
 
 /* Keyboard */
 gboolean brisk_menu_window_key_press(BriskMenuWindow *self, GdkEvent *event, gpointer v);
 gboolean brisk_menu_window_key_release(BriskMenuWindow *self, GdkEvent *event, gpointer v);
 void brisk_menu_window_update_hotkey(BriskMenuWindow *self, gchar *key);
-void brisk_menu_window_key_activate(BriskMenuWindow *self, gpointer v);
-
-void brisk_menu_window_set_filters_enabled(BriskMenuWindow *self, gboolean enabled);
 
 /* Global grabs */
 void brisk_menu_window_configure_grabs(BriskMenuWindow *self);
 
 /* Session controls */
-void brisk_menu_window_setup_session_controls(BriskMenuWindow *self);
+void brisk_menu_window_logout(BriskMenuWindow *self, gpointer v);
+void brisk_menu_window_shutdown(BriskMenuWindow *self, gpointer v);
+void brisk_menu_window_lock(BriskMenuWindow *self, gpointer v);
 gboolean brisk_menu_window_setup_session(BriskMenuWindow *self);
 
 /* Settings */
 void brisk_menu_window_init_settings(BriskMenuWindow *self);
-void brisk_menu_window_update_search(BriskMenuWindow *self);
 void brisk_menu_window_pump_settings(BriskMenuWindow *self);
 
 /* Context menu */
@@ -151,6 +147,12 @@
                                     BriskMenuEntryButton *button);
 void brisk_menu_window_configure_context(BriskMenuWindow *self);
 
+/* Search */
+void brisk_menu_window_clear_search(GtkEntry *entry, GtkEntryIconPosition pos, GdkEvent *event,
+                                    gpointer v);
+void brisk_menu_window_search(BriskMenuWindow *self, GtkEntry *entry);
+gboolean brisk_menu_window_filter_apps(BriskMenuWindow *self, GtkWidget *child);
+
 DEF_AUTOFREE(GtkWidget, gtk_widget_destroy)
 DEF_AUTOFREE(GSList, g_slist_free)
 DEF_AUTOFREE(GList, g_list_free)
diff -Naur a/src/frontend/menu-search.c b/src/frontend/menu-search.c
--- a/src/frontend/menu-search.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-search.c	2019-11-25 14:46:11.094939153 +0100
@@ -43,7 +43,7 @@
  */
 static void brisk_menu_set_categories_sensitive(BriskMenuWindow *self, gboolean sensitive)
 {
-        brisk_menu_set_checks_sensitive(self->sidebar, sensitive);
+        brisk_menu_set_checks_sensitive(self->section_box_holder, sensitive);
         GHashTableIter iter;
         __attribute__((unused)) gchar *key = NULL;
         GtkWidget *box = NULL;
@@ -56,6 +56,25 @@
 }
 
 /**
+ * brisk_menu_window_filter_section:
+ *
+ * This function will handle filtering the selection based on the active
+ * section, when no search term is applied.
+ *
+ * Returning TRUE means the item should be displayed
+ */
+__brisk_pure__ static gboolean brisk_menu_window_filter_section(BriskMenuWindow *self,
+                                                                BriskItem *item)
+{
+        /* All visible */
+        if (!self->active_section) {
+                return TRUE;
+        }
+
+        return brisk_section_can_show_item(self->active_section, item);
+}
+
+/**
  * brisk_menu_window_clear_search:
  *
  * Simply put, resets the active search term
@@ -99,52 +118,15 @@
         }
 
         /* Now filter again */
-        gtk_list_box_invalidate_filter(GTK_LIST_BOX(self->apps));
-        gtk_list_box_invalidate_sort(GTK_LIST_BOX(self->apps));
-}
-
-/**
- * brisk_menu_window_filter_section:
- *
- * This function will handle filtering the selection based on the active
- * section, when no search term is applied.
- *
- * Returning TRUE means the item should be displayed
- */
-__brisk_pure__ static gboolean brisk_menu_window_filter_section(BriskMenuWindow *self,
-                                                                BriskItem *item)
-{
-        /* All visible */
-        if (!self->active_section) {
-                return TRUE;
-        }
-
-        return brisk_section_can_show_item(self->active_section, item);
+        brisk_menu_window_invalidate_filter(self, NULL);
 }
 
-/**
- * brisk_menu_window_filter_apps:
- *
- * Responsible for filtering the selection based on active group or search
- * term.
- */
-__brisk_pure__ gboolean brisk_menu_window_filter_apps(GtkListBoxRow *row, gpointer v)
+__brisk_pure__ gboolean brisk_menu_window_filter_apps(BriskMenuWindow *self, GtkWidget *child)
 {
-        BriskMenuWindow *self = NULL;
-        BriskItem *item = NULL;
-        GtkWidget *child = NULL;
         const gchar *item_id = NULL;
+        BriskItem *item = NULL;
         GtkWidget *compare_child = NULL;
 
-        self = BRISK_MENU_WINDOW(v);
-
-        if (!self->filtering) {
-                return FALSE;
-        }
-
-        /* Grab our Entry widget */
-        child = gtk_bin_get_child(GTK_BIN(row));
-
         g_object_get(child, "item", &item, NULL);
         if (!item) {
                 return FALSE;
diff -Naur a/src/frontend/menu-session.c b/src/frontend/menu-session.c
--- a/src/frontend/menu-session.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-session.c	2019-11-25 14:46:11.094939153 +0100
@@ -48,7 +48,7 @@
 /**
  * Handle log out
  */
-static void brisk_menu_window_logout(BriskMenuWindow *self, __brisk_unused__ gpointer v)
+void brisk_menu_window_logout(BriskMenuWindow *self, __brisk_unused__ gpointer v)
 {
         gtk_widget_hide(GTK_WIDGET(self));
 
@@ -83,7 +83,7 @@
 /**
  * Handle shut down
  */
-static void brisk_menu_window_shutdown(BriskMenuWindow *self, __brisk_unused__ gpointer v)
+void brisk_menu_window_shutdown(BriskMenuWindow *self, __brisk_unused__ gpointer v)
 {
         gtk_widget_hide(GTK_WIDGET(self));
         g_idle_add((GSourceFunc)brisk_menu_window_shutdown_real, self);
@@ -112,64 +112,12 @@
 /**
  * Handle lock
  */
-static void brisk_menu_window_lock(BriskMenuWindow *self, __brisk_unused__ gpointer v)
+void brisk_menu_window_lock(BriskMenuWindow *self, __brisk_unused__ gpointer v)
 {
         gtk_widget_hide(GTK_WIDGET(self));
         g_idle_add((GSourceFunc)brisk_menu_window_lock_real, self);
 }
 
-/**
- * Create the graphical buttons for session control
- */
-void brisk_menu_window_setup_session_controls(BriskMenuWindow *self)
-{
-        GtkWidget *widget = NULL;
-        GtkWidget *box = NULL;
-        GtkStyleContext *style = NULL;
-
-        box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-        gtk_widget_set_margin_bottom(box, 4);
-
-        gtk_box_pack_end(GTK_BOX(self->sidebar_wrap), box, FALSE, FALSE, 0);
-        gtk_widget_set_halign(box, GTK_ALIGN_CENTER);
-
-        /* Add a separator for visual consistency */
-        widget = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
-        gtk_box_pack_end(GTK_BOX(self->sidebar_wrap), widget, FALSE, FALSE, 3);
-
-        /* Logout */
-        widget = gtk_button_new_from_icon_name("brisk_system-log-out-symbolic", GTK_ICON_SIZE_MENU);
-        self->button_logout = widget;
-        g_signal_connect_swapped(widget, "clicked", G_CALLBACK(brisk_menu_window_logout), self);
-        gtk_widget_set_tooltip_text(widget, _("End the current session"));
-        gtk_widget_set_can_focus(widget, FALSE);
-        gtk_container_add(GTK_CONTAINER(box), widget);
-        style = gtk_widget_get_style_context(widget);
-        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
-
-        /* Lock */
-        widget = gtk_button_new_from_icon_name("system-lock-screen-symbolic",
-                                               GTK_ICON_SIZE_SMALL_TOOLBAR);
-        self->button_lock = widget;
-        g_signal_connect_swapped(widget, "clicked", G_CALLBACK(brisk_menu_window_lock), self);
-        gtk_widget_set_tooltip_text(widget, _("Lock the screen"));
-        gtk_widget_set_can_focus(widget, FALSE);
-        gtk_container_add(GTK_CONTAINER(box), widget);
-        style = gtk_widget_get_style_context(widget);
-        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
-
-        /* Shutdown */
-        widget =
-            gtk_button_new_from_icon_name("system-shutdown-symbolic", GTK_ICON_SIZE_SMALL_TOOLBAR);
-        self->button_shutdown = widget;
-        g_signal_connect_swapped(widget, "clicked", G_CALLBACK(brisk_menu_window_shutdown), self);
-        gtk_widget_set_tooltip_text(widget, _("Turn off the device"));
-        gtk_widget_set_can_focus(widget, FALSE);
-        gtk_container_add(GTK_CONTAINER(box), widget);
-        style = gtk_widget_get_style_context(widget);
-        gtk_style_context_add_class(style, GTK_STYLE_CLASS_FLAT);
-}
-
 gboolean brisk_menu_window_setup_session(BriskMenuWindow *self)
 {
         autofree(GError) *error = NULL;
@@ -188,14 +136,11 @@
                 g_warning("Failed to contact org.gnome.SessionManager: %s\n", error->message);
                 g_error_free(error);
 
-                gtk_widget_set_sensitive(self->button_shutdown, FALSE);
-                gtk_widget_set_sensitive(self->button_logout, FALSE);
                 goto saver_init;
         }
 
         /* Set sensitive according to policy */
         gnome_session_manager_call_can_shutdown_sync(self->session, &can_shutdown, NULL, NULL);
-        gtk_widget_set_sensitive(self->button_shutdown, can_shutdown);
 
 saver_init:
         self->saver =
@@ -207,14 +152,12 @@
                                                      &error);
         if (error) {
                 g_warning("Failed to contact org.mate.ScreenSaver: %s\n", error->message);
-                gtk_widget_set_sensitive(self->button_lock, FALSE);
                 return FALSE;
         }
 
         /* Check the screensaver is *really* running */
         mate_screen_saver_call_get_active_sync(self->saver, &is_active, NULL, &error);
         if (error) {
-                gtk_widget_set_sensitive(self->button_lock, FALSE);
                 g_warning("org.mate.ScreenSaver not running: %s\n", error->message);
         }
         return FALSE;
diff -Naur a/src/frontend/menu-settings.c b/src/frontend/menu-settings.c
--- a/src/frontend/menu-settings.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-settings.c	2019-11-25 14:46:11.094939153 +0100
@@ -65,38 +65,6 @@
         }
 }
 
-/**
- * Update the position of the search bar in accordance with settings
- */
-void brisk_menu_window_update_search(BriskMenuWindow *self)
-{
-        SearchPosition search_position = self->search_position;
-        GtkWidget *layout = NULL;
-        gint n_pos = 0;
-
-        layout = gtk_bin_get_child(GTK_BIN(self));
-
-        if (search_position < SEARCH_POS_MIN || search_position >= SEARCH_POS_MAX) {
-                search_position = SEARCH_POS_AUTOMATIC;
-        }
-
-        switch (search_position) {
-        case SEARCH_POS_AUTOMATIC:
-                /* Top panel, bottom search. Bottom panel, top search */
-                n_pos = self->position == GTK_POS_TOP ? 1 : 0;
-                break;
-        case SEARCH_POS_TOP:
-                n_pos = 0;
-                break;
-        case SEARCH_POS_BOTTOM:
-        default:
-                n_pos = 1;
-                break;
-        }
-
-        gtk_container_child_set(GTK_CONTAINER(layout), self->search, "position", n_pos, NULL);
-}
-
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
  *
diff -Naur a/src/frontend/menu-sort.c b/src/frontend/menu-sort.c
--- a/src/frontend/menu-sort.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-sort.c	2019-11-25 14:46:11.094939153 +0100
@@ -45,23 +45,13 @@
         return score;
 }
 
-__brisk_pure__ gint brisk_menu_window_sort(GtkListBoxRow *row1, GtkListBoxRow *row2, gpointer v)
+__brisk_pure__ gint brisk_menu_window_sort(BriskMenuWindow *self, BriskItem *itemA,
+                                           BriskItem *itemB)
 {
-        GtkWidget *child1, *child2 = NULL;
-        BriskItem *itemA, *itemB = NULL;
         autofree(gchar) *nameA = NULL;
         autofree(gchar) *nameB = NULL;
-        BriskMenuWindow *self = NULL;
         gint sc1 = -1, sc2 = -1;
 
-        self = BRISK_MENU_WINDOW(v);
-
-        child1 = gtk_bin_get_child(GTK_BIN(row1));
-        child2 = gtk_bin_get_child(GTK_BIN(row2));
-
-        g_object_get(child1, "item", &itemA, NULL);
-        g_object_get(child2, "item", &itemB, NULL);
-
         /* Handle normal searching */
         if (self->search_term) {
                 sc1 = brisk_get_entry_score(itemA, self->search_term);
diff -Naur a/src/frontend/menu-window.c b/src/frontend/menu-window.c
--- a/src/frontend/menu-window.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-window.c	2019-11-25 14:46:11.094939153 +0100
@@ -14,26 +14,11 @@
 #include "util.h"
 
 BRISK_BEGIN_PEDANTIC
-#include "category-button.h"
-#include "desktop-button.h"
-#include "entry-button.h"
-#include "launcher.h"
-#include "lib/styles.h"
 #include "menu-private.h"
-#include "menu-window.h"
-#include "sidebar-scroller.h"
-#include <gio/gdesktopappinfo.h>
-#include <glib/gi18n.h>
-#include <gtk/gtk.h>
 BRISK_END_PEDANTIC
 
 G_DEFINE_TYPE(BriskMenuWindow, brisk_menu_window, GTK_TYPE_WINDOW)
 
-static void brisk_menu_window_load_css(BriskMenuWindow *self);
-static void brisk_menu_window_hide(GtkWidget *widget);
-static void brisk_menu_window_add_shortcut(BriskMenuWindow *self, const gchar *id);
-static void brisk_menu_window_build_sidebar(BriskMenuWindow *self);
-
 static void brisk_menu_window_set_property(GObject *object, guint id, const GValue *value,
                                            GParamSpec *spec);
 static void brisk_menu_window_get_property(GObject *object, guint id, GValue *value,
@@ -45,21 +30,6 @@
 };
 
 /**
- * brisk_menu_window_new:
- *
- * Construct a new BriskMenuWindow object
- */
-GtkWidget *brisk_menu_window_new(GtkWidget *relative_to)
-{
-        return g_object_new(BRISK_TYPE_MENU_WINDOW,
-                            "type",
-                            GTK_WINDOW_POPUP,
-                            "relative-to",
-                            relative_to,
-                            NULL);
-}
-
-/**
  * brisk_menu_window_dispose:
  *
  * Clean up a BriskMenuWindow instance
@@ -67,13 +37,6 @@
 static void brisk_menu_window_dispose(GObject *obj)
 {
         BriskMenuWindow *self = BRISK_MENU_WINDOW(obj);
-        GdkScreen *screen = NULL;
-
-        if (self->css) {
-                screen = gtk_widget_get_screen(GTK_WIDGET(self));
-                gtk_style_context_remove_provider_for_screen(screen, GTK_STYLE_PROVIDER(self->css));
-                g_clear_object(&self->css);
-        }
 
         g_clear_object(&self->binder);
         g_clear_pointer(&self->shortcut, g_free);
@@ -99,7 +62,6 @@
 static void brisk_menu_window_class_init(BriskMenuWindowClass *klazz)
 {
         GObjectClass *obj_class = G_OBJECT_CLASS(klazz);
-        GtkWidgetClass *wid_class = GTK_WIDGET_CLASS(klazz);
 
         /* gobject vtable hookup */
         obj_class->dispose = brisk_menu_window_dispose;
@@ -113,9 +75,6 @@
                                  "Owning GtkWidget for this BriskMenuWindow",
                                  G_PARAM_CONSTRUCT | G_PARAM_READWRITE);
         g_object_class_install_properties(obj_class, N_PROPS, obj_properties);
-
-        /* widget vtable */
-        wid_class->hide = brisk_menu_window_hide;
 }
 
 /**
@@ -125,243 +84,83 @@
  */
 static void brisk_menu_window_init(BriskMenuWindow *self)
 {
-        GtkWidget *layout = NULL;
-        GtkWidget *widget = NULL;
-        GtkWidget *content = NULL;
-        GtkWidget *scroll = NULL;
-        GtkStyleContext *style = NULL;
-        autofree(gchar) *txt_holder = NULL;
-        autofree(gchar) *place_holder = NULL;
-
-        self->binder = brisk_key_binder_new();
-        self->launcher = brisk_menu_launcher_new();
-        brisk_menu_window_load_css(self);
-        brisk_menu_window_init_settings(self);
+        gtk_window_set_decorated(GTK_WINDOW(self), FALSE);
+        gtk_window_set_type_hint(GTK_WINDOW(self), GDK_WINDOW_TYPE_HINT_POPUP_MENU);
+        gtk_window_set_skip_pager_hint(GTK_WINDOW(self), TRUE);
+        gtk_window_set_skip_taskbar_hint(GTK_WINDOW(self), TRUE);
 
         /* Initialise main tables */
         self->item_store = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
-        /* brisk_backend_get_id being static const */
         self->section_boxes = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
         self->backends = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_object_unref);
 
-        gtk_window_set_decorated(GTK_WINDOW(self), FALSE);
-        gtk_window_set_type_hint(GTK_WINDOW(self), GDK_WINDOW_TYPE_HINT_POPUP_MENU);
-        gtk_window_set_skip_pager_hint(GTK_WINDOW(self), TRUE);
-        gtk_window_set_skip_taskbar_hint(GTK_WINDOW(self), TRUE);
-        style = gtk_widget_get_style_context(GTK_WIDGET(self));
-        gtk_style_context_add_class(style, BRISK_STYLE_MAIN);
-
-        /* Hook up grabs */
-        brisk_menu_window_configure_grabs(self);
+        self->binder = brisk_key_binder_new();
+        self->launcher = brisk_menu_launcher_new();
 
-        /* Create the main layout (Vertical search/content */
-        layout = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
-        gtk_container_add(GTK_CONTAINER(self), layout);
-
-        /* Create search entry - but not GtkSearchEntry to avoid rounding in themes */
-        widget = gtk_entry_new();
-        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),
-                                          GTK_ENTRY_ICON_PRIMARY,
-                                          "edit-find-symbolic");
-        gtk_entry_set_icon_from_icon_name(GTK_ENTRY(widget),
-                                          GTK_ENTRY_ICON_SECONDARY,
-                                          "edit-clear-symbolic");
-
-        gtk_box_pack_start(GTK_BOX(layout), widget, FALSE, FALSE, 0);
-        /* Translators: This is the text shown in the "search box" with no content */
-        txt_holder = g_strdup_printf("%s\u2026", _("Type to search"));
-        gtk_entry_set_placeholder_text(GTK_ENTRY(widget), txt_holder);
-        self->search = widget;
-        g_signal_connect_swapped(widget, "changed", G_CALLBACK(brisk_menu_window_search), self);
-        g_signal_connect_swapped(widget,
-                                 "activate",
-                                 G_CALLBACK(brisk_menu_window_key_activate),
-                                 self);
-        g_signal_connect(widget, "icon-press", G_CALLBACK(brisk_menu_window_clear_search), self);
-
-        /* Content layout */
-        content = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
-        gtk_box_pack_start(GTK_BOX(layout), content, TRUE, TRUE, 0);
-
-        /* Sidebar for categories */
-        widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
-        scroll = brisk_menu_sidebar_scroller_new();
-        self->sidebar = widget;
-        style = gtk_widget_get_style_context(self->sidebar);
-        gtk_style_context_add_class(style, BRISK_STYLE_SIDEBAR);
-        self->sidebar_scroll = scroll;
-        gtk_container_add(GTK_CONTAINER(scroll), widget);
-
-        /* Create a wrapper for the categories */
-        widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
-        gtk_box_pack_start(GTK_BOX(widget), scroll, TRUE, TRUE, 0);
-        gtk_box_pack_start(GTK_BOX(content), widget, TRUE, TRUE, 0);
-        self->sidebar_wrap = widget;
-
-        /* Scrollbar for apps */
-        scroll = gtk_scrolled_window_new(NULL, NULL);
-        gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(scroll), GTK_SHADOW_IN);
-        gtk_box_pack_start(GTK_BOX(content), scroll, TRUE, TRUE, 0);
-        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
-                                       GTK_POLICY_NEVER,
-                                       GTK_POLICY_AUTOMATIC);
-        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(scroll), FALSE);
-        self->apps_scroll = scroll;
-
-        /* Application launcher display */
-        widget = gtk_list_box_new();
-        gtk_container_add(GTK_CONTAINER(scroll), widget);
-        self->apps = widget;
-        gtk_list_box_set_activate_on_single_click(GTK_LIST_BOX(self->apps), TRUE);
-        gtk_list_box_set_selection_mode(GTK_LIST_BOX(self->apps), GTK_SELECTION_SINGLE);
-        g_signal_connect_swapped(self->apps,
-                                 "row-activated",
-                                 G_CALLBACK(brisk_menu_window_activated),
-                                 self);
-
-        /* Style up the app box */
-        style = gtk_widget_get_style_context(widget);
-        gtk_style_context_add_class(style, BRISK_STYLE_APPS_LIST);
-        gtk_style_context_add_class(style, "view");
-        gtk_style_context_add_class(style, "content-view");
-        gtk_style_context_remove_class(style, "background");
-
-        /* Translators: This message is shown when the search results are empty */
-        place_holder = g_strdup_printf("<big>%s</big>", _("Sorry, no items found"));
-        widget = gtk_label_new(place_holder);
-        /* Add a placeholder when there are no apps for current search term */
-        gtk_label_set_use_markup(GTK_LABEL(widget), TRUE);
-        g_object_set(widget,
-                     "halign",
-                     GTK_ALIGN_CENTER,
-                     "valign",
-                     GTK_ALIGN_START,
-                     "margin",
-                     6,
-                     NULL);
-        style = gtk_widget_get_style_context(widget);
-        gtk_style_context_add_class(style, "dim-label");
-        gtk_list_box_set_placeholder(GTK_LIST_BOX(self->apps), widget);
-        gtk_widget_show_all(widget);
-
-        /* Add session controls */
-        brisk_menu_window_setup_session_controls(self);
-
-        gtk_window_set_default_size(GTK_WINDOW(self), 300, 510);
-        g_object_set(layout, "margin", 3, NULL);
-
-        /* Hook up keyboard events */
-        g_signal_connect(self,
-                         "key-release-event",
-                         G_CALLBACK(brisk_menu_window_key_release),
-                         NULL);
-        g_signal_connect(self, "key-press-event", G_CALLBACK(brisk_menu_window_key_press), NULL);
-
-        brisk_menu_window_build_sidebar(self);
-
-        brisk_menu_window_init_backends(self);
-
-        /* Hook up dbus later on */
-        g_idle_add((GSourceFunc)brisk_menu_window_setup_session, self);
-        /* Start with all content parts "shown" */
-        gtk_widget_show_all(layout);
+        brisk_menu_window_init_settings(self);
 }
 
-/**
- * Fired by clicking a category button
- */
-static void brisk_menu_window_on_toggled(BriskMenuWindow *self, GtkWidget *button)
+static void brisk_menu_window_set_property(GObject *object, guint id, const GValue *value,
+                                           GParamSpec *spec)
 {
-        BriskMenuCategoryButton *cat = NULL;
+        BriskMenuWindow *self = BRISK_MENU_WINDOW(object);
 
-        /* Skip a double signal due to using a group */
-        if (!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button))) {
-                return;
+        switch (id) {
+        case PROP_RELATIVE_TO:
+                self->relative_to = g_value_get_pointer(value);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
         }
-
-        cat = BRISK_MENU_CATEGORY_BUTTON(button);
-        g_object_get(cat, "section", &self->active_section, NULL);
-
-        /* Start the filter. */
-        gtk_list_box_invalidate_filter(GTK_LIST_BOX(self->apps));
-        gtk_list_box_invalidate_sort(GTK_LIST_BOX(self->apps));
 }
 
-/**
- * Fired by entering into the category button with a roll over
- */
-static gboolean brisk_menu_window_on_enter(BriskMenuWindow *self,
-                                           __brisk_unused__ GdkEventCrossing *event,
-                                           GtkWidget *button)
-{
-        GtkToggleButton *but = GTK_TOGGLE_BUTTON(button);
-
-        /* Whether we're in rollover mode */
-        if (!self->rollover) {
-                return GDK_EVENT_PROPAGATE;
-        }
+static void brisk_menu_window_get_property(GObject *object, guint id, GValue *value,
+                                           GParamSpec *spec)
+{
+        BriskMenuWindow *self = BRISK_MENU_WINDOW(object);
 
-        if (gtk_toggle_button_get_active(but) || !gtk_widget_get_visible(button)) {
-                return GDK_EVENT_PROPAGATE;
+        switch (id) {
+        case PROP_RELATIVE_TO:
+                g_value_set_pointer(value, self->relative_to);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
+                break;
         }
-
-        /* Force activation through rollover */
-        gtk_toggle_button_set_active(but, TRUE);
-
-        return GDK_EVENT_PROPAGATE;
 }
 
-/**
- * brisk_menu_window_associate_category:
- *
- * This will hook up the category button for events to enable us to filter the
- * list based on the active category.
- */
-void brisk_menu_window_associate_category(BriskMenuWindow *self, GtkWidget *button)
+void brisk_menu_window_set_parent_position(BriskMenuWindow *self, GtkPositionType position)
 {
-        g_signal_connect_swapped(button, "toggled", G_CALLBACK(brisk_menu_window_on_toggled), self);
-        g_signal_connect_swapped(button,
-                                 "enter-notify-event",
-                                 G_CALLBACK(brisk_menu_window_on_enter),
-                                 self);
+        self->position = position;
+        brisk_menu_window_update_screen_position(self);
+        brisk_menu_window_update_search(self);
 }
 
 /**
- * Load up the CSS assets
+ * brisk_menu_window_select_sidebar:
+ *
+ * Select the first child in the section box holder prior to any kind of display
  */
-static void brisk_menu_window_load_css(BriskMenuWindow *self)
+void brisk_menu_window_select_sections(BriskMenuWindow *self)
 {
-        GtkCssProvider *css = NULL;
-        autofree(GFile) *file = NULL;
-        autofree(GError) *err = NULL;
-        GdkScreen *screen = NULL;
-
-        file = g_file_new_for_uri("resource://com/solus-project/brisk/menu/styling.css");
-        if (!file) {
-                return;
-        }
+        GtkWidget *next_child = NULL;
 
-        css = gtk_css_provider_new();
-        self->css = css;
-        screen = gtk_widget_get_screen(GTK_WIDGET(self));
-        gtk_style_context_add_provider_for_screen(screen,
-                                                  GTK_STYLE_PROVIDER(css),
-                                                  GTK_STYLE_PROVIDER_PRIORITY_FALLBACK);
-
-        if (!gtk_css_provider_load_from_file(css, file, &err)) {
-                g_warning("Failed to load CSS: %s\n", err->message);
-                return;
+        /* Activate the first child in the group after the dummy widget */
+        next_child = brisk_menu_window_find_first_visible_radio(self);
+        if (next_child) {
+                gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(next_child), TRUE);
         }
 }
 
-static GtkWidget *brisk_menu_window_find_first_visible_radio(BriskMenuWindow *self)
+GtkWidget *brisk_menu_window_find_first_visible_radio(BriskMenuWindow *self)
 {
         autofree(GList) *box_kids = NULL;
         autofree(GList) *box_kids2 = NULL;
         GtkWidget *main_box = NULL;
         GList *elem = NULL;
 
-        box_kids = gtk_container_get_children(GTK_CONTAINER(self->sidebar));
+        box_kids = gtk_container_get_children(GTK_CONTAINER(self->section_box_holder));
         for (elem = box_kids; elem; elem = elem->next) {
                 if (!GTK_IS_BOX(elem->data)) {
                         continue;
@@ -377,261 +176,86 @@
 }
 
 /**
- * brisk_menu_window_select_sidebar:
+ * brisk_menu_window_get_id:
  *
- * Select the first child in the sidebar prior to any kind of display
+ * Return the unique ID for the window
+ * @note This string is owned by the window and must not be freed
  */
-void brisk_menu_window_select_sidebar(BriskMenuWindow *self)
+const gchar *brisk_menu_window_get_id(BriskMenuWindow *window)
 {
-        GtkWidget *next_child = NULL;
-
-        /* Activate the first child in the group after the dummy widget */
-        next_child = brisk_menu_window_find_first_visible_radio(self);
-        if (next_child) {
-                gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(next_child), TRUE);
-        }
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->get_id != NULL);
+        return klazz->get_id(window);
 }
 
 /**
- * Override hiding so that we can invalidate all filters
+ * brisk_menu_window_get_display_name:
+ *
+ * Return the display name for the window
+ * @note This string is owned by the window and must not be freed
  */
-static void brisk_menu_window_hide(GtkWidget *widget)
+const gchar *brisk_menu_window_get_display_name(BriskMenuWindow *window)
 {
-        BriskMenuWindow *self = NULL;
-        GtkAdjustment *adjustment = NULL;
-
-        /* Have parent deal with it first */
-        GTK_WIDGET_CLASS(brisk_menu_window_parent_class)->hide(widget);
-
-        self = BRISK_MENU_WINDOW(widget);
-
-        /* Remove search filter */
-        gtk_entry_set_text(GTK_ENTRY(self->search), "");
-
-        brisk_menu_window_select_sidebar(self);
-
-        /* Reset scrollbars */
-        adjustment = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->apps_scroll));
-        gtk_adjustment_set_value(adjustment, 0);
-        adjustment = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->sidebar_scroll));
-        gtk_adjustment_set_value(adjustment, 0);
-
-        /* Unselect any current "apps" */
-        gtk_list_box_select_row(GTK_LIST_BOX(self->apps), NULL);
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->get_display_name != NULL);
+        return klazz->get_display_name(window);
 }
 
 /**
- * Enable or disable the filters between building of the menus
+ * brisk_menu_window_update_screen_position:
+ *
+ * Ask that the menu window updates it's position on screen
  */
-void brisk_menu_window_set_filters_enabled(BriskMenuWindow *self, gboolean enabled)
+void brisk_menu_window_update_screen_position(BriskMenuWindow *window)
 {
-        self->filtering = enabled;
-        if (enabled) {
-                gtk_list_box_set_filter_func(GTK_LIST_BOX(self->apps),
-                                             brisk_menu_window_filter_apps,
-                                             self,
-                                             NULL);
-                gtk_list_box_set_sort_func(GTK_LIST_BOX(self->apps),
-                                           brisk_menu_window_sort,
-                                           self,
-                                           NULL);
-                return;
-        }
-        gtk_list_box_set_filter_func(GTK_LIST_BOX(self->apps), NULL, NULL, NULL);
-        gtk_list_box_set_sort_func(GTK_LIST_BOX(self->apps), NULL, NULL, NULL);
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->add_item != NULL);
+        klazz->update_screen_position(window);
 }
 
-void brisk_menu_window_activated(__brisk_unused__ BriskMenuWindow *self, GtkListBoxRow *row,
-                                 __brisk_unused__ gpointer v)
+void brisk_menu_window_update_search(BriskMenuWindow *window)
 {
-        BriskMenuEntryButton *button = NULL;
-        GtkWidget *child = NULL;
-
-        child = gtk_bin_get_child(GTK_BIN(row));
-        if (!child) {
-                return;
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        if (klazz->update_search) {
+                klazz->update_search(window);
         }
-        if (!BRISK_IS_MENU_ENTRY_BUTTON(child)) {
-                return;
-        }
-        button = BRISK_MENU_ENTRY_BUTTON(child);
-        brisk_menu_entry_button_launch(button);
 }
 
-void brisk_menu_window_set_parent_position(BriskMenuWindow *self, GtkPositionType position)
+void brisk_menu_window_add_item(BriskMenuWindow *window, BriskItem *item, BriskBackend *backend)
 {
-        self->position = position;
-        brisk_menu_window_update_search(self);
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->add_item != NULL);
+        klazz->add_item(window, item, backend);
 }
 
-/**
- * Begin a build of the menu structure
- */
-static void brisk_menu_window_build_sidebar(BriskMenuWindow *self)
+void brisk_menu_window_add_section(BriskMenuWindow *window, BriskSection *section,
+                                   BriskBackend *backend)
 {
-        GtkWidget *sep = NULL;
-        autofree(gstrv) *shortcuts = NULL;
-
-        brisk_menu_window_set_filters_enabled(self, FALSE);
-
-        /* Special leader to control group association, hidden from view */
-        self->sidebar_leader = gtk_radio_button_new(NULL);
-        gtk_box_pack_start(GTK_BOX(self->sidebar), self->sidebar_leader, FALSE, FALSE, 0);
-        gtk_widget_set_no_show_all(self->sidebar_leader, TRUE);
-        gtk_widget_hide(self->sidebar_leader);
-
-        /* Separate the things */
-        sep = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
-        gtk_box_pack_start(GTK_BOX(self->sidebar), sep, FALSE, FALSE, 5);
-        gtk_widget_show_all(sep);
-
-        /* Load the shortcuts up */
-        shortcuts = g_settings_get_strv(self->settings, "pinned-shortcuts");
-        if (!shortcuts) {
-                return;
-        }
-
-        /* Add from gsettings */
-        for (guint i = 0; i < g_strv_length(shortcuts); i++) {
-                brisk_menu_window_add_shortcut(self, shortcuts[i]);
-        }
-
-        brisk_menu_window_set_filters_enabled(self, TRUE);
-}
-
-/**
- * brisk_menu_window_add_shortcut
- *
- * If we can create a .desktop launcher for the given name, add a new button to
- * the sidebar as a quick launch facility.
- */
-static void brisk_menu_window_add_shortcut(BriskMenuWindow *self, const gchar *id)
-{
-        GDesktopAppInfo *info = NULL;
-        GtkWidget *button = NULL;
-
-        info = g_desktop_app_info_new(id);
-        if (!info) {
-                g_message("Not adding missing %s to BriskMenu", id);
-                return;
-        }
-
-        button = brisk_menu_desktop_button_new(self->launcher, G_APP_INFO(info));
-        gtk_widget_show_all(button);
-        gtk_box_pack_start(GTK_BOX(self->sidebar), button, FALSE, FALSE, 1);
-}
-
-static void brisk_menu_window_set_property(GObject *object, guint id, const GValue *value,
-                                           GParamSpec *spec)
-{
-        BriskMenuWindow *self = BRISK_MENU_WINDOW(object);
-
-        switch (id) {
-        case PROP_RELATIVE_TO:
-                self->relative_to = g_value_get_pointer(value);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
-                break;
-        }
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->add_section != NULL);
+        klazz->add_section(window, section, backend);
 }
 
-static void brisk_menu_window_get_property(GObject *object, guint id, GValue *value,
-                                           GParamSpec *spec)
+void brisk_menu_window_invalidate_filter(BriskMenuWindow *window, BriskBackend *backend)
 {
-        BriskMenuWindow *self = BRISK_MENU_WINDOW(object);
-
-        switch (id) {
-        case PROP_RELATIVE_TO:
-                g_value_set_pointer(value, self->relative_to);
-                break;
-        default:
-                G_OBJECT_WARN_INVALID_PROPERTY_ID(object, id, spec);
-                break;
-        }
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->invalidate_filter != NULL);
+        klazz->invalidate_filter(window, backend);
 }
 
-void brisk_menu_window_update_screen_position(BriskMenuWindow *self)
+void brisk_menu_window_reset(BriskMenuWindow *window, BriskBackend *backend)
 {
-        GdkScreen *screen = NULL;
-        GtkAllocation relative_alloc = { 0 };
-        GdkWindow *window = NULL;
-        GdkRectangle geom = { 0 };
-        gint relative_x, relative_y = 0;      /* Real X, Y of the applet, on screen */
-        gint window_width, window_height = 0; /* Window width & height */
-        gint mon = 0;                         /* Monitor to display on */
-        gint window_x, window_y = 0;          /* Target X, Y */
-
-        if (!self->relative_to) {
-                g_warning("Cannot set relative location without relative widget!");
-                return;
-        }
-
-        /* Forcibly realize the applet window */
-        if (!gtk_widget_get_realized(self->relative_to)) {
-                gtk_widget_realize(self->relative_to);
-        }
-
-        /* Forcibly realize ourselves */
-        if (!gtk_widget_get_realized(GTK_WIDGET(self))) {
-                gtk_widget_realize(GTK_WIDGET(self));
-        }
-
-        gtk_widget_get_allocation(self->relative_to, &relative_alloc);
-
-        /* Find out where we are on screen */
-        window = gtk_widget_get_window(self->relative_to);
-        gdk_window_get_origin(window, &relative_x, &relative_y);
-
-        /* Find out the window size */
-        gtk_window_get_size(GTK_WINDOW(self), &window_width, &window_height);
-
-        /* Grab the geometry for the monitor we're currently on */
-        screen = gtk_widget_get_screen(self->relative_to);
-        mon = gdk_screen_get_monitor_at_point(screen, relative_x, relative_y);
-        gdk_screen_get_monitor_geometry(screen, mon, &geom);
-
-        switch (self->position) {
-        case GTK_POS_LEFT:
-                /* Left vertical panel, appear to the RHS of it */
-                window_x = relative_x + relative_alloc.width;
-                window_y = relative_y;
-                break;
-        case GTK_POS_RIGHT:
-                /* Right vertical panel, appear to the LHS of it */
-                window_x = relative_x - window_width;
-                window_y = relative_y;
-                break;
-        case GTK_POS_TOP:
-                /* Top panel, appear below it */
-                window_x = relative_x;
-                window_y = relative_y + relative_alloc.height;
-                break;
-        case GTK_POS_BOTTOM:
-        default:
-                /* Bottom panel, appear above it */
-                window_x = relative_x;
-                window_y = relative_y - window_height;
-                break;
-        }
-
-        /* Bound the right side */
-        if (window_x + window_width > (geom.x + geom.width)) {
-                window_x = (geom.x + geom.width) - window_width;
-                if (self->position == GTK_POS_RIGHT) {
-                        window_x -= relative_alloc.width;
-                }
-        }
-
-        /* Bound the left side */
-        if (window_x < geom.x) {
-                window_x = geom.x;
-                if (self->position == GTK_POS_LEFT) {
-                        window_x -= relative_alloc.width;
-                }
-        }
-
-        gtk_window_move(GTK_WINDOW(self), window_x, window_y);
+        g_assert(window != NULL);
+        BriskMenuWindowClass *klazz = BRISK_MENU_WINDOW_GET_CLASS(window);
+        g_assert(klazz->reset != NULL);
+        klazz->reset(window, backend);
 }
 
 /*
diff -Naur a/src/frontend/menu-window.h b/src/frontend/menu-window.h
--- a/src/frontend/menu-window.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/menu-window.h	2019-11-25 14:46:11.094939153 +0100
@@ -29,19 +29,17 @@
 #define BRISK_MENU_WINDOW_GET_CLASS(o)                                                             \
         (G_TYPE_INSTANCE_GET_CLASS((o), BRISK_TYPE_MENU_WINDOW, BriskMenuWindowClass))
 
-GtkWidget *brisk_menu_window_new(GtkWidget *relative_to);
-
 GType brisk_menu_window_get_type(void);
 
-/**
- * Update internal notion of where the parent panel is on screen
- */
-void brisk_menu_window_set_parent_position(BriskMenuWindow *window, GtkPositionType position);
-
-/**
- * Ask that the menu window updates it's position on screen
- */
+const gchar *brisk_menu_window_get_id(BriskMenuWindow *window);
+const gchar *brisk_menu_window_get_display_name(BriskMenuWindow *window);
 void brisk_menu_window_update_screen_position(BriskMenuWindow *window);
+void brisk_menu_window_update_search(BriskMenuWindow *window);
+void brisk_menu_window_invalidate_filter(BriskMenuWindow *self, BriskBackend *backend);
+void brisk_menu_window_add_item(BriskMenuWindow *window, BriskItem *item, BriskBackend *backend);
+void brisk_menu_window_add_section(BriskMenuWindow *window, BriskSection *section,
+                                   BriskBackend *backend);
+void brisk_menu_window_reset(BriskMenuWindow *window, BriskBackend *backend);
 
 G_END_DECLS
 
diff -Naur a/src/frontend/meson.build b/src/frontend/meson.build
--- a/src/frontend/meson.build	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/meson.build	2019-11-25 14:46:11.094939153 +0100
@@ -1,18 +1,24 @@
 libfrontend_sources = [
-    'category-button.c',
-    'desktop-button.c',
     'entry-button.c',
     'launcher.c',
     'menu-context.c',
     'menu-grabs.c',
     'menu-keyboard.c',
     'menu-loader.c',
+    'menu-loader.c',
     'menu-search.c',
     'menu-session.c',
     'menu-settings.c',
     'menu-sort.c',
     'menu-window.c',
-    'sidebar-scroller.c',
+    'classic/category-button.c',
+    'classic/classic-entry-button.c',
+    'classic/classic-window.c',
+    'classic/desktop-button.c',
+    'classic/sidebar-scroller.c',
+    'dash/category-button.c',
+    'dash/dash-entry-button.c',
+    'dash/dash-window.c',
 ]
 
 libfrontend_dependencies = [
@@ -24,6 +30,7 @@
 
 libfrontend_includes = [
     include_directories('.'),
+    include_directories('../../data'),
 ]
 
 # Contains the main Brisk UI (Windowed)
diff -Naur a/src/frontend/sidebar-scroller.c b/src/frontend/sidebar-scroller.c
--- a/src/frontend/sidebar-scroller.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/sidebar-scroller.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/*
- * This file is part of brisk-menu.
- *
- * Copyright © 2017 Brisk Menu Developers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#define _GNU_SOURCE
-
-#include "util.h"
-
-BRISK_BEGIN_PEDANTIC
-#include "sidebar-scroller.h"
-#include <gtk/gtk.h>
-
-BRISK_END_PEDANTIC
-
-struct _BriskMenuSidebarScrollerClass {
-        GtkScrolledWindowClass parent_class;
-};
-
-struct _BriskMenuSidebarScroller {
-        GtkScrolledWindow parent;
-};
-
-G_DEFINE_TYPE(BriskMenuSidebarScroller, brisk_menu_sidebar_scroller, GTK_TYPE_SCROLLED_WINDOW)
-
-static void brisk_menu_sidebar_scroller_get_preferred_height(GtkWidget *widget, gint *min_height,
-                                                             gint *nat_height);
-
-/**
- * brisk_menu_sidebar_scroller_new:
- *
- * Construct a new BriskMenuSidebarScroller object
- */
-GtkWidget *brisk_menu_sidebar_scroller_new()
-{
-        return g_object_new(BRISK_TYPE_MENU_SIDEBAR_SCROLLER,
-                            "hadjustment",
-                            NULL,
-                            "vadjustment",
-                            NULL,
-                            NULL);
-}
-
-/**
- * brisk_menu_sidebar_scroller_class_init:
- *
- * Handle class initialisation
- */
-static void brisk_menu_sidebar_scroller_class_init(BriskMenuSidebarScrollerClass *klazz)
-{
-        GtkWidgetClass *wid_class = GTK_WIDGET_CLASS(klazz);
-        wid_class->get_preferred_height = brisk_menu_sidebar_scroller_get_preferred_height;
-}
-
-/**
- * brisk_menu_sidebar_scroller_init:
- *
- * Handle construction of the BriskMenuEntryButton
- */
-static void brisk_menu_sidebar_scroller_init(BriskMenuSidebarScroller *self)
-{
-        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(self),
-                                       GTK_POLICY_NEVER,
-                                       GTK_POLICY_AUTOMATIC);
-        gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(self), FALSE);
-}
-
-static void brisk_menu_sidebar_scroller_get_preferred_height(GtkWidget *widget, gint *min_height,
-                                                             gint *nat_height)
-{
-        GdkScreen *screen = NULL;
-        GdkWindow *window = NULL;
-        GdkRectangle geom = { 0 };
-        gint applet_x, applet_y = 0;
-        gint mon = 0;
-
-        /* Find out where we are on screen */
-        window = gtk_widget_get_window(widget);
-        gdk_window_get_origin(window, &applet_x, &applet_y);
-
-        /* Grab the geometry for the monitor we're currently on */
-        screen = gtk_widget_get_screen(widget);
-        mon = gdk_screen_get_monitor_at_point(screen, applet_x, applet_y);
-        gdk_screen_get_monitor_geometry(screen, mon, &geom);
-
-        gint max_height = geom.height - 200;
-
-        GtkBin *bin = NULL;
-        GtkWidget *child = NULL;
-
-        bin = GTK_BIN(widget);
-        child = gtk_bin_get_child(bin);
-
-        if (child) {
-                gtk_widget_get_preferred_height(child, min_height, nat_height);
-                *min_height = MIN(max_height, *min_height);
-                *nat_height = MIN(max_height, *nat_height);
-        } else {
-                *min_height = *nat_height = 0;
-        }
-}
-
-/*
- * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
- *
- * Local variables:
- * c-basic-offset: 8
- * tab-width: 8
- * indent-tabs-mode: nil
- * End:
- *
- * vi: set shiftwidth=8 tabstop=8 expandtab:
- * :indentSize=8:tabSize=8:noTabs=true:
- */
diff -Naur a/src/frontend/sidebar-scroller.h b/src/frontend/sidebar-scroller.h
--- a/src/frontend/sidebar-scroller.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/frontend/sidebar-scroller.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-/*
- * This file is part of brisk-menu.
- *
- * Copyright © 2017 Brisk Menu Developers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#pragma once
-
-#include <glib-object.h>
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-typedef struct _BriskMenuSidebarScroller BriskMenuSidebarScroller;
-typedef struct _BriskMenuSidebarScrollerClass BriskMenuSidebarScrollerClass;
-
-#define BRISK_TYPE_MENU_SIDEBAR_SCROLLER brisk_menu_sidebar_scroller_get_type()
-#define BRISK_MENU_SIDEBAR_SCROLLER(o)                                                             \
-        (G_TYPE_CHECK_INSTANCE_CAST((o),                                                           \
-                                    BRISK_TYPE_MENU_SIDEBAR_SCROLLER,                              \
-                                    BriskMenuSidebarScroller))
-#define BRISK_IS_MENU_SIDEBAR_SCROLLER(o)                                                          \
-        (G_TYPE_CHECK_INSTANCE_TYPE((o), BRISK_TYPE_MENU_SIDEBAR_SCROLLER))
-#define BRISK_MENU_SIDEBAR_SCROLLER_CLASS(o)                                                       \
-        (G_TYPE_CHECK_CLASS_CAST((o),                                                              \
-                                 BRISK_TYPE_MENU_SIDEBAR_SCROLLER,                                 \
-                                 BriskMenuSidebarScrollerClass))
-#define BRISK_IS_MENU_SIDEBAR_SCROLLER_CLASS(o)                                                    \
-        (G_TYPE_CHECK_CLASS_TYPE((o), BRISK_TYPE_MENU_SIDEBAR_SCROLLER))
-#define BRISK_MENU_SIDEBAR_SCROLLER_GET_CLASS(o)                                                   \
-        (G_TYPE_INSTANCE_GET_CLASS((o),                                                            \
-                                   BRISK_TYPE_MENU_SIDEBAR_SCROLLER,                               \
-                                   BriskMenuSidebarScrollerClass))
-
-/**
- * Construct a new BriskMenuSidebarScroller
- */
-GtkWidget *brisk_menu_sidebar_scroller_new(void);
-
-GType brisk_menu_sidebar_scroller_get_type(void);
-
-G_END_DECLS
-
-/*
- * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
- *
- * Local variables:
- * c-basic-offset: 8
- * tab-width: 8
- * indent-tabs-mode: nil
- * End:
- *
- * vi: set shiftwidth=8 tabstop=8 expandtab:
- * :indentSize=8:tabSize=8:noTabs=true:
- */
diff -Naur a/src/lib/authors.h b/src/lib/authors.h
--- a/src/lib/authors.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/lib/authors.h	2019-11-25 14:46:11.094939153 +0100
@@ -6,6 +6,7 @@
         "Federico Damián Schonborn <federicodamiansch@gmail.com>",
         "Ikey Doherty <ikey@solus-project.com>",
         "Martin Wimpress <code@flexion.org>",
+        "Stefan Ric <stefan@solus-project.com>",
         "Stefan Ric <stfric369@gmail.com>",
         "Victor Kareh <vkareh@vkareh.net>",
         NULL,
diff -Naur a/src/lib/key-binder.c b/src/lib/key-binder.c
--- a/src/lib/key-binder.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/lib/key-binder.c	2019-11-25 14:46:11.094939153 +0100
@@ -168,30 +168,27 @@
 
         /* Find a matching binding */
         while (g_hash_table_iter_next(&iter, (void **)&key, (void **)&binding)) {
-                /* capture initial key press */
-                if (xev->xkey.keycode == binding->keycode && xev->type == KeyPress &&
+                if (xev->type == KeyPress && xev->xkey.keycode == binding->keycode &&
                     !self->wait_for_release) {
+                        /* capture initial key press */
                         if (mods == binding->mods) {
                                 self->wait_for_release = TRUE;
-                                XAllowEvents(display, AsyncKeyboard, xev->xkey.time);
                         }
-                } else if (xev->xkey.keycode == binding->keycode && self->wait_for_release) {
+                } else if (xev->type == KeyRelease && xev->xkey.keycode == binding->keycode &&
+                           self->wait_for_release) {
                         /* capture release within same shortcut sequence */
-                        if (xev->type == KeyRelease) {
-                                self->wait_for_release = FALSE;
-                                binding->func(event, binding->udata);
-                        }
-                        XAllowEvents(display, AsyncKeyboard, xev->xkey.time);
+                        binding->func(event, binding->udata);
+                        self->wait_for_release = FALSE;
                 } else {
+                        XUngrabKeyboard(display, xev->xkey.time);
                         /* when breaking the shortcut sequence, send the event up the window
                          * hierarchy in case it's part of a different shortcut sequence
                          * (e.g. <Mod4>a) */
                         XSendEvent(display,
-                                   GDK_WINDOW_XID(self->root_window),
+                                   xev->xkey.window,
                                    TRUE,
                                    KeyPressMask | KeyReleaseMask,
                                    xev);
-                        XAllowEvents(display, ReplayKeyboard, xev->xkey.time);
                         self->wait_for_release = FALSE;
                 }
         }
diff -Naur a/src/lib/styles.h b/src/lib/styles.h
--- a/src/lib/styles.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/lib/styles.h	2019-11-25 14:46:11.094939153 +0100
@@ -34,6 +34,11 @@
  */
 #define BRISK_STYLE_BUTTON_VERTICAL "brisk-button-vertical"
 
+/**
+ * This is a dash window
+ */
+#define BRISK_STYLE_DASH "brisk-dash"
+
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
  *
diff -Naur a/src/mate-applet/applet.c b/src/mate-applet/applet.c
--- a/src/mate-applet/applet.c	2017-11-02 20:16:40.000000000 +0100
+++ b/src/mate-applet/applet.c	2019-11-25 14:46:11.098939210 +0100
@@ -16,8 +16,8 @@
 
 BRISK_BEGIN_PEDANTIC
 #include "applet.h"
-#include "frontend/menu-private.h"
-#include "frontend/menu-window.h"
+#include "frontend/classic/classic-window.h"
+#include "frontend/dash/dash-window.h"
 #include "lib/authors.h"
 #include "lib/styles.h"
 #include <gio/gdesktopappinfo.h>
@@ -40,6 +40,9 @@
 static void brisk_menu_applet_change_size(MatePanelApplet *applet, guint size);
 static void brisk_menu_applet_change_menu_orient(BriskMenuApplet *self);
 
+static gboolean brisk_menu_applet_startup(BriskMenuApplet *self);
+static void brisk_menu_applet_create_window(BriskMenuApplet *self);
+
 /* Handle applet settings */
 void brisk_menu_applet_init_settings(BriskMenuApplet *self);
 static void brisk_menu_applet_settings_changed(GSettings *settings, const gchar *key, gpointer v);
@@ -48,6 +51,7 @@
 /* Helpers */
 static GtkPositionType convert_mate_position(MatePanelAppletOrient orient);
 static void brisk_menu_applet_adapt_layout(BriskMenuApplet *self);
+static GtkWidget *brisk_menu_applet_automatic_window_type(BriskMenuApplet *self);
 
 /**
  * brisk_menu_applet_dispose:
@@ -107,7 +111,7 @@
  */
 static void brisk_menu_applet_init(BriskMenuApplet *self)
 {
-        GtkWidget *toggle, *layout, *image, *label, *menu = NULL;
+        GtkWidget *toggle, *layout, *image, *label = NULL;
         GtkStyleContext *style = NULL;
 
         brisk_menu_applet_init_settings(self);
@@ -160,22 +164,48 @@
         mate_panel_applet_set_flags(MATE_PANEL_APPLET(self), MATE_PANEL_APPLET_EXPAND_MINOR);
         mate_panel_applet_set_background_widget(MATE_PANEL_APPLET(self), GTK_WIDGET(self));
 
+        /* Wait for mate-panel to do its thing and tell us the orientation */
+        g_idle_add((GSourceFunc)brisk_menu_applet_startup, self);
+}
+
+static gboolean brisk_menu_applet_startup(BriskMenuApplet *self)
+{
+        /* Ensure we fire off the initial layout adaptation code */
+        brisk_menu_applet_change_orient(MATE_PANEL_APPLET(self),
+                                        mate_panel_applet_get_orient(MATE_PANEL_APPLET(self)));
+
+        return G_SOURCE_REMOVE;
+}
+
+static void brisk_menu_applet_create_window(BriskMenuApplet *self)
+{
+        GtkWidget *menu = NULL;
+
         /* Now show all content */
-        gtk_widget_show_all(toggle);
+        gtk_widget_show_all(self->toggle);
 
         /* Construct our menu */
-        menu = brisk_menu_window_new(GTK_WIDGET(self));
+        WindowType window_type = g_settings_get_enum(self->settings, "window-type");
+        switch (window_type) {
+        case WINDOW_TYPE_DASH:
+                menu = GTK_WIDGET(brisk_dash_window_new(GTK_WIDGET(self)));
+                break;
+        case WINDOW_TYPE_AUTOMATIC:
+                menu = brisk_menu_applet_automatic_window_type(self);
+                break;
+        case WINDOW_TYPE_CLASSIC:
+        default:
+                menu = GTK_WIDGET(brisk_classic_window_new(GTK_WIDGET(self)));
+                break;
+        }
+
         self->menu = menu;
 
         /* Render "active" toggle only when the window is open, automatically. */
-        g_object_bind_property(menu, "visible", toggle, "active", G_BINDING_DEFAULT);
-
-        /* Load initially in the idle loop, prevent lagging panel on startup */
-        g_idle_add((GSourceFunc)brisk_menu_window_load_menus, self->menu);
+        g_object_bind_property(menu, "visible", self->toggle, "active", G_BINDING_DEFAULT);
 
-        /* Ensure we fire off the initial layout adaptation code */
-        brisk_menu_applet_change_orient(MATE_PANEL_APPLET(self),
-                                        mate_panel_applet_get_orient(MATE_PANEL_APPLET(self)));
+        /* Load our menus */
+        brisk_menu_window_load_menus(BRISK_MENU_WINDOW(self->menu));
 
         /* Pump the settings */
         brisk_menu_window_pump_settings(BRISK_MENU_WINDOW(self->menu));
@@ -240,11 +270,15 @@
 {
         BriskMenuApplet *self = BRISK_MENU_APPLET(applet);
         self->orient = orient;
-
-        brisk_menu_applet_change_menu_orient(self);
-
         /* Now adjust our own display to deal with the orientation */
         brisk_menu_applet_adapt_layout(BRISK_MENU_APPLET(applet));
+
+        if (!self->menu) {
+                brisk_menu_applet_create_window(self);
+                return;
+        }
+
+        brisk_menu_applet_change_menu_orient(self);
 }
 
 static void brisk_menu_applet_change_size(MatePanelApplet *applet, guint size)
@@ -325,7 +359,7 @@
 void brisk_menu_applet_show_about(__brisk_unused__ GtkAction *action,
                                   __brisk_unused__ BriskMenuApplet *applet)
 {
-        static const gchar *copyright_string = "Copyright © 2016-2017 Brisk Menu Developers";
+        static const gchar *copyright_string = "Copyright © 2016-2018 Brisk Menu Developers";
         gtk_show_about_dialog(NULL,
                               "authors",
                               brisk_developers,
@@ -398,6 +432,17 @@
                 break;
         }
 }
+
+static GtkWidget *brisk_menu_applet_automatic_window_type(BriskMenuApplet *self)
+{
+        switch (self->orient) {
+        case MATE_PANEL_APPLET_ORIENT_LEFT:
+        case MATE_PANEL_APPLET_ORIENT_RIGHT:
+                return GTK_WIDGET(brisk_dash_window_new(GTK_WIDGET(self)));
+        default:
+                return GTK_WIDGET(brisk_classic_window_new(GTK_WIDGET(self)));
+        }
+}
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
  *
diff -Naur a/src/mate-applet/applet.h b/src/mate-applet/applet.h
--- a/src/mate-applet/applet.h	2017-11-02 20:16:40.000000000 +0100
+++ b/src/mate-applet/applet.h	2019-11-25 14:46:11.098939210 +0100
@@ -20,6 +20,14 @@
 typedef struct _BriskMenuApplet BriskMenuApplet;
 typedef struct _BriskMenuAppletClass BriskMenuAppletClass;
 
+typedef enum {
+        WINDOW_TYPE_MIN = 0,
+        WINDOW_TYPE_CLASSIC = 1 << 0,
+        WINDOW_TYPE_DASH = 1 << 1,
+        WINDOW_TYPE_AUTOMATIC = 1 << 2,
+        WINDOW_TYPE_MAX,
+} WindowType;
+
 struct _BriskMenuAppletClass {
         MatePanelAppletClass parent_class;
 };
diff -Naur a/src/meson.build b/src/meson.build
--- a/src/meson.build	2017-11-02 20:16:40.000000000 +0100
+++ b/src/meson.build	2019-11-25 14:46:11.098939210 +0100
@@ -18,15 +18,40 @@
     ],
 )
 
+# Build the Cs into a simple static library and control compiler noise
+libsession_stub = static_library(
+    'brisk-glue',
+    sources: [
+        libsaver_glue,
+        libsession_glue,
+    ],
+    c_args: [
+        '-Wno-unused-parameter',
+    ],
+    dependencies: dep_gio_unix,
+    install: false,
+    include_directories: [
+        include_directories('..'),
+    ],
+)
+
+# Allow linking to the stub
+link_libsession_stub = declare_dependency(
+    link_with: libsession_stub,
+    dependencies: [
+        dep_gio_unix,
+    ],
+    include_directories: [
+        include_directories('.'),
+    ],
+)
+
 # Build common library (currently just keybinder really.)
 subdir('lib')
 
 # Build the backend component
 subdir('backend')
 
-# Build session glue to help the frontend out
-subdir('session')
-
 # Now build our main UI
 subdir('frontend')
 
diff -Naur a/src/session/meson.build b/src/session/meson.build
--- a/src/session/meson.build	2017-11-02 20:16:40.000000000 +0100
+++ b/src/session/meson.build	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-# libsaver_glue provides dbus code for the MATE screensaver
-libsaver_glue = gnome.gdbus_codegen(
-    'libsaver-glue',
-    'org.mate.ScreenSaver.xml',
-    interface_prefix : 'org.mate.',
-    namespace : 'Mate',
-)
-
-# libsession_glue provides dbus code for the MATE/GNOME session
-libsession_glue = gnome.gdbus_codegen(
-    'libsession-glue',
-    'org.gnome.SessionManager.xml',
-    interface_prefix : 'org.gnome.',
-    namespace : 'Gnome',
-)
-
-# Build the Cs into a simple static library and control compiler noise
-libsession_stub = static_library(
-    'brisk-glue',
-    sources: [
-        libsaver_glue,
-        libsession_glue,
-    ],
-    c_args: [
-        '-Wno-unused-parameter',
-    ],
-    dependencies: dep_gio_unix,
-    install: false,
-)
-
-# Allow linking to the stub
-link_libsession_stub = declare_dependency(
-    link_with: libsession_stub,
-    dependencies: [
-        dep_gio_unix,
-    ],
-    include_directories: [
-        include_directories('.'),
-    ],
-)
diff -Naur a/src/session/org.gnome.SessionManager.xml b/src/session/org.gnome.SessionManager.xml
--- a/src/session/org.gnome.SessionManager.xml	2017-11-02 20:16:40.000000000 +0100
+++ b/src/session/org.gnome.SessionManager.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
-                      "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<!-- GDBus 2.48.1 -->
-<node>
-  <interface name="org.gnome.SessionManager">
-    <method name="Shutdown"/>
-    <method name="Reboot"/>
-    <method name="CanShutdown">
-      <arg type="b" name="is_available" direction="out"/>
-    </method>
-    <method name="Logout">
-      <arg type="u" name="mode" direction="in"/>
-    </method>
-  </interface>
-</node>
diff -Naur a/src/session/org.mate.ScreenSaver.xml b/src/session/org.mate.ScreenSaver.xml
--- a/src/session/org.mate.ScreenSaver.xml	2017-11-02 20:16:40.000000000 +0100
+++ b/src/session/org.mate.ScreenSaver.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
-"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
-<node>
-  <interface name="org.mate.ScreenSaver">
-    <method name="Lock">
-    </method>
-    <method name="GetActive">
-      <arg name="value" direction="out" type="b"/>
-    </method>
-  </interface>
-</node>
