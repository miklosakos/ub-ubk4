From 69b9b9bb001b1d1ef14c2c6e2e9d9c87f9fcd9d7 Mon Sep 17 00:00:00 2001
From: Kai KÃ¶hne <kai.koehne@qt.io>
Date: Wed, 25 Aug 2021 08:17:35 +0200
Subject: [PATCH] Do not translate Qt Linguist command line tools

The Linguist CLI tools were the only ones in Qt that were translated at
all, so this commit improves consistency. Additionally, the translations
weren't even shown in bootstrapped Windows builds due to missing codec
support, which would be required for console code page adaptation.

This commit also has the nice side effect of avoiding a crash in non-
prefix builds, presumably because lrelease overwrote the .qm file it had
currently memory-mapped.

Fixes: QTBUG-95975
Change-Id: I26acf86c7be338b407225d4a08959fd9c44ec762
Reviewed-by: Oswald Buddenhagen <oswald.buddenhagen@gmx.de>
Reviewed-by: Kai Koehne <kai.koehne@qt.io>
(cherry picked from commit 9f06d5917010c12e80e2edbba97f8c6c3e25680c)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---

diff --git a/qttools/src/linguist/lconvert/main.cpp b/qttools/src/linguist/lconvert/main.cpp
index 816453b..d7381d0 100644
--- a/qttools/src/linguist/lconvert/main.cpp
+++ b/qttools/src/linguist/lconvert/main.cpp
@@ -39,10 +39,6 @@
 
 QT_USE_NAMESPACE
 
-class LC {
-    Q_DECLARE_TR_FUNCTIONS(LConvert)
-};
-
 static int usage(const QStringList &args)
 {
     Q_UNUSED(args);
@@ -52,7 +48,7 @@
     for (const Translator::FileFormat &format : qAsConst(Translator::registeredFileFormats()))
         loaders += line.arg(format.extension, -5).arg(format.description());
 
-    std::cout << qPrintable(LC::tr("\nUsage:\n"
+    std::cout << qPrintable(QStringLiteral("\nUsage:\n"
         "    lconvert [options] <infile> [<infile>...]\n\n"
         "lconvert is part of Qt's Linguist tool chain. It can be used as a\n"
         "stand-alone tool to convert and filter translation data files.\n"
diff --git a/qttools/src/linguist/lprodump/main.cpp b/qttools/src/linguist/lprodump/main.cpp
index d1d4f60..eed1e70 100644
--- a/qttools/src/linguist/lprodump/main.cpp
+++ b/qttools/src/linguist/lprodump/main.cpp
@@ -80,34 +80,30 @@
     obj[QLatin1String(key)] = toJsonValue(value);
 }
 
-class LD {
-    Q_DECLARE_TR_FUNCTIONS(LProDump)
-};
-
 static void printUsage()
 {
-    printOut(LD::tr(
-        "Usage:\n"
-        "    lprodump [options] project-file...\n"
-        "lprodump is part of Qt's Linguist tool chain. It extracts information\n"
-        "from qmake projects to a .json file. This file can be passed to\n"
-        "lupdate/lrelease using the -project option.\n\n"
-        "Options:\n"
-        "    -help  Display this information and exit.\n"
-        "    -silent\n"
-        "           Do not explain what is being done.\n"
-        "    -pro <filename>\n"
-        "           Name of a .pro file. Useful for files with .pro file syntax but\n"
-        "           different file suffix. Projects are recursed into and merged.\n"
-        "    -pro-out <directory>\n"
-        "           Virtual output directory for processing subsequent .pro files.\n"
-        "    -pro-debug\n"
-        "           Trace processing .pro files. Specify twice for more verbosity.\n"
-        "    -out <filename>\n"
-        "           Name of the output file.\n"
-        "    -version\n"
-        "           Display the version of lprodump and exit.\n"
-    ));
+    printOut(uR"(Usage:
+    lprodump [options] project-file...
+lprodump is part of Qt's Linguist tool chain. It extracts information
+from qmake projects to a .json file. This file can be passed to
+lupdate/lrelease using the -project option.
+
+Options:
+    -help  Display this information and exit.
+    -silent
+           Do not explain what is being done.
+    -pro <filename>
+           Name of a .pro file. Useful for files with .pro file syntax but
+           different file suffix. Projects are recursed into and merged.
+    -pro-out <directory>
+           Virtual output directory for processing subsequent .pro files.
+    -pro-debug
+           Trace processing .pro files. Specify twice for more verbosity.
+    -out <filename>
+           Name of the output file.
+    -version
+           Display the version of lprodump and exit.
+)"_qs);
 }
 
 static void print(const QString &fileName, int lineNo, const QString &msg)
@@ -160,12 +156,12 @@
     QString errStr;
     if (vfs->readFile(vfs->idForFileName(resourceFile, QMakeVfs::VfsCumulative),
                       &content, &errStr) != QMakeVfs::ReadOk) {
-        printErr(LD::tr("lprodump error: Cannot read %1: %2\n").arg(resourceFile, errStr));
+        printErr(QStringLiteral("lprodump error: Cannot read %1: %2\n").arg(resourceFile, errStr));
         return QStringList();
     }
     const ReadQrcResult rqr = readQrcFile(resourceFile, content);
     if (rqr.hasError()) {
-        printErr(LD::tr("lprodump error: %1:%2: %3\n")
+        printErr(QStringLiteral("lprodump error: %1:%2: %3\n")
                  .arg(resourceFile, QString::number(rqr.line), rqr.errorString));
     }
     return rqr.files;
@@ -388,7 +384,7 @@
         } else if (arg == QLatin1String("-out")) {
             ++i;
             if (i == argc) {
-                printErr(LD::tr("The option -out requires a parameter.\n"));
+                printErr(u"The option -out requires a parameter.\n"_qs);
                 return 1;
             }
             outputFilePath = args[i];
@@ -397,12 +393,12 @@
         } else if (arg == QLatin1String("-pro-debug")) {
             proDebug++;
         } else if (arg == QLatin1String("-version")) {
-            printOut(LD::tr("lprodump version %1\n").arg(QLatin1String(QT_VERSION_STR)));
+            printOut(QStringLiteral("lprodump version %1\n").arg(QLatin1String(QT_VERSION_STR)));
             return 0;
         } else if (arg == QLatin1String("-pro")) {
             ++i;
             if (i == argc) {
-                printErr(LD::tr("The -pro option should be followed by a filename of .pro file.\n"));
+                printErr(QStringLiteral("The -pro option should be followed by a filename of .pro file.\n"));
                 return 1;
             }
             QString file = QDir::cleanPath(QFileInfo(args[i]).absoluteFilePath());
@@ -411,21 +407,21 @@
         } else if (arg == QLatin1String("-pro-out")) {
             ++i;
             if (i == argc) {
-                printErr(LD::tr("The -pro-out option should be followed by a directory name.\n"));
+                printErr(QStringLiteral("The -pro-out option should be followed by a directory name.\n"));
                 return 1;
             }
             outDir = QDir::cleanPath(QFileInfo(args[i]).absoluteFilePath());
         } else if (arg.startsWith(QLatin1String("-")) && arg != QLatin1String("-")) {
-            printErr(LD::tr("Unrecognized option '%1'.\n").arg(arg));
+            printErr(QStringLiteral("Unrecognized option '%1'.\n").arg(arg));
             return 1;
         } else {
             QFileInfo fi(arg);
             if (!fi.exists()) {
-                printErr(LD::tr("lprodump error: File '%1' does not exist.\n").arg(arg));
+                printErr(QStringLiteral("lprodump error: File '%1' does not exist.\n").arg(arg));
                 return 1;
             }
             if (!isProOrPriFile(arg)) {
-                printErr(LD::tr("lprodump error: '%1' is neither a .pro nor a .pri file.\n")
+                printErr(QStringLiteral("lprodump error: '%1' is neither a .pro nor a .pri file.\n")
                          .arg(arg));
                 return 1;
             }
@@ -465,7 +461,7 @@
     } else {
         QFile f(outputFilePath);
         if (!f.open(QIODevice::WriteOnly)) {
-            printErr(LD::tr("lprodump error: Cannot open %1 for writing.\n").arg(outputFilePath));
+            printErr(QStringLiteral("lprodump error: Cannot open %1 for writing.\n").arg(outputFilePath));
             return 1;
         }
         f.write(output);
diff --git a/qttools/src/linguist/lrelease-pro/main.cpp b/qttools/src/linguist/lrelease-pro/main.cpp
index bd20eea..31c660c 100644
--- a/qttools/src/linguist/lrelease-pro/main.cpp
+++ b/qttools/src/linguist/lrelease-pro/main.cpp
@@ -38,19 +38,6 @@
 
 QT_USE_NAMESPACE
 
-#ifdef QT_BOOTSTRAPPED
-struct LR {
-    static inline QString tr(const char *sourceText, const char *comment = 0)
-    {
-        return QCoreApplication::translate("LRelease", sourceText, comment);
-    }
-};
-#else
-class LR {
-    Q_DECLARE_TR_FUNCTIONS(LRelease)
-};
-#endif
-
 static void printOut(const QString &out)
 {
     std::cout << qPrintable(out);
@@ -63,21 +50,22 @@
 
 static void printUsage()
 {
-    printOut(LR::tr(
-        "Usage:\n"
-        "    lrelease-pro [options] [project-file]...\n"
-        "lrelease-pro is part of Qt's Linguist tool chain. It extracts project\n"
-        "information from qmake projects and passes it to lrelease.\n"
-        "All command line options that are not consumed by lrelease-pro are\n"
-        "passed to lrelease.\n\n"
-        "Options:\n"
-        "    -help  Display this information and exit\n"
-        "    -keep  Keep the temporary project dump around\n"
-        "    -silent\n"
-        "           Do not explain what is being done\n"
-        "    -version\n"
-        "           Display the version of lrelease-pro and exit\n"
-    ));
+    printOut(uR"(
+Usage:
+    lrelease-pro [options] [project-file]...
+lrelease-pro is part of Qt's Linguist tool chain. It extracts project
+information from qmake projects and passes it to lrelease.
+All command line options that are not consumed by lrelease-pro are
+passed to lrelease.
+
+Options:
+    -help  Display this information and exit
+    -keep  Keep the temporary project dump around
+    -silent
+           Do not explain what is being done
+    -version
+           Display the version of lrelease-pro and exit
+)"_qs);
 }
 
 int main(int argc, char **argv)
@@ -110,7 +98,8 @@
             lprodumpOptions << arg;
             lreleaseOptions << arg;
         } else if (!strcmp(argv[i], "-version")) {
-            printOut(LR::tr("lrelease-pro version %1\n").arg(QLatin1String(QT_VERSION_STR)));
+            printOut(QStringLiteral("lrelease-pro version %1\n")
+                     .arg(QLatin1String(QT_VERSION_STR)));
             return 0;
         } else if (!strcmp(argv[i], "-help")) {
             printUsage();
@@ -129,12 +118,12 @@
 
     const QStringList proFiles = extractProFiles(&inputFiles);
     if (proFiles.isEmpty()) {
-        printErr(LR::tr("lrelease-pro: No .pro/.pri files given.\n"));
+        printErr(u"lrelease-pro: No .pro/.pri files given.\n"_qs);
         return 1;
     }
     if (!inputFiles.isEmpty()) {
-        printErr(LR::tr("lrelease-pro: Only .pro/.pri files are supported. "
-                        "Offending files:\n    %1\n")
+        printErr(QStringLiteral("lrelease-pro: Only .pro/.pri files are supported. "
+                                "Offending files:\n    %1\n")
                  .arg(inputFiles.join(QLatin1String("\n    "))));
         return 1;
     }
diff --git a/qttools/src/linguist/lrelease/main.cpp b/qttools/src/linguist/lrelease/main.cpp
index 95617a8..49ff0cd 100644
--- a/qttools/src/linguist/lrelease/main.cpp
+++ b/qttools/src/linguist/lrelease/main.cpp
@@ -47,19 +47,6 @@
 
 QT_USE_NAMESPACE
 
-#ifdef QT_BOOTSTRAPPED
-struct LR {
-    static inline QString tr(const char *sourceText, const char *comment = 0)
-    {
-        return QCoreApplication::translate("LRelease", sourceText, comment);
-    }
-};
-#else
-class LR {
-    Q_DECLARE_TR_FUNCTIONS(LRelease)
-};
-#endif
-
 static void printOut(const QString & out)
 {
     QTextStream stream(stdout);
@@ -74,38 +61,40 @@
 
 static void printUsage()
 {
-    printOut(LR::tr(
-        "Usage:\n"
-        "    lrelease [options] -project project-file\n"
-        "    lrelease [options] ts-files [-qm qm-file]\n\n"
-        "lrelease is part of Qt's Linguist tool chain. It can be used as a\n"
-        "stand-alone tool to convert XML-based translations files in the TS\n"
-        "format into the 'compiled' QM format used by QTranslator objects.\n\n"
-        "Passing .pro files to lrelease is deprecated.\n"
-        "Please use the lrelease-pro tool instead, or use qmake's lrelease.prf\n"
-        "feature.\n\n"
-        "Options:\n"
-        "    -help  Display this information and exit\n"
-        "    -idbased\n"
-        "           Use IDs instead of source strings for message keying\n"
-        "    -compress\n"
-        "           Compress the QM files\n"
-        "    -nounfinished\n"
-        "           Do not include unfinished translations\n"
-        "    -removeidentical\n"
-        "           If the translated text is the same as\n"
-        "           the source text, do not include the message\n"
-        "    -markuntranslated <prefix>\n"
-        "           If a message has no real translation, use the source text\n"
-        "           prefixed with the given string instead\n"
-        "    -project <filename>\n"
-        "           Name of a file containing the project's description in JSON format.\n"
-        "           Such a file may be generated from a .pro file using the lprodump tool.\n"
-        "    -silent\n"
-        "           Do not explain what is being done\n"
-        "    -version\n"
-        "           Display the version of lrelease and exit\n"
-    ));
+    printOut(uR"(Usage:
+    lrelease [options] -project project-file
+    lrelease [options] ts-files [-qm qm-file]
+
+lrelease is part of Qt's Linguist tool chain. It can be used as a
+stand-alone tool to convert XML-based translations files in the TS
+format into the 'compiled' QM format used by QTranslator objects.
+
+Passing .pro files to lrelease is deprecated.
+Please use the lrelease-pro tool instead, or use qmake's lrelease.prf
+feature.
+
+Options:
+    -help  Display this information and exit
+    -idbased
+           Use IDs instead of source strings for message keying
+    -compress
+           Compress the QM files
+    -nounfinished
+           Do not include unfinished translations
+    -removeidentical
+           If the translated text is the same as
+           the source text, do not include the message
+    -markuntranslated <prefix>
+           If a message has no real translation, use the source text
+           prefixed with the given string instead
+    -project <filename>
+           Name of a file containing the project's description in JSON format.
+           Such a file may be generated from a .pro file using the lprodump tool.
+    -silent
+           Do not explain what is being done
+    -version
+           Display the version of lrelease and exit
+)"_qs);
 }
 
 static bool loadTsFile(Translator &tor, const QString &tsFileName, bool /* verbose */)
@@ -113,7 +102,7 @@
     ConversionData cd;
     bool ok = tor.load(tsFileName, cd, QLatin1String("auto"));
     if (!ok) {
-        printErr(LR::tr("lrelease error: %1").arg(cd.error()));
+        printErr(QLatin1String("lrelease error: %1").arg(cd.error()));
     } else {
         if (!cd.errors().isEmpty())
             printOut(cd.error());
@@ -128,17 +117,18 @@
     tor.reportDuplicates(tor.resolveDuplicates(), qmFileName, cd.isVerbose());
 
     if (cd.isVerbose())
-        printOut(LR::tr("Updating '%1'...\n").arg(qmFileName));
+        printOut(QLatin1String("Updating '%1'...\n").arg(qmFileName));
     if (removeIdentical) {
         if (cd.isVerbose())
-            printOut(LR::tr("Removing translations equal to source text in '%1'...\n").arg(qmFileName));
+            printOut(QLatin1String("Removing translations equal to source text in '%1'...\n")
+                             .arg(qmFileName));
         tor.stripIdenticalSourceTranslations();
     }
 
     QFile file(qmFileName);
     if (!file.open(QIODevice::WriteOnly)) {
-        printErr(LR::tr("lrelease error: cannot create '%1': %2\n")
-                                .arg(qmFileName, file.errorString()));
+        printErr(QLatin1String("lrelease error: cannot create '%1': %2\n")
+                         .arg(qmFileName, file.errorString()));
         return false;
     }
 
@@ -147,8 +137,7 @@
     file.close();
 
     if (!ok) {
-        printErr(LR::tr("lrelease error: cannot save '%1': %2")
-                                .arg(qmFileName, cd.error()));
+        printErr(QLatin1String("lrelease error: cannot save '%1': %2").arg(qmFileName, cd.error()));
     } else if (!cd.errors().isEmpty()) {
         printOut(cd.error());
     }
@@ -184,8 +173,9 @@
         result = *project.translations;
     result << translationsFromProjects(project.subProjects, false);
     if (topLevel && result.isEmpty()) {
-        printErr(LR::tr("lrelease warning: Met no 'TRANSLATIONS' entry in project file '%1'\n")
-                 .arg(project.filePath));
+        printErr(
+            QLatin1String("lrelease warning: Met no 'TRANSLATIONS' entry in project file '%1'\n")
+            .arg(project.filePath));
     }
     return result;
 }
@@ -201,19 +191,6 @@
 int main(int argc, char **argv)
 {
     QCoreApplication app(argc, argv);
-#ifndef QT_BOOTSTRAPPED
-#ifndef Q_OS_WIN32
-    QTranslator translator;
-    QTranslator qtTranslator;
-    QString sysLocale = QLocale::system().name();
-    QString resourceDir = QLibraryInfo::path(QLibraryInfo::TranslationsPath);
-    if (translator.load(QLatin1String("linguist_") + sysLocale, resourceDir)
-        && qtTranslator.load(QLatin1String("qt_") + sysLocale, resourceDir)) {
-        app.installTranslator(&translator);
-        app.installTranslator(&qtTranslator);
-    }
-#endif // Q_OS_WIN32
-#endif // QT_BOOTSTRAPPED
 
     ConversionData cd;
     cd.m_verbose = true; // the default is true starting with Qt 4.2
@@ -247,11 +224,11 @@
             cd.m_unTrPrefix = QString::fromLocal8Bit(argv[++i]);
         } else if (!strcmp(argv[i], "-project")) {
             if (i == argc - 1) {
-                printErr(LR::tr("The option -project requires a parameter.\n"));
+                printErr(QLatin1String("The option -project requires a parameter.\n"));
                 return 1;
             }
             if (!projectDescriptionFile.isEmpty()) {
-                printErr(LR::tr("The option -project must appear only once.\n"));
+                printErr(QLatin1String("The option -project must appear only once.\n"));
                 return 1;
             }
             projectDescriptionFile = QString::fromLocal8Bit(argv[++i]);
@@ -262,7 +239,7 @@
             cd.m_verbose = true;
             continue;
         } else if (!strcmp(argv[i], "-version")) {
-            printOut(LR::tr("lrelease version %1\n").arg(QLatin1String(QT_VERSION_STR)));
+            printOut(QLatin1String("lrelease version %1\n").arg(QLatin1String(QT_VERSION_STR)));
             return 0;
         } else if (!strcmp(argv[i], "-qm")) {
             if (i == argc - 1) {
@@ -288,18 +265,19 @@
 
     QString errorString;
     if (!extractProFiles(&inputFiles).isEmpty()) {
-        runInternalQtTool(QStringLiteral("lrelease-pro"), app.arguments().mid(1));
+        runInternalQtTool(QLatin1String("lrelease-pro"), app.arguments().mid(1));
         return 0;
     }
 
     if (!projectDescriptionFile.isEmpty()) {
         if (!inputFiles.isEmpty()) {
-            printErr(LR::tr("lrelease error: Do not specify TS files if -project is given.\n"));
+            printErr(QLatin1String(
+                    "lrelease error: Do not specify TS files if -project is given.\n"));
             return 1;
         }
         Projects projectDescription = readProjectDescription(projectDescriptionFile, &errorString);
         if (!errorString.isEmpty()) {
-            printErr(LR::tr("lrelease error: %1\n").arg(errorString));
+            printErr(QLatin1String("lrelease error: %1\n").arg(errorString));
             return 1;
         }
         inputFiles = translationsFromProjects(projectDescription);
diff --git a/qttools/src/linguist/lupdate-pro/main.cpp b/qttools/src/linguist/lupdate-pro/main.cpp
index 1910467..bd3aa5f 100644
--- a/qttools/src/linguist/lupdate-pro/main.cpp
+++ b/qttools/src/linguist/lupdate-pro/main.cpp
@@ -52,33 +52,30 @@
     std::cerr << qPrintable(out);
 }
 
-class LU {
-    Q_DECLARE_TR_FUNCTIONS(LUpdate)
-};
-
 static void printUsage()
 {
-    printOut(LU::tr(
-        "Usage:\n"
-        "    lupdate-pro [options] [project-file]... [-ts ts-files...]\n"
-        "lupdate-pro is part of Qt's Linguist tool chain. It extracts project\n"
-        "information from qmake projects and passes it to lupdate.\n"
-        "All command line options that are not consumed by lupdate-pro are\n"
-        "passed to lupdate.\n\n"
-        "Options:\n"
-        "    -help  Display this information and exit.\n"
-        "    -silent\n"
-        "           Do not explain what is being done.\n"
-        "    -pro <filename>\n"
-        "           Name of a .pro file. Useful for files with .pro file syntax but\n"
-        "           different file suffix. Projects are recursed into and merged.\n"
-        "    -pro-out <directory>\n"
-        "           Virtual output directory for processing subsequent .pro files.\n"
-        "    -pro-debug\n"
-        "           Trace processing .pro files. Specify twice for more verbosity.\n"
-        "    -version\n"
-        "           Display the version of lupdate-pro and exit.\n"
-    ));
+    printOut(
+        uR"(Usage:
+lupdate-pro [options] [project-file]... [-ts ts-files...]
+lupdate-pro is part of Qt's Linguist tool chain. It extracts project
+information from qmake projects and passes it to lupdate.
+All command line options that are not consumed by lupdate-pro are
+passed to lupdate.
+
+Options:
+    -help  Display this information and exit.
+    -silent
+           Do not explain what is being done.
+    -pro <filename>
+           Name of a .pro file. Useful for files with .pro file syntax but
+           different file suffix. Projects are recursed into and merged.
+    -pro-out <directory>
+           Virtual output directory for processing subsequent .pro files.
+    -pro-debug
+           Trace processing .pro files. Specify twice for more verbosity.
+    -version
+           Display the version of lupdate-pro and exit.
+)"_qs);
 }
 
 int main(int argc, char **argv)
@@ -119,12 +116,12 @@
         } else if (arg == QLatin1String("-pro-debug")) {
             lprodumpOptions << arg;
         } else if (arg == QLatin1String("-version")) {
-            printOut(LU::tr("lupdate-pro version %1\n").arg(QLatin1String(QT_VERSION_STR)));
+            printOut(QStringLiteral("lupdate-pro version %1\n").arg(QLatin1String(QT_VERSION_STR)));
             return 0;
         } else if (arg == QLatin1String("-pro")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The -pro option should be followed by a filename of .pro file.\n"));
+                printErr(u"The -pro option should be followed by a filename of .pro file.\n"_qs);
                 return 1;
             }
             lprodumpOptions << arg << args[i];
@@ -132,7 +129,7 @@
         } else if (arg == QLatin1String("-pro-out")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The -pro-out option should be followed by a directory name.\n"));
+                printErr(u"The -pro-out option should be followed by a directory name.\n"_qs);
                 return 1;
             }
             lprodumpOptions << arg << args[i];
@@ -145,7 +142,7 @@
     } // for args
 
     if (!hasProFiles) {
-        printErr(LU::tr("lupdate-pro: No .pro/.pri files given.\n"));
+        printErr(u"lupdate-pro: No .pro/.pri files given.\n"_qs);
         return 1;
     }
 
diff --git a/qttools/src/linguist/lupdate/cpp.cpp b/qttools/src/linguist/lupdate/cpp.cpp
index ed0947c..22891c6 100644
--- a/qttools/src/linguist/lupdate/cpp.cpp
+++ b/qttools/src/linguist/lupdate/cpp.cpp
@@ -512,8 +512,8 @@
                                 || yyBraceDepth != is.braceDepth1st
                                 || yyParenDepth != is.parenDepth1st)
                                 yyMsg(is.elseLine)
-                                    << qPrintable(LU::tr("Parenthesis/bracket/brace mismatch between "
-                                                         "#if and #else branches; using #if branch\n"));
+                                    << "Parenthesis/bracket/brace mismatch between "
+                                       "#if and #else branches; using #if branch\n";
                         } else {
                             is.bracketDepth1st = yyBracketDepth;
                             is.braceDepth1st = yyBraceDepth;
@@ -535,8 +535,8 @@
                                 || yyBraceDepth != is.braceDepth1st
                                 || yyParenDepth != is.parenDepth1st)
                                 yyMsg(is.elseLine)
-                                    << qPrintable(LU::tr("Parenthesis/brace mismatch between "
-                                                         "#if and #else branches; using #if branch\n"));
+                                    << "Parenthesis/brace mismatch between "
+                                       "#if and #else branches; using #if branch\n";
                             yyBracketDepth = is.bracketDepth1st;
                             yyBraceDepth = is.braceDepth1st;
                             yyParenDepth = is.parenDepth1st;
@@ -562,7 +562,7 @@
                         forever {
                             yyCh = getChar();
                             if (yyCh == EOF) {
-                                yyMsg() << qPrintable(LU::tr("Unterminated C++ comment\n"));
+                                yyMsg() << "Unterminated C++ comment\n";
                                 break;
                             }
 
@@ -701,7 +701,7 @@
                 else
                     yyWord.resize(ptr - reinterpret_cast<const ushort *>(yyWord.unicode()));
                 if (yyCh != '"')
-                    yyMsg() << qPrintable(LU::tr("Unterminated/mismatched C++ Raw string\n"));
+                    yyMsg() << "Unterminated/mismatched C++ Raw string\n";
                 else
                     yyCh = getChar();
                 return Tok_RawString;
@@ -742,7 +742,7 @@
                     forever {
                         yyCh = getChar();
                         if (yyCh == EOF) {
-                            yyMsg() << qPrintable(LU::tr("Unterminated C++ comment\n"));
+                            yyMsg() << "Unterminated C++ comment\n";
                             break;
                         }
                         *ptr++ = yyCh;
@@ -776,7 +776,7 @@
                 yyWord.resize(ptr - (ushort *)yyWord.unicode());
 
                 if (yyCh != '"')
-                    yyMsg() << qPrintable(LU::tr("Unterminated C++ string\n"));
+                    yyMsg() << "Unterminated C++ string\n";
                 else
                     yyCh = getChar();
                 return Tok_String;
@@ -813,7 +813,7 @@
 
                 forever {
                     if (yyCh == EOF || yyCh == '\n') {
-                        yyMsg() << qPrintable(LU::tr("Unterminated C++ character\n"));
+                        yyMsg() << "Unterminated C++ character\n";
                         break;
                     }
                     yyCh = getChar();
@@ -833,8 +833,8 @@
                 if (yyBraceDepth == yyMinBraceDepth) {
                     if (!inDefine)
                         yyMsg(yyCurLineNo)
-                            << qPrintable(LU::tr("Excess closing brace in C++ code"
-                                                 " (or abuse of the C++ preprocessor)\n"));
+                            << "Excess closing brace in C++ code"
+                            " (or abuse of the C++ preprocessor)\n";
                     // Avoid things getting messed up even more
                     yyCh = getChar();
                     return Tok_Semicolon;
@@ -851,8 +851,8 @@
             case ')':
                 if (yyParenDepth == 0)
                     yyMsg(yyCurLineNo)
-                        << qPrintable(LU::tr("Excess closing parenthesis in C++ code"
-                                             " (or abuse of the C++ preprocessor)\n"));
+                        << "Excess closing parenthesis in C++ code"
+                           " (or abuse of the C++ preprocessor)\n";
                 else
                     yyParenDepth--;
                 yyCh = getChar();
@@ -866,8 +866,8 @@
             case ']':
                 if (yyBracketDepth == 0)
                     yyMsg(yyCurLineNo)
-                        << qPrintable(LU::tr("Excess closing bracket in C++ code"
-                                             " (or abuse of the C++ preprocessor)\n"));
+                        << "Excess closing bracket in C++ code"
+                           " (or abuse of the C++ preprocessor)\n";
                 else
                     yyBracketDepth--;
                 yyCh = getChar();
@@ -1298,7 +1298,8 @@
 
     QFile f(cleanFile);
     if (!f.open(QIODevice::ReadOnly)) {
-        yyMsg() << qPrintable(LU::tr("Cannot open %1: %2\n").arg(cleanFile, f.errorString()));
+        yyMsg() << qPrintable(
+            QStringLiteral("Cannot open %1: %2\n").arg(cleanFile, f.errorString()));
         return;
     }
 
@@ -1394,7 +1395,7 @@
         return true;
     }
     if (yyWord == strLatin1 || yyWord == strDefaultCodec || yyWord == strCodecForTr)
-        yyMsg() << qPrintable(LU::tr("Unsupported encoding Latin1/DefaultCodec/CodecForTr\n"));
+        yyMsg() << "Unsupported encoding Latin1/DefaultCodec/CodecForTr\n";
     return false;
 }
 
@@ -1462,7 +1463,7 @@
 void CppParser::handleTr(QString &prefix, bool plural)
 {
     if (!sourcetext.isEmpty())
-        yyMsg() << qPrintable(LU::tr("//% cannot be used with tr() / QT_TR_NOOP(). Ignoring\n"));
+        yyMsg() << "//% cannot be used with tr() / QT_TR_NOOP(). Ignoring\n";
     int line = yyLineNo;
     yyTok = getToken();
     if (matchString(&text) && !text.isEmpty()) {
@@ -1481,8 +1482,9 @@
             NamespaceList unresolved;
             if (!fullyQualify(namespaces, pendingContext, true, &functionContext, &unresolved)) {
                 functionContextUnresolved = stringifyNamespace(0, unresolved);
-                yyMsg() << qPrintable(LU::tr("Qualifying with unknown namespace/class %1::%2\n")
-                                      .arg(stringifyNamespace(functionContext)).arg(unresolved.first().value()));
+                yyMsg() << qPrintable(
+                    QStringLiteral("Qualifying with unknown namespace/class %1::%2\n")
+                    .arg(stringifyNamespace(functionContext)).arg(unresolved.first().value()));
             }
             pendingContext.clear();
         }
@@ -1490,7 +1492,7 @@
             if (functionContextUnresolved.isEmpty()) {
                 int idx = functionContext.length();
                 if (idx < 2) {
-                    yyMsg() << qPrintable(LU::tr("tr() cannot be called without context\n"));
+                    yyMsg() << "tr() cannot be called without context\n";
                     return;
                 }
                 Namespace *fctx;
@@ -1499,8 +1501,8 @@
                         context = stringifyNamespace(functionContext);
                         fctx = findNamespace(functionContext)->classDef;
                         if (!fctx->complained) {
-                            yyMsg() << qPrintable(LU::tr("Class '%1' lacks Q_OBJECT macro\n")
-                                                 .arg(context));
+                            yyMsg() << qPrintable(
+                                QStringLiteral("Class '%1' lacks Q_OBJECT macro\n").arg(context));
                             fctx->complained = true;
                         }
                         goto gotctx;
@@ -1527,7 +1529,7 @@
             int last = prefix.lastIndexOf(QLatin1String("::"));
             QString className = prefix.mid(last == -1 ? 0 : last + 2);
             if (!className.isEmpty() && className == functionName) {
-                yyMsg() << qPrintable(LU::tr("It is not recommended to call tr() from within a constructor '%1::%2'\n")
+                yyMsg() << qPrintable(QStringLiteral("It is not recommended to call tr() from within a constructor '%1::%2'\n")
                         .arg(className).arg(functionName));
             }
 #endif
@@ -1543,7 +1545,8 @@
                     context = fctx->trQualification;
                 }
                 if (!fctx->hasTrFunctions && !fctx->complained) {
-                    yyMsg() << qPrintable(LU::tr("Class '%1' lacks Q_OBJECT macro\n").arg(context));
+                    yyMsg() << qPrintable(QStringLiteral("Class '%1' lacks Q_OBJECT macro\n")
+                                          .arg(context));
                     fctx->complained = true;
                 }
             } else {
@@ -1565,7 +1568,7 @@
 void CppParser::handleTranslate(bool plural)
 {
     if (!sourcetext.isEmpty())
-        yyMsg() << qPrintable(LU::tr("//% cannot be used with translate() / QT_TRANSLATE_NOOP(). Ignoring\n"));
+        yyMsg() << "//% cannot be used with translate() / QT_TRANSLATE_NOOP(). Ignoring\n";
     int line = yyLineNo;
     yyTok = getToken();
     if (matchString(&context)
@@ -1618,7 +1621,7 @@
 void CppParser::handleTrId(bool plural)
 {
     if (!msgid.isEmpty())
-        yyMsg() << qPrintable(LU::tr("//= cannot be used with qtTrId() / QT_TRID_NOOP(). Ignoring\n"));
+        yyMsg() << "//= cannot be used with qtTrId() / QT_TRID_NOOP(). Ignoring\n";
     int line = yyLineNo;
     yyTok = getToken();
     if (matchString(&msgid) && !msgid.isEmpty()) {
@@ -1788,7 +1791,7 @@
                     // Forward-declared class definitions can be namespaced.
                     NamespaceList nsl;
                     if (!fullyQualify(namespaces, quali, true, &nsl, 0)) {
-                        yyMsg() << qPrintable(LU::tr("Ignoring definition of undeclared qualified class\n"));
+                        yyMsg() << "Ignoring definition of undeclared qualified class\n";
                         break;
                     }
                     namespaceDepths.push(namespaces.count());
@@ -1978,7 +1981,7 @@
                 switch (trFunctionAliasManager.trFunctionByName(yyWord)) {
                 case TrFunctionAliasManager::Function_tr:
                 case TrFunctionAliasManager::Function_trUtf8:
-                    yyMsg() << qPrintable(LU::tr("Cannot invoke tr() like this\n"));
+                    yyMsg() << "Cannot invoke tr() like this\n";
                     break;
                 }
             }
@@ -2021,7 +2024,7 @@
             prospectiveContext.clear();
             prefix.clear();
             if (!sourcetext.isEmpty() || !extracomment.isEmpty() || !msgid.isEmpty() || !extra.isEmpty()) {
-                yyMsg() << qPrintable(LU::tr("Discarding unconsumed meta data\n"));
+                yyMsg() << "Discarding unconsumed meta data\n";
                 sourcetext.clear();
                 extracomment.clear();
                 msgid.clear();
@@ -2096,16 +2099,15 @@
   goteof:
     if (yyBraceDepth != 0)
         yyMsg(yyBraceLineNo)
-            << qPrintable(LU::tr("Unbalanced opening brace in C++ code"
-                                 " (or abuse of the C++ preprocessor)\n"));
+            << "Unbalanced opening brace in C++ code (or abuse of the C++ preprocessor)\n";
     else if (yyParenDepth != 0)
         yyMsg(yyParenLineNo)
-            << qPrintable(LU::tr("Unbalanced opening parenthesis in C++ code"
-                                 " (or abuse of the C++ preprocessor)\n"));
+            << "Unbalanced opening parenthesis in C++ code"
+               " (or abuse of the C++ preprocessor)\n";
     else if (yyBracketDepth != 0)
         yyMsg(yyBracketLineNo)
-            << qPrintable(LU::tr("Unbalanced opening bracket in C++ code"
-                                 " (or abuse of the C++ preprocessor)\n"));
+            << "Unbalanced opening bracket in C++ code"
+               " (or abuse of the C++ preprocessor)\n";
 }
 
 void CppParser::processComment()
@@ -2140,13 +2142,13 @@
             if (isspace(c))
                 continue;
             if (c != '"') {
-                yyMsg() << qPrintable(LU::tr("Unexpected character in meta string\n"));
+                yyMsg() << "Unexpected character in meta string\n";
                 break;
             }
             forever {
                 if (p >= yyWord.length()) {
                   whoops:
-                    yyMsg() << qPrintable(LU::tr("Unterminated meta string\n"));
+                    yyMsg() << "Unterminated meta string\n";
                     break;
                 }
                 c = yyWord.unicode()[p++].unicode();
@@ -2236,7 +2238,8 @@
 
         QFile file(filename);
         if (!file.open(QIODevice::ReadOnly)) {
-            cd.appendError(LU::tr("Cannot open %1: %2").arg(filename, file.errorString()));
+            cd.appendError(QStringLiteral("Cannot open %1: %2").arg(filename,
+                                                                    file.errorString()));
             continue;
         }
 
diff --git a/qttools/src/linguist/lupdate/cpp_clang.cpp b/qttools/src/linguist/lupdate/cpp_clang.cpp
index b3e792a..2284e58 100644
--- a/qttools/src/linguist/lupdate/cpp_clang.cpp
+++ b/qttools/src/linguist/lupdate/cpp_clang.cpp
@@ -360,7 +360,7 @@
         qCDebug(lcClang) << "Generating compilation database" << dbFilePath;
         if (!generateCompilationDatabase(dbFilePath, cd)) {
             *fail = true;
-            cd.appendError(LU::tr("Cannot generate compilation database."));
+            cd.appendError(u"Cannot generate compilation database."_qs);
             return;
         }
         errorMessage.clear();
diff --git a/qttools/src/linguist/lupdate/java.cpp b/qttools/src/linguist/lupdate/java.cpp
index 94aa992..7a1c6b6 100644
--- a/qttools/src/linguist/lupdate/java.cpp
+++ b/qttools/src/linguist/lupdate/java.cpp
@@ -178,7 +178,7 @@
                     while ( !metAsterSlash ) {
                         yyCh = getChar();
                         if (yyEOF) {
-                            yyMsg() << qPrintable(LU::tr("Unterminated Java comment.\n"));
+                            yyMsg() << "Unterminated Java comment.\n";
                             return Tok_Comment;
                         }
 
@@ -215,7 +215,7 @@
                                 else {
                                     int sub(yyCh.toLower().toLatin1() - 87);
                                     if( sub > 15 || sub < 10) {
-                                        yyMsg() << qPrintable(LU::tr("Invalid Unicode value.\n"));
+                                        yyMsg() << "Invalid Unicode value.\n";
                                         break;
                                     }
                                     unicode += sub;
@@ -238,7 +238,7 @@
                 }
 
                 if ( yyCh != QLatin1Char('"') )
-                    yyMsg() << qPrintable(LU::tr("Unterminated string.\n"));
+                    yyMsg() << "Unterminated string.\n";
 
                 yyCh = getChar();
 
@@ -351,9 +351,9 @@
         if (yyTok == Tok_String)
             s += yyString;
         else {
-            yyMsg() << qPrintable(LU::tr(
+            yyMsg() <<
                 "String used in translation can contain only literals"
-                " concatenated with other literals, not expressions or numbers.\n"));
+                " concatenated with other literals, not expressions or numbers.\n";
             return false;
         }
         yyTok = getToken();
@@ -462,7 +462,7 @@
                 yyScope.push(new Scope(yyIdent, Scope::Clazz, yyLineNo));
             }
             else {
-                yyMsg() << qPrintable(LU::tr("'class' must be followed by a class name.\n"));
+                yyMsg() << "'class' must be followed by a class name.\n";
                 break;
             }
             while (!match(Tok_LeftBrace)) {
@@ -534,7 +534,7 @@
 
         case Tok_RightBrace:
             if ( yyScope.isEmpty() ) {
-                yyMsg() << qPrintable(LU::tr("Excess closing brace.\n"));
+                yyMsg() << "Excess closing brace.\n";
             }
             else
                 delete (yyScope.pop());
@@ -563,7 +563,7 @@
                         yyPackage.append(QLatin1String("."));
                         break;
                     default:
-                         yyMsg() << qPrintable(LU::tr("'package' must be followed by package name.\n"));
+                         yyMsg() << "'package' must be followed by package name.\n";
                          break;
                 }
                 yyTok = getToken();
@@ -576,9 +576,9 @@
     }
 
     if ( !yyScope.isEmpty() )
-        yyMsg(yyScope.top()->line) << qPrintable(LU::tr("Unbalanced opening brace.\n"));
+        yyMsg(yyScope.top()->line) << "Unbalanced opening brace.\n";
     else if ( yyParenDepth != 0 )
-        yyMsg(yyParenLineNo) << qPrintable(LU::tr("Unbalanced opening parenthesis.\n"));
+        yyMsg(yyParenLineNo) << "Unbalanced opening parenthesis.\n";
 }
 
 
@@ -586,7 +586,7 @@
 {
     QFile file(filename);
     if (!file.open(QIODevice::ReadOnly)) {
-        cd.appendError(LU::tr("Cannot open %1: %2").arg(filename, file.errorString()));
+        cd.appendError(QStringLiteral("Cannot open %1: %2").arg(filename, file.errorString()));
         return false;
     }
 
diff --git a/qttools/src/linguist/lupdate/lupdate.h b/qttools/src/linguist/lupdate/lupdate.h
index 9a37c7e..a68ce3c 100644
--- a/qttools/src/linguist/lupdate/lupdate.h
+++ b/qttools/src/linguist/lupdate/lupdate.h
@@ -140,10 +140,6 @@
     mutable QHash<QString,TrFunction> m_nameToTrFunctionMap;
 };
 
-class LU {
-    Q_DECLARE_TR_FUNCTIONS(LUpdate)
-};
-
 QT_END_NAMESPACE
 
 extern QT_PREPEND_NAMESPACE(TrFunctionAliasManager) trFunctionAliasManager;
diff --git a/qttools/src/linguist/lupdate/main.cpp b/qttools/src/linguist/lupdate/main.cpp
index c4cbc74..f84962b 100644
--- a/qttools/src/linguist/lupdate/main.cpp
+++ b/qttools/src/linguist/lupdate/main.cpp
@@ -215,7 +215,7 @@
 
 static void printUsage()
 {
-    printOut(LU::tr(
+    printOut(QStringLiteral(
         "Usage:\n"
         "    lupdate [options] [project-file]...\n"
         "    lupdate [options] [source-file|path|@lst-file]... -ts ts-files|@lst-file\n\n"
@@ -303,7 +303,7 @@
     for (const QString &pair : arg.split(QLatin1Char(','), Qt::SkipEmptyParts)) {
         const int equalSign = pair.indexOf(QLatin1Char('='));
         if (equalSign < 0) {
-            printErr(LU::tr("tr-function mapping '%1' in -tr-function-alias is missing the '='.\n").arg(pair));
+            printErr(QStringLiteral("tr-function mapping '%1' in -tr-function-alias is missing the '='.\n").arg(pair));
             return false;
         }
         const bool plusEqual = equalSign > 0 && pair[equalSign-1] == QLatin1Char('+');
@@ -312,13 +312,13 @@
         const QString alias = pair.mid(equalSign+1).trimmed();
         const int trFunction = trFunctionByDefaultName(trFunctionName);
         if (trFunction < 0) {
-            printErr(LU::tr("Unknown tr-function '%1' in -tr-function-alias option.\n"
+            printErr(QStringLiteral("Unknown tr-function '%1' in -tr-function-alias option.\n"
                             "Available tr-functions are: %2")
                      .arg(trFunctionName, availableFunctions().join(QLatin1Char(','))));
             return false;
         }
         if (alias.isEmpty()) {
-            printErr(LU::tr("Empty alias for tr-function '%1' in -tr-function-alias option.\n")
+            printErr(QStringLiteral("Empty alias for tr-function '%1' in -tr-function-alias option.\n")
                      .arg(trFunctionName));
             return false;
         }
@@ -336,7 +336,7 @@
     for (int i = 0; i < fetchedTor.messageCount(); i++) {
         const TranslatorMessage &msg = fetchedTor.constMessage(i);
         if (!msg.id().isEmpty() && msg.sourceText().isEmpty())
-            printErr(LU::tr("lupdate warning: Message with id '%1' has no source.\n")
+            printErr(QStringLiteral("lupdate warning: Message with id '%1' has no source.\n")
                      .arg(msg.id()));
     }
 
@@ -369,11 +369,11 @@
             tor.resolveDuplicates();
             cd.clearErrors();
             if (!targetLanguage.isEmpty() && targetLanguage != tor.languageCode())
-                printErr(LU::tr("lupdate warning: Specified target language '%1' disagrees with"
+                printErr(QStringLiteral("lupdate warning: Specified target language '%1' disagrees with"
                                 " existing file's language '%2'. Ignoring.\n")
                          .arg(targetLanguage, tor.languageCode()));
             if (!sourceLanguage.isEmpty() && sourceLanguage != tor.sourceLanguageCode())
-                printErr(LU::tr("lupdate warning: Specified source language '%1' disagrees with"
+                printErr(QStringLiteral("lupdate warning: Specified source language '%1' disagrees with"
                                 " existing file's language '%2'. Ignoring.\n")
                          .arg(sourceLanguage, tor.sourceLanguageCode()));
             // If there is translation in the file, the language should be recognized
@@ -384,7 +384,7 @@
                 tor.languageAndCountry(tor.languageCode(), &l, &c);
                 QStringList forms;
                 if (!getNumerusInfo(l, c, 0, &forms, 0)) {
-                    printErr(LU::tr("File %1 won't be updated: it contains translation but the"
+                    printErr(QStringLiteral("File %1 won't be updated: it contains translation but the"
                     " target language is not recognized\n").arg(fileName));
                     continue;
                 }
@@ -405,7 +405,7 @@
         else if (options & AbsoluteLocations)
             tor.setLocationsType(Translator::AbsoluteLocations);
         if (options & Verbose)
-            printOut(LU::tr("Updating '%1'...\n").arg(fn));
+            printOut(QStringLiteral("Updating '%1'...\n").arg(fn));
 
         UpdateOptions theseOptions = options;
         if (tor.locationsType() == Translator::NoLocations) // Could be set from file
@@ -418,7 +418,7 @@
         }
         if (options & PluralOnly) {
             if (options & Verbose)
-                printOut(LU::tr("Stripping non plural forms in '%1'...\n").arg(fn));
+                printOut(QStringLiteral("Stripping non plural forms in '%1'...\n").arg(fn));
             out.stripNonPluralForms();
         }
         if (options & NoObsolete)
@@ -464,12 +464,12 @@
     QString content;
     QString errStr;
     if (!readFileContent(resourceFile, &content, &errStr)) {
-        printErr(LU::tr("lupdate error: Can not read %1: %2\n").arg(resourceFile, errStr));
+        printErr(QStringLiteral("lupdate error: Can not read %1: %2\n").arg(resourceFile, errStr));
         return QStringList();
     }
     ReadQrcResult rqr = readQrcFile(resourceFile, content);
     if (rqr.hasError()) {
-        printErr(LU::tr("lupdate error: %1:%2: %3\n")
+        printErr(QStringLiteral("lupdate error: %1:%2: %3\n")
                  .arg(resourceFile, QString::number(rqr.line), rqr.errorString));
     }
     return rqr.files;
@@ -527,7 +527,7 @@
 
 #ifdef QT_NO_QML
     if (requireQmlSupport)
-        printErr(LU::tr("lupdate warning: Some files have been ignored due to missing qml/javascript support\n"));
+        printErr(QStringLiteral("lupdate warning: Some files have been ignored due to missing qml/javascript support\n"));
 #endif
 
     if (useClangToParseCpp) {
@@ -535,7 +535,7 @@
         ClangCppParser::loadCPP(fetchedTor, sourceFilesCpp, cd, fail);
 #else
         *fail = true;
-        printErr(LU::tr("lupdate error: lupdate was built without clang support."));
+        printErr(QStringLiteral("lupdate error: lupdate was built without clang support."));
 #endif
     }
     else
@@ -592,7 +592,7 @@
                        || codecForSource == QLatin1String("utf8")) {
                 options &= ~SourceIsUtf16;
             } else {
-                printErr(LU::tr("lupdate warning: Codec for source '%1' is invalid."
+                printErr(QStringLiteral("lupdate warning: Codec for source '%1' is invalid."
                                 " Falling back to UTF-8.\n").arg(codecForSource));
                 options &= ~SourceIsUtf16;
             }
@@ -616,11 +616,11 @@
             tsFiles = *prj.translations;
             if (parentTor) {
                 if (topLevel) {
-                    printErr(LU::tr("lupdate warning: TS files from command line "
+                    printErr(QStringLiteral("lupdate warning: TS files from command line "
                                     "will override TRANSLATIONS in %1.\n").arg(projectFile));
                     goto noTrans;
                 } else if (nestComplain) {
-                    printErr(LU::tr("lupdate warning: TS files from command line "
+                    printErr(QStringLiteral("lupdate warning: TS files from command line "
                                     "prevent recursing into %1.\n").arg(projectFile));
                     return;
                 }
@@ -642,7 +642,7 @@
       noTrans:
         if (!parentTor) {
             if (topLevel) {
-                printErr(LU::tr("lupdate warning: no TS files specified. Only diagnostics "
+                printErr(QStringLiteral("lupdate warning: no TS files specified. Only diagnostics "
                                 "will be produced for '%1'.\n").arg(projectFile));
             }
             Translator tor;
@@ -729,11 +729,11 @@
         } else if (arg == QLatin1String("-project")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The option -project requires a parameter.\n"));
+                printErr(u"The option -project requires a parameter.\n"_qs);
                 return 1;
             }
             if (!projectDescriptionFile.isEmpty()) {
-                printErr(LU::tr("The option -project must appear only once.\n"));
+                printErr(u"The option -project must appear only once.\n"_qs);
                 return 1;
             }
             projectDescriptionFile = args[i];
@@ -742,7 +742,7 @@
         } else if (arg == QLatin1String("-target-language")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The option -target-language requires a parameter.\n"));
+                printErr(u"The option -target-language requires a parameter.\n"_qs);
                 return 1;
             }
             targetLanguage = args[i];
@@ -750,7 +750,7 @@
         } else if (arg == QLatin1String("-source-language")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The option -source-language requires a parameter.\n"));
+                printErr(u"The option -source-language requires a parameter.\n"_qs);
                 return 1;
             }
             sourceLanguage = args[i];
@@ -758,7 +758,7 @@
         } else if (arg == QLatin1String("-disable-heuristic")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The option -disable-heuristic requires a parameter.\n"));
+                printErr(u"The option -disable-heuristic requires a parameter.\n"_qs);
                 return 1;
             }
             arg = args[i];
@@ -769,14 +769,14 @@
             } else if (arg == QLatin1String("number")) {
                 options &= ~HeuristicNumber;
             } else {
-                printErr(LU::tr("Invalid heuristic name passed to -disable-heuristic.\n"));
+                printErr(u"Invalid heuristic name passed to -disable-heuristic.\n"_qs);
                 return 1;
             }
             continue;
         } else if (arg == QLatin1String("-locations")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The option -locations requires a parameter.\n"));
+                printErr(u"The option -locations requires a parameter.\n"_qs);
                 return 1;
             }
             if (args[i] == QLatin1String("none")) {
@@ -786,7 +786,7 @@
             } else if (args[i] == QLatin1String("absolute")) {
                 options |= AbsoluteLocations;
             } else {
-                printErr(LU::tr("Invalid parameter passed to -locations.\n"));
+                printErr(u"Invalid parameter passed to -locations.\n"_qs);
                 return 1;
             }
             continue;
@@ -807,7 +807,7 @@
             options |= NoSort;
             continue;
         } else if (arg == QLatin1String("-version")) {
-            printOut(LU::tr("lupdate version %1\n").arg(QLatin1String(QT_VERSION_STR)));
+            printOut(QStringLiteral("lupdate version %1\n").arg(QLatin1String(QT_VERSION_STR)));
             return 0;
         } else if (arg == QLatin1String("-ts")) {
             metTsFlag = true;
@@ -820,7 +820,7 @@
         } else if (arg == QLatin1String("-extensions")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The -extensions option should be followed by an extension list.\n"));
+                printErr(u"The -extensions option should be followed by an extension list.\n"_qs);
                 return 1;
             }
             extensions = args[i];
@@ -828,7 +828,7 @@
         } else if (arg == QLatin1String("-tr-function-alias")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The -tr-function-alias option should be followed by a list of function=alias mappings.\n"));
+                printErr(u"The -tr-function-alias option should be followed by a list of function=alias mappings.\n"_qs);
                 return 1;
             }
             if (!handleTrFunctionAliases(args[i]))
@@ -837,7 +837,7 @@
         } else if (arg == QLatin1String("-pro")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The -pro option should be followed by a filename of .pro file.\n"));
+                printErr(u"The -pro option should be followed by a filename of .pro file.\n"_qs);
                 return 1;
             }
             QString file = QDir::cleanPath(QFileInfo(args[i]).absoluteFilePath());
@@ -847,7 +847,7 @@
         } else if (arg == QLatin1String("-pro-out")) {
             ++i;
             if (i == argc) {
-                printErr(LU::tr("The -pro-out option should be followed by a directory name.\n"));
+                printErr(u"The -pro-out option should be followed by a directory name.\n"_qs);
                 return 1;
             }
             outDir = QDir::cleanPath(QFileInfo(args[i]).absoluteFilePath());
@@ -856,7 +856,7 @@
             if (arg.length() == 2) {
                 ++i;
                 if (i == argc) {
-                    printErr(LU::tr("The -I option should be followed by a path.\n"));
+                    printErr(u"The -I option should be followed by a path.\n"_qs);
                     return 1;
                 }
                 includePath += args[i];
@@ -877,7 +877,7 @@
         }
 #endif
         else if (arg.startsWith(QLatin1String("-")) && arg != QLatin1String("-")) {
-            printErr(LU::tr("Unrecognized option '%1'.\n").arg(arg));
+            printErr(QStringLiteral("Unrecognized option '%1'.\n").arg(arg));
             return 1;
         }
 
@@ -885,7 +885,7 @@
         if (arg.startsWith(QLatin1String("@"))) {
             QFile lstFile(arg.mid(1));
             if (!lstFile.open(QIODevice::ReadOnly)) {
-                printErr(LU::tr("lupdate error: List file '%1' is not readable.\n")
+                printErr(QStringLiteral("lupdate error: List file '%1' is not readable.\n")
                          .arg(lstFile.fileName()));
                 return 1;
             }
@@ -894,7 +894,7 @@
 
                 if (lineContent.startsWith(QLatin1String("-I"))) {
                     if (lineContent.length() == 2) {
-                        printErr(LU::tr("The -I option should be followed by a path.\n"));
+                        printErr(u"The -I option should be followed by a path.\n"_qs);
                         return 1;
                     }
                     includePath += lineContent.mid(2);
@@ -914,7 +914,7 @@
                         if (!fi.exists() || fi.isWritable()) {
                             tsFileNames.append(QFileInfo(file).absoluteFilePath());
                         } else {
-                            printErr(LU::tr("lupdate warning: For some reason, '%1' is not writable.\n")
+                            printErr(QStringLiteral("lupdate warning: For some reason, '%1' is not writable.\n")
                                      .arg(file));
                         }
                         found = true;
@@ -922,7 +922,7 @@
                     }
                 }
                 if (!found) {
-                    printErr(LU::tr("lupdate error: File '%1' has no recognized extension.\n")
+                    printErr(QStringLiteral("lupdate error: File '%1' has no recognized extension.\n")
                              .arg(file));
                     return 1;
                 }
@@ -934,7 +934,7 @@
             for (const QString &file : qAsConst(files)) {
                 QFileInfo fi(file);
                 if (!fi.exists()) {
-                    printErr(LU::tr("lupdate error: File '%1' does not exist.\n").arg(file));
+                    printErr(QStringLiteral("lupdate error: File '%1' does not exist.\n").arg(file));
                     return 1;
                 }
                 if (isProOrPriFile(file)) {
@@ -942,7 +942,7 @@
                     proFiles << cleanFile;
                 } else if (fi.isDir()) {
                     if (options & Verbose)
-                        printOut(LU::tr("Scanning directory '%1'...\n").arg(file));
+                        printOut(QStringLiteral("Scanning directory '%1'...\n").arg(file));
                     QDir dir = QDir(fi.filePath());
                     projectRoots.insert(dir.absolutePath() + QLatin1Char('/'));
                     if (extensionsNameFilters.isEmpty()) {
@@ -1001,12 +1001,12 @@
     }
 
     if (!targetLanguage.isEmpty() && tsFileNames.count() != 1)
-        printErr(LU::tr("lupdate warning: -target-language usually only"
-                        " makes sense with exactly one TS file.\n"));
+        printErr(u"lupdate warning: -target-language usually only"
+                  " makes sense with exactly one TS file.\n"_qs);
 
     QString errorString;
     if (!proFiles.isEmpty()) {
-        runInternalQtTool(QStringLiteral("lupdate-pro"), app.arguments().mid(1));
+        runInternalQtTool(u"lupdate-pro"_qs, app.arguments().mid(1));
         return 0;
     }
 
@@ -1014,11 +1014,11 @@
     if (!projectDescriptionFile.isEmpty()) {
         projectDescription = readProjectDescription(projectDescriptionFile, &errorString);
         if (!errorString.isEmpty()) {
-            printErr(LU::tr("lupdate error: %1\n").arg(errorString));
+            printErr(QStringLiteral("lupdate error: %1\n").arg(errorString));
             return 1;
         }
         if (projectDescription.empty()) {
-            printErr(LU::tr("lupdate error:"
+            printErr(QStringLiteral("lupdate error:"
                             " Could not find project descriptions in %1.\n")
                      .arg(projectDescriptionFile));
             return 1;
@@ -1028,8 +1028,8 @@
     bool fail = false;
     if (projectDescription.empty()) {
         if (tsFileNames.isEmpty())
-            printErr(LU::tr("lupdate warning:"
-                            " no TS files specified. Only diagnostics will be produced.\n"));
+            printErr(u"lupdate warning:"
+                      " no TS files specified. Only diagnostics will be produced.\n"_qs);
 
         Translator fetchedTor;
         ConversionData cd;
@@ -1046,7 +1046,7 @@
                       sourceLanguage, targetLanguage, options, &fail);
     } else {
         if (!sourceFiles.isEmpty() || !resourceFiles.isEmpty() || !includePath.isEmpty()) {
-            printErr(LU::tr("lupdate error:"
+            printErr(QStringLiteral("lupdate error:"
                             " Both project and source files / include paths specified.\n"));
             return 1;
         }
diff --git a/qttools/src/linguist/lupdate/merge.cpp b/qttools/src/linguist/lupdate/merge.cpp
index 9db8826..57f7760 100644
--- a/qttools/src/linguist/lupdate/merge.cpp
+++ b/qttools/src/linguist/lupdate/merge.cpp
@@ -525,25 +525,26 @@
 
     if (options & Verbose) {
         int totalFound = neww + known;
-        err += LU::tr("    Found %n source text(s) (%1 new and %2 already existing)\n", 0, totalFound).arg(neww).arg(known);
+        err += QStringLiteral("    Found %1 source text(s) (%2 new and %3 already existing)\n")
+            .arg(totalFound).arg(neww).arg(known);
 
         if (obsoleted) {
             if (options & NoObsolete) {
-                err += LU::tr("    Removed %n obsolete entries\n", 0, obsoleted);
+                err += QStringLiteral("    Removed %1 obsolete entries\n").arg(obsoleted);
             } else {
-                err += LU::tr("    Kept %n obsolete entries\n", 0, obsoleted);
+                err += QStringLiteral("    Kept %1 obsolete entries\n").arg(obsoleted);
             }
         }
 
         if (sameNumberHeuristicCount)
-            err += LU::tr("    Number heuristic provided %n translation(s)\n",
-                      0, sameNumberHeuristicCount);
+            err += QStringLiteral("    Number heuristic provided %1 translation(s)\n")
+                .arg(sameNumberHeuristicCount);
         if (sameTextHeuristicCount)
-            err += LU::tr("    Same-text heuristic provided %n translation(s)\n",
-                      0, sameTextHeuristicCount);
+            err += QStringLiteral("    Same-text heuristic provided %1 translation(s)\n")
+                .arg(sameTextHeuristicCount);
         if (similarTextHeuristicCount)
-            err += LU::tr("    Similar-text heuristic provided %n translation(s)\n",
-                      0, similarTextHeuristicCount);
+            err += QStringLiteral("    Similar-text heuristic provided %1 translation(s)\n")
+                .arg(similarTextHeuristicCount);
     }
     return outTor;
 }
diff --git a/qttools/src/linguist/lupdate/python.cpp b/qttools/src/linguist/lupdate/python.cpp
index d134d31..a439866 100644
--- a/qttools/src/linguist/lupdate/python.cpp
+++ b/qttools/src/linguist/lupdate/python.cpp
@@ -734,7 +734,7 @@
     const bool ok = yyInFile != nullptr;
 #endif
     if (!ok) {
-        cd.appendError(LU::tr("Cannot open %1").arg(fileName));
+        cd.appendError(QStringLiteral("Cannot open %1").arg(fileName));
         return false;
     }
 
diff --git a/qttools/src/linguist/lupdate/qdeclarative.cpp b/qttools/src/linguist/lupdate/qdeclarative.cpp
index f326853..2f8d911 100644
--- a/qttools/src/linguist/lupdate/qdeclarative.cpp
+++ b/qttools/src/linguist/lupdate/qdeclarative.cpp
@@ -105,11 +105,15 @@
             case TrFunctionAliasManager::Function_qsTr:
             case TrFunctionAliasManager::Function_QT_TR_NOOP: {
                 if (!node->arguments) {
-                    yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").arg(name));
+                    yyMsg(identLineNo)
+                        << qPrintable(QStringLiteral("%1() requires at least one argument.\n")
+                                      .arg(name));
                     return;
                 }
                 if (AST::cast<AST::TemplateLiteral *>(node->arguments->expression)) {
-                    yyMsg(identLineNo) << qPrintable(LU::tr("%1() cannot be used with template literals. Ignoring\n").arg(name));
+                    yyMsg(identLineNo)
+                        << qPrintable(QStringLiteral("%1() cannot be used with template literals. "
+                                                     "Ignoring\n").arg(name));
                     return;
                 }
 
@@ -128,7 +132,7 @@
                 }
 
                 if (!sourcetext.isEmpty())
-                    yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").arg(name));
+                    yyMsg(identLineNo) << qPrintable(QStringLiteral("//% cannot be used with %1(). Ignoring\n").arg(name));
 
                 TranslatorMessage msg(m_component, ParserTool::transcode(source),
                     comment, QString(), m_fileName,
@@ -143,7 +147,7 @@
             case TrFunctionAliasManager::Function_qsTranslate:
             case TrFunctionAliasManager::Function_QT_TRANSLATE_NOOP: {
                 if (! (node->arguments && node->arguments->next)) {
-                    yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least two arguments.\n").arg(name));
+                    yyMsg(identLineNo) << qPrintable(QStringLiteral("%1() requires at least two arguments.\n").arg(name));
                     return;
                 }
 
@@ -158,7 +162,7 @@
                     return;
 
                 if (!sourcetext.isEmpty())
-                    yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").arg(name));
+                    yyMsg(identLineNo) << qPrintable(QStringLiteral("//% cannot be used with %1(). Ignoring\n").arg(name));
 
                 QString comment;
                 bool plural = false;
@@ -184,7 +188,7 @@
             case TrFunctionAliasManager::Function_qsTrId:
             case TrFunctionAliasManager::Function_QT_TRID_NOOP: {
                 if (!node->arguments) {
-                    yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").arg(name));
+                    yyMsg(identLineNo) << qPrintable(QStringLiteral("%1() requires at least one argument.\n").arg(name));
                     return;
                 }
 
@@ -193,7 +197,7 @@
                     return;
 
                 if (!msgid.isEmpty()) {
-                    yyMsg(identLineNo) << qPrintable(LU::tr("//= cannot be used with %1(). Ignoring\n").arg(name));
+                    yyMsg(identLineNo) << qPrintable(QStringLiteral("//= cannot be used with %1(). Ignoring\n").arg(name));
                     return;
                 }
 
@@ -224,7 +228,7 @@
     void throwRecursionDepthError() final
     {
         std::cerr << qPrintable(m_fileName) << ": "
-                  << qPrintable(LU::tr("Maximum statement or expression depth exceeded"));
+                  << "Maximum statement or expression depth exceeded";
     }
 
 
@@ -302,7 +306,7 @@
         processComments(node->lastSourceLocation().end());
 
         if (!sourcetext.isEmpty() || !extracomment.isEmpty() || !msgid.isEmpty() || !extra.isEmpty()) {
-            yyMsg(node->lastSourceLocation().startLine) << qPrintable(LU::tr("Discarding unconsumed meta data\n"));
+            yyMsg(node->lastSourceLocation().startLine) << "Discarding unconsumed meta data\n";
             consumeComment();
         }
     }
@@ -360,13 +364,13 @@
             if (std::isspace(c))
                 continue;
             if (c != '"') {
-                yyMsg(loc.startLine) << qPrintable(LU::tr("Unexpected character in meta string\n"));
+                yyMsg(loc.startLine) << "Unexpected character in meta string\n";
                 break;
             }
             forever {
                 if (p >= length) {
                   whoops:
-                    yyMsg(loc.startLine) << qPrintable(LU::tr("Unterminated meta string\n"));
+                    yyMsg(loc.startLine) << "Unterminated meta string\n";
                     break;
                 }
                 c = chars[p++].unicode();
@@ -449,7 +453,7 @@
     cd.m_sourceFileName = filename;
     QFile file(filename);
     if (!file.open(QIODevice::ReadOnly)) {
-        cd.appendError(LU::tr("Cannot open %1: %2").arg(filename, file.errorString()));
+        cd.appendError(QStringLiteral("Cannot open %1: %2").arg(filename, file.errorString()));
         return false;
     }
 
diff --git a/qttools/src/linguist/lupdate/ui.cpp b/qttools/src/linguist/lupdate/ui.cpp
index 5f84a92..1737b53 100644
--- a/qttools/src/linguist/lupdate/ui.cpp
+++ b/qttools/src/linguist/lupdate/ui.cpp
@@ -135,7 +135,7 @@
 
 bool UiReader::fatalError(qint64 line, qint64 column, const QString &message)
 {
-    QString msg = LU::tr("XML error: Parse error at line %1, column %2 (%3).")
+    QString msg = QStringLiteral("XML error: Parse error at line %1, column %2 (%3).")
                           .arg(line)
                           .arg(column)
                           .arg(message);
@@ -182,7 +182,7 @@
     cd.m_sourceFileName = filename;
     QFile file(filename);
     if (!file.open(QIODevice::ReadOnly)) {
-        cd.appendError(LU::tr("Cannot open %1: %2").arg(filename, file.errorString()));
+        cd.appendError(QStringLiteral("Cannot open %1: %2").arg(filename, file.errorString()));
         return false;
     }
 
@@ -192,7 +192,7 @@
     UiReader uiReader(translator, cd, reader);
     bool result = uiReader.parse();
     if (!result)
-        cd.appendError(LU::tr("Parse error in UI file"));
+        cd.appendError(u"Parse error in UI file"_qs);
     return result;
 }
 
